angular.module('ccc-app', ['ui.bootstrap', 'monospaced.elastic', 'ngImgCrop', 'ngMaterial', 'ngSanitize', 'ui.router']);
angular.module('ccc-app').config(function($mdIconProvider, $mdThemingProvider, $stateProvider, $urlRouterProvider, $animateProvider, $mdDateLocaleProvider) {
    $mdIconProvider.fontSet('fontawesome', 'fa');
    $mdDateLocaleProvider.formatDate = function(date) {
        var day = date.getDate();
        var month = date.getMonth() + 1;
        var year = date.getFullYear();
        return (day < 10 ? '0' + day : day) + '/' + (month < 10 ? '0' + month : month) + '/' + year;
    };
    $mdDateLocaleProvider.parseDate = function(dateAsString) {
        var dateParts = dateAsString.split('/');
        var newData = new Date(dateParts[2], parseInt(dateParts[1]) - 1, dateParts[0], 0, 0, 0, 0);
        return newData;
    };
    $animateProvider.classNameFilter(/angular-animate/);
    $mdThemingProvider.definePalette('orange', {
        '50': '#ffffff',
        '100': '#ffe8d0',
        '200': '#ffcd98',
        '300': '#ffab50',
        '400': '#ff9d32',
        '500': '#ff8e13',
        '600': '#f37f00',
        '700': '#d56f00',
        '800': '#b65f00',
        '900': '#984f00',
        'A100': '#ffffff',
        'A200': '#ffe8d0',
        'A400': '#ff9d32',
        'A700': '#d56f00',
        'contrastDefaultColor': 'light',
        'contrastDarkColors': '50 100 200 A100 A200'
    });
    $mdThemingProvider.definePalette('blue', {
        '50': '#ffffff',
        '100': '#ffffff',
        '200': '#ffffff',
        '300': '#3a76c8',
        '400': '#3268b1',
        '500': '#2b5a99',
        '600': '#244c81',
        '700': '#1e3e69',
        '800': '#173051',
        '900': '#102239',
        'A100': '#d9e5f4',
        'A200': '#337ab7',
        'A400': '#3268b1',
        'A700': '#1e3e69',
        'contrastDefaultColor': 'light',
        'contrastDarkColors': '50 100 200 A100 A200'
    });
    $mdThemingProvider.theme('default').primaryPalette('orange').accentPalette('blue');
});;;;
! function(e, n) {
    var o = e();
    e.fn.dropdownHover = function(t) {
        return "ontouchstart" in document ? this : (o = o.add(this.parent()), this.each(function() {
            function r() {
                n.clearTimeout(a), n.clearTimeout(i), i = n.setTimeout(function() {
                    o.find(":focus").blur(), f.instantlyCloseOthers === !0 && o.removeClass("open"), n.clearTimeout(i), d.attr("aria-expanded", "true"), s.addClass("open"), d.trigger(l)
                }, f.hoverDelay)
            }
            var a, i, d = e(this),
                s = d.parent(),
                u = {
                    delay: 500,
                    hoverDelay: 0,
                    instantlyCloseOthers: !0
                },
                h = {
                    delay: e(this).data("delay"),
                    hoverDelay: e(this).data("hover-delay"),
                    instantlyCloseOthers: e(this).data("close-others")
                },
                l = "show.bs.dropdown",
                c = "hide.bs.dropdown",
                f = e.extend(!0, {}, u, t, h);
            s.hover(function(e) {
                return s.hasClass("open") || d.is(e.target) ? void r(e) : !0
            }, function() {
                n.clearTimeout(i), a = n.setTimeout(function() {
                    d.attr("aria-expanded", "false"), s.removeClass("open"), d.trigger(c)
                }, f.delay)
            }), d.hover(function(e) {
                return s.hasClass("open") || s.is(e.target) ? void r(e) : !0
            }), s.find(".dropdown-submenu").each(function() {
                var o, t = e(this);
                t.hover(function() {
                    n.clearTimeout(o), t.children(".dropdown-menu").show(), t.siblings().children(".dropdown-menu").hide()
                }, function() {
                    var e = t.children(".dropdown-menu");
                    o = n.setTimeout(function() {
                        e.hide()
                    }, f.delay)
                })
            })
        }))
    }, e(document).ready(function() {
        e('[data-hover="dropdown"]').dropdownHover()
    })
}(jQuery, window);;;;
var CCC = CCC || {};
CCC.STATIC = CCC.STATIC || {};
CCC.STATIC.TYPE = {
    'TRADE': '0',
    'FEEDNEWS': '1',
    'CURRENT': '2',
    'LOADCOMPLATE': '3',
    'COINPAIRS': '4',
    'CURRENTAGG': '5',
    'TOPLIST': '6',
    'TOPLISTCHANGE': '7',
    'ORDERBOOK': '8',
    'FULLORDERBOOK': '9',
    'ACTIVATION': '10',
    'FULLVOLUME': '11',
    'TRADECATCHUP': '100',
    'NEWSCATCHUP': '101',
    'TRADECATCHUPCOMPLETE': '300',
    'NEWSCATCHUPCOMPLETE': '301',
    'UNAUTHORIZED': '401'
};
CCC.STATIC.CURRENCY = CCC.STATIC.CURRENCY || {};
CCC.STATIC.CURRENCY.SYMBOL = {
    'BTC': 'Ƀ',
    'LTC': 'Ł',
    'DAO': 'Ð',
    'USD': '$',
    'CNY': '¥',
    'EUR': '€',
    'GBP': '£',
    'JPY': '¥',
    'PLN': 'zł',
    'RUB': '₽',
    'ETH': 'Ξ',
    'GOLD': 'Gold g',
    'INR': '₹',
    'BRL': 'R$',
    'KRW': '₩',
    'RUR': '₽'
};
CCC.STATIC.CURRENCY.getSymbol = function(symbol) {
    return CCC.STATIC.CURRENCY.SYMBOL[symbol] || symbol;
};
CCC.STATIC.UTIL = {
    chartColors: {
        Green: {
            Title: "Green",
            Hex: "#5cb85c"
        },
        Red: {
            Title: "Red",
            Hex: "#A11B0A"
        },
        Blue: {
            Title: "Blue",
            Hex: "#006098"
        },
        Black: {
            Title: "Black",
            Hex: "#000000"
        },
        Orange: {
            Title: "Orange",
            Hex: "#F89017"
        },
        DarkGreen: {
            Title: "Dark Green",
            Hex: "#398439"
        },
        LighRed: {
            Title: "Light Red",
            Hex: "#D44E3D"
        },
        DarkBlue: {
            Title: "Dark Blue",
            Hex: "#002387"
        },
        Yellow: {
            Title: "Yellow",
            Hex: "#FFF700"
        },
        White: {
            Title: "White",
            Hex: "#FFFFFF"
        }
    },
    exchangeNameMapping: {
        'CCCAGG': 'CryptoCompare Index',
        'BTCChina': 'BTCC',
        'Coinbase': 'GDAX'
    },
    isMobile: function(userAgent) {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4)))
            return true;
        return false;
    },
    convertToMB: function(bytes) {
        return (parseInt(bytes, 10) / 1024 / 1024).toFixed(2) + ' MB';
    },
    getNameForExchange: function(exchangeName) {
        if (this.exchangeNameMapping.hasOwnProperty(exchangeName)) {
            return this.exchangeNameMapping[exchangeName];
        }
        return exchangeName;
    },
    noExponents: function(value) {
        var data = String(value).split(/[eE]/);
        if (data.length == 1) return data[0];
        var z = '',
            sign = value < 0 ? '-' : '',
            str = data[0].replace('.', ''),
            mag = Number(data[1]) + 1;
        if (mag < 0) {
            z = sign + '0.';
            while (mag++) z += '0';
            return z + str.replace(/^\-/, '');
        }
        mag -= str.length;
        while (mag--) z += '0';
        return str + z;
    },
    reduceFloatVal: function(value) {
        value = parseFloat(value);
        var absValue = Math.abs(value);
        if (absValue > 1) {
            value = Math.round(value * 100) / 100;
            return value;
        }
        if (absValue >= 0.00001000) {
            return parseFloat(value.toPrecision(4));
        }
        if (absValue >= 0.00000100) {
            return parseFloat(value.toPrecision(3));
        }
        if (absValue >= 0.00000010) {
            return parseFloat(value.toPrecision(2));
        }
        return parseFloat(value.toPrecision(1));
    },
    reduceReal: function(value) {
        value = parseFloat(value);
        return parseFloat(value.toFixed(8));
    },
    convertCurrentKeyToAll: function(key) {
        var valuesArray = key.split("~");
        valuesArray[0] = CCC.STATIC.TYPE.CURRENTAGG;
        valuesArray[1] = 'CCCAGG';
        return valuesArray.join('~');
    },
    convertCurrentKeyToTrade: function(key) {
        var valuesArray = key.split("~");
        valuesArray[0] = CCC.STATIC.TYPE.TRADE;
        return valuesArray.join('~');
    },
    convertValueToDisplay: function(symbol, value, filterNumberFunctionAngularJS, type, fullNumbers) {
        var prefix = '';
        var valueSign = 1;
        value = parseFloat(value);
        var valueAbs = Math.abs(value);
        var decimalsOnBigNumbers = 2;
        var decimalsOnNormalNumbers = 2;
        var decimalsOnSmallNumbers = 4;
        if (fullNumbers === true) {
            decimalsOnBigNumbers = 2;
            decimalsOnNormalNumbers = 0;
            decimalsOnSmallNumbers = 4;
        }
        if (type == "8decimals") {
            decimalsOnBigNumbers = 4;
            decimalsOnNormalNumbers = 8;
            decimalsOnSmallNumbers = 8;
            if (value < 0.0001 && value >= 0.00001) {
                decimalsOnSmallNumbers = 4;
            }
            if (value < 0.001 && value >= 0.0001) {
                decimalsOnSmallNumbers = 5;
            }
            if (value < 0.01 && value >= 0.001) {
                decimalsOnSmallNumbers = 6;
            }
            if (value < 0.1 && value >= 0.01) {
                decimalsOnSmallNumbers = 7;
            }
        }
        if (symbol != '') {
            prefix = symbol + ' ';
        }
        if (value < 0) {
            valueSign = -1;
        }
        if (value == 0) {
            return prefix + '0';
        }
        if (value < 0.00001000 && value >= 0.00000100 && decimalsOnSmallNumbers > 3) {
            decimalsOnSmallNumbers = 3;
        }
        if (value < 0.00000100 && value >= 0.00000010 && decimalsOnSmallNumbers > 2) {
            decimalsOnSmallNumbers = 2;
        }
        if (value < 0.00000010 && decimalsOnSmallNumbers > 1) {
            decimalsOnSmallNumbers = 1;
        }
        if (type == "short" || type == "8decimals") {
            if (valueAbs > 1000000000) {
                valueAbs = valueAbs / 1000000000;
                return prefix + filterNumberFunctionAngularJS(valueSign * valueAbs, decimalsOnBigNumbers) + ' B';
            }
            if (valueAbs > 1000000) {
                valueAbs = valueAbs / 1000000;
                return prefix + filterNumberFunctionAngularJS(valueSign * valueAbs, decimalsOnBigNumbers) + ' M';
            }
            if (valueAbs > 10000) {
                valueAbs = valueAbs / 1000;
                return prefix + filterNumberFunctionAngularJS(valueSign * valueAbs, decimalsOnBigNumbers) + ' K';
            }
            if (type == "8decimals" && valueAbs >= 100) {
                return prefix + filterNumberFunctionAngularJS(valueSign * valueAbs, decimalsOnBigNumbers);
            }
            if (valueAbs >= 1) {
                return prefix + filterNumberFunctionAngularJS(valueSign * valueAbs, decimalsOnNormalNumbers);
            }
            return prefix + (valueSign * valueAbs).toPrecision(decimalsOnSmallNumbers);
        } else {
            if (valueAbs >= 1) {
                return prefix + filterNumberFunctionAngularJS(valueSign * valueAbs, decimalsOnNormalNumbers);
            }
            return prefix + this.noExponents((valueSign * valueAbs).toPrecision(decimalsOnSmallNumbers));
        }
    }
};
CCC.TRADE = CCC.TRADE || {};
CCC.TRADE.FLAGS = {
    'SELL': 0x1,
    'BUY': 0x2,
    'UNKNOWN': 0x4
}
CCC.TRADE.FIELDS = {
    'T': 0x0,
    'M': 0x0,
    'FSYM': 0x0,
    'TSYM': 0x0,
    'F': 0x0,
    'ID': 0x1,
    'TS': 0x2,
    'Q': 0x4,
    'P': 0x8,
    'TOTAL': 0x10
};
CCC.TRADE.DISPLAY = CCC.TRADE.DISPLAY || {};
CCC.TRADE.DISPLAY.FIELDS = {
    'T': {
        "Show": false
    },
    'M': {
        "Show": true,
        'Filter': 'Market'
    },
    'FSYM': {
        "Show": true,
        'Filter': 'CurrencySymbol'
    },
    'TSYM': {
        "Show": true,
        'Filter': 'CurrencySymbol'
    },
    'F': {
        "Show": true,
        'Filter': 'TradeFlag'
    },
    'ID': {
        "Show": true,
        'Filter': 'Text'
    },
    'TS': {
        'Show': true,
        'Filter': 'Date',
        'Format': 'yyyy MMMM dd HH:mm:ss'
    },
    'Q': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'FSYM'
    },
    'P': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TSYM'
    },
    'TOTAL': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TSYM'
    }
};
CCC.TRADE.pack = function(tradeObject) {
    var mask = 0;
    var packedTrade = '';
    for (var field in tradeObject) {
        packedTrade += '~' + tradeObject[field];
        mask |= this.FIELDS[field];
    }
    return packedTrade.substr(1) + '~' + mask.toString(16);
};
CCC.TRADE.unpack = function(tradeString) {
    var valuesArray = tradeString.split("~");
    var valuesArrayLenght = valuesArray.length;
    var mask = valuesArray[valuesArrayLenght - 1];
    var maskInt = parseInt(mask, 16);
    var unpackedTrade = {};
    var currentField = 0;
    for (var property in this.FIELDS) {
        if (this.FIELDS[property] === 0) {
            unpackedTrade[property] = valuesArray[currentField];
            currentField++;
        } else if (maskInt & this.FIELDS[property]) {
            unpackedTrade[property] = valuesArray[currentField];
            currentField++;
        }
    }
    return unpackedTrade;
}
CCC.TRADE.getKey = function(tradeObject) {
    return tradeObject['T'] + '~' + tradeObject['M'] + '~' + tradeObject['FSYM'] + '~' + tradeObject['TSYM'];
};
CCC.CURRENT = CCC.CURRENT || {};
CCC.CURRENT.FLAGS = {
    'PRICEUP': 0x1,
    'PRICEDOWN': 0x2,
    'PRICEUNCHANGED': 0x4,
    'BIDUP': 0x8,
    'BIDDOWN': 0x10,
    'BIDUNCHANGED': 0x20,
    'OFFERUP': 0x40,
    'OFFERDOWN': 0x80,
    'OFFERUNCHANGED': 0x100,
    'AVGUP': 0x200,
    'AVGDOWN': 0x400,
    'AVGUNCHANGED': 0x800
};
CCC.CURRENT.FIELDS = {
    'TYPE': 0x0,
    'MARKET': 0x0,
    'FROMSYMBOL': 0x0,
    'TOSYMBOL': 0x0,
    'FLAGS': 0x0,
    'PRICE': 0x1,
    'BID': 0x2,
    'OFFER': 0x4,
    'LASTUPDATE': 0x8,
    'AVG': 0x10,
    'LASTVOLUME': 0x20,
    'LASTVOLUMETO': 0x40,
    'LASTTRADEID': 0x80,
    'VOLUMEDAY': 0x100,
    'VOLUMEDAYTO': 0x200,
    'VOLUME24HOUR': 0x400,
    'VOLUME24HOURTO': 0x800,
    'OPENDAY': 0x1000,
    'HIGHDAY': 0x2000,
    'LOWDAY': 0x4000,
    'OPEN24HOUR': 0x8000,
    'HIGH24HOUR': 0x10000,
    'LOW24HOUR': 0x20000,
    'LASTMARKET': 0x40000
};
CCC.CURRENT.DISPLAY = CCC.CURRENT.DISPLAY || {};
CCC.CURRENT.DISPLAY.FLAGSLINK = {
    'PRICEUP': ['PRICEDOWN', 'PRICEUNCHANGED'],
    'PRICEDOWN': ['PRICEUP', 'PRICEUNCHANGED'],
    'PRICEUNCHANGED': ['PRICEUP', 'PRICEDOWN'],
    'BIDUP': ['BIDDOWN', 'BIDUNCHANGED'],
    'BIDDOWN': ['BIDUP', 'BIDUNCHANGED'],
    'BIDUNCHANGED': ['BIDUP', 'BIDDOWN'],
    'OFFERUP': ['OFFERDOWN', 'OFFERUNCHANGED'],
    'OFFERDOWN': ['OFFERUP', 'OFFERUNCHANGED'],
    'OFFERUNCHANGED': ['OFFERUP', 'OFFERDOWN'],
    'AVGUP': ['AVGDOWN', 'AVGUNCHANGED'],
    'AVGDOWN': ['AVGUP', 'AVGUNCHANGED'],
    'AVGUNCHANGED': ['AVGUP', 'AVGDOWN']
};
CCC.CURRENT.DISPLAY.FIELDS = {
    'TYPE': {
        'Show': false,
        'Default': '5'
    },
    'MARKET': {
        'Show': true,
        'Filter': 'Market',
        'Default': 'N/A'
    },
    'FROMSYMBOL': {
        'Show': false,
        'Default': 'BTC'
    },
    'TOSYMBOL': {
        'Show': false,
        'Default': 'BTC'
    },
    'FLAGS': {
        'Show': false,
        'Default': 0
    },
    'PRICE': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'BID': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'OFFER': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'LASTUPDATE': {
        'Show': true,
        'Filter': 'Date',
        'Format': 'yyyy MMMM dd HH:mm:ss',
        'Default': Math.floor((new Date()).getTime() / 1000)
    },
    'AVG': {
        'Show': true,
        ' Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'LASTVOLUME': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'FROMSYMBOL',
        'Default': 0,
        'SortNumberAsWell': false
    },
    'LASTVOLUMETO': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 0,
        'SortNumberAsWell': false
    },
    'LASTTRADEID': {
        'Show': true,
        'Filter': 'String',
        'Default': 0
    },
    'VOLUMEDAY': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'FROMSYMBOL',
        'Default': 0,
        'SortNumberAsWell': false
    },
    'VOLUMEDAYTO': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 0,
        'SortNumberAsWell': false
    },
    'VOLUME24HOUR': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'FROMSYMBOL',
        'Default': 0,
        'SortNumberAsWell': true
    },
    'VOLUME24HOURTO': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 0,
        'SortNumberAsWell': true
    },
    'OPENDAY': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'HIGHDAY': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'LOWDAY': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'OPEN24HOUR': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'HIGH24HOUR': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'LOW24HOUR': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TOSYMBOL',
        'Default': 1,
        'SortNumberAsWell': false
    },
    'LASTMARKET': {
        'Show': true,
        'Filter': 'String',
        'Default': 'N/A'
    }
};
CCC.CURRENT.pack = function(currentObject) {
    var mask = 0;
    var packedCurrent = '';
    for (var property in this.FIELDS) {
        if (currentObject.hasOwnProperty(property)) {
            packedCurrent += '~' + currentObject[property];
            mask |= this.FIELDS[property];
        }
    }
    return packedCurrent.substr(1) + '~' + mask.toString(16);
};
CCC.CURRENT.unpack = function(value) {
    var valuesArray = value.split("~");
    var valuesArrayLenght = valuesArray.length;
    var mask = valuesArray[valuesArrayLenght - 1];
    var maskInt = parseInt(mask, 16);
    var unpackedCurrent = {};
    var currentField = 0;
    for (var property in this.FIELDS) {
        if (this.FIELDS[property] === 0) {
            unpackedCurrent[property] = valuesArray[currentField];
            currentField++;
        } else if (maskInt & this.FIELDS[property]) {
            if (property === 'LASTMARKET') {
                unpackedCurrent[property] = valuesArray[currentField];
            } else {
                unpackedCurrent[property] = parseFloat(valuesArray[currentField]);
            }
            currentField++;
        }
    }
    return unpackedCurrent;
};
CCC.CURRENT.getKey = function(currentObject) {
    return currentObject['TYPE'] + '~' + currentObject['MARKET'] + '~' + currentObject['FROMSYMBOL'] + '~' + currentObject['TOSYMBOL'];
};
CCC.CURRENT.getKeyFromStreamerData = function(streamerData) {
    var valuesArray = streamerData.split("~");
    return valuesArray[0] + '~' + valuesArray[1] + '~' + valuesArray[2] + '~' + valuesArray[3];
};
CCC.ORDER = CCC.ORDER || {};
CCC.ORDER.FLAGS = {
    'ADD': 0x1,
    'REMOVE': 0x2,
    'CHANGE': 0x4,
    'NOACTION': 0x8
};
CCC.ORDER.SIDE = {
    'BID': 0x1,
    'ASK': 0x2
};
CCC.ORDER.FIELDS = {
    'T': 0x0,
    'M': 0x0,
    'FSYM': 0x0,
    'TSYM': 0x0,
    'S': 0x0,
    'F': 0x0,
    'SEQ': 0x0,
    'P': 0x0,
    'Q': 0x0
};
CCC.ORDER.FIELDSNOKEY = {
    'P': 0x0,
    'Q': 0x0
};
CCC.ORDER.DISPLAY = CCC.ORDER.DISPLAY || {};
CCC.ORDER.DISPLAY.FIELDS = {
    'T': {
        "Show": false,
        'Filter': 'None'
    },
    'M': {
        "Show": true,
        'Filter': 'Market'
    },
    'FSYM': {
        "Show": true,
        'Filter': 'CurrencySymbol'
    },
    'TSYM': {
        "Show": true,
        'Filter': 'CurrencySymbol'
    },
    'S': {
        "Show": true,
        'Filter': 'Integer'
    },
    'F': {
        "Show": true,
        'Filter': 'Integer'
    },
    'SEQ': {
        'Show': false,
        'Filter': 'Integer'
    },
    'P': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'TSYM'
    },
    'Q': {
        'Show': true,
        'Filter': 'Number',
        'Symbol': 'NONE'
    }
};
CCC.ORDER.pack = function(orderObject) {
    var packedOrder = '';
    for (var property in this.FIELDS) {
        if (orderObject.hasOwnProperty(property)) {
            packedOrder += '~' + orderObject[property];
        }
    }
    return packedOrder.substr(1);
};
CCC.ORDER.packNoType = function(orderObject) {
    var packedOrder = '';
    for (var property in this.FIELDS) {
        if (property == 'T') {
            continue;
        }
        if (orderObject.hasOwnProperty(property)) {
            packedOrder += '~' + orderObject[property];
        }
    }
    return packedOrder.substr(1);
};
CCC.ORDER.packNoKey = function(orderObject) {
    var packedOrder = '';
    for (var property in this.FIELDSNOKEY) {
        if (orderObject.hasOwnProperty(property)) {
            packedOrder += '~' + orderObject[property];
        }
    }
    return packedOrder.substr(1);
};
CCC.ORDER.unpack = function(orderString) {
    var valuesArray = orderString.split("~");
    var totalValues = valuesArray.length;
    var unpackedOrder = {};
    var currentField = 0;
    for (var property in this.FIELDS) {
        if (this.FIELDS[property] === 0 && currentField < totalValues) {
            if (this.DISPLAY.FIELDS[property].Filter == 'Number') {
                unpackedOrder[property] = parseFloat(valuesArray[currentField]);
            } else if (this.DISPLAY.FIELDS[property].Filter == 'Integer') {
                unpackedOrder[property] = parseInt(valuesArray[currentField], 10);
            } else {
                unpackedOrder[property] = valuesArray[currentField];
            }
            currentField++;
        }
    }
    return unpackedOrder;
};
CCC.ORDER.getKey = function(orderObject) {
    return orderObject['T'] + '~' + orderObject['M'] + '~' + orderObject['FSYM'] + '~' + orderObject['TSYM'];
};
CCC.ORDER.getOrderBookKey = function(orderObject) {
    return orderObject['M'] + '~' + orderObject['FSYM'] + '~' + orderObject['TSYM'];
};
CCC.ORDER.unpackOrderBookKey = function(orderBookKey) {
    var parts = orderBookKey.split('~');
    return {
        M: parts[0],
        FSYM: parts[1],
        TSYM: parts[2]
    };
};
CCC.ORDER.getObjectKey = function(orderObject) {
    return orderObject['P'] + '~' + orderObject['S'];
};
CCC.ORDER.getExchangeKey = function(orderObject) {
    return orderObject['T'] + '~' + orderObject['M'];
};
CCC.ORDER.getTypeText = function(orderObject) {
    for (var property in this.FLAGS) {
        if (this.FLAGS[property] === orderObject.F) {
            return property;
        }
    }
    return "N/A";
};;;;
angular.module('ccc-app').factory('cookieService', ['$rootScope', function cookieServiceFactory($rootScope) {
    var cookieServiceInterface = {};
    cookieServiceInterface.setItem = function(key, value) {
        cookieServiceInterface.setCookie(key, value, 1000, '/');
    };
    cookieServiceInterface.removeItem = function(key, value) {
        cookieServiceInterface.setCookie(key, value, -1, '/');
    };
    cookieServiceInterface.setCookie = function(cname, cvalue, exdays, path) {
        var d = new Date();
        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toUTCString();
        var cnpCookie = cname + "=" + cvalue + "; " + expires + "; path=" + path;
        document.cookie = cnpCookie;
    };
    cookieServiceInterface.getCookie = function(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1);
            if (c.indexOf(name) == 0) return c.substring(name.length, c.length);
        }
        return "";
    };
    return cookieServiceInterface;
}]);
angular.module('ccc-app').factory('cccLocalStorage', ['cookieService', function cccLocalStorageFactory(cookieService) {
    var cccLocalStorageInterface = {};
    var localStorageSupported = false;
    try {
        localStorage.setItem("localStorageSupported", true);
        localStorage.removeItem("localStorageSupported");
        localStorageSupported = true;
    } catch (e) {
        localStorageSupported = false;
    };
    cccLocalStorageInterface.setObject = function(key, value) {
        if (localStorageSupported) {
            localStorage.setItem(key, JSON.stringify(value));
        }
    };
    cccLocalStorageInterface.getObject = function(key) {
        var objectToReturn = {};
        if (localStorageSupported) {
            objectToReturn = localStorage.getItem(key);
            if (objectToReturn == null) {
                objectToReturn = {};
            } else {
                objectToReturn = JSON.parse(objectToReturn);
            }
        }
        return objectToReturn;
    };
    cccLocalStorageInterface.setItem = function(key, value) {
        if (localStorageSupported) {
            localStorage.setItem(key, value);
        } else {
            cookieService.setItem(key, value);
        }
    };
    cccLocalStorageInterface.removeItem = function(key) {
        if (localStorageSupported) {
            localStorage.removeItem(key);
        } else {
            cookieService.removeItem(key);
        }
    };
    cccLocalStorageInterface.getText = function(key) {
        var itemValue = '';
        if (localStorageSupported) {
            itemValue = localStorage.getItem(key);
        } else {
            itemValue = cookieService.getCookie(key);
        }
        if (itemValue === null) {
            return '';
        }
        return itemValue;
    }
    cccLocalStorageInterface.getInteger = function(key) {
        var itemValue = 0;
        if (localStorageSupported) {
            itemValue = localStorage.getItem(key);
        } else {
            itemValue = cookieService.getCookie(key);
        }
        if (itemValue === null) {
            return 0;
        }
        return parseInt(itemValue, 10);
    };
    return cccLocalStorageInterface;
}]);
angular.module('ccc-app').factory('cccLightsService', ['$rootScope', 'cookieService', function cccLightsService($rootScope, cookieService) {
    var cccLightsServiceInterface = {};
    var lightsOffKey = 'lightsOff';
    cccLightsServiceInterface.isOn = function() {
        if (cookieService.getCookie(lightsOffKey) === '') {
            return true;
        }
        return false;
    };
    cccLightsServiceInterface.turnOn = function() {
        cookieService.removeItem(lightsOffKey, '1');
        $rootScope.$emit("LightsChange");
    };
    cccLightsServiceInterface.turnOff = function() {
        cookieService.setItem(lightsOffKey, '1');
        $rootScope.$emit("LightsChange", '1');
    };
    return cccLightsServiceInterface;
}]);
angular.module('ccc-app').factory('profileManager', ['$http', '$filter', function profileManagerFactory($http, $filter) {
    var profileStatsData = {};
    var profileData = {};
    var utilStatic = CCC.STATIC.UTIL;
    return {
        setAvatarUrl: function(avatarUrl) {
            profileData.AvatarUrl = avatarUrl;
        },
        setId: function(cryptopianId) {
            profileData.Id = cryptopianId;
        },
        setBannedStatus: function(isBanned) {
            profileData.isBanned = isBanned;
        },
        setCreationDate: function(createdOnTimestamp) {
            profileData.CreationDate = createdOnTimestamp;
        },
        setUsername: function(username) {
            profileData.Username = username;
        },
        setComment: function(comment) {
            profileData.Comment = comment;
        },
        setProfileStatsData: function(apiResponse) {
            profileStatsData = apiResponse["Data"];
        },
        getProfileStatsData: function() {
            return profileStatsData;
        },
        getBannedStatus: function() {
            return profileData.isBanned;
        },
        getStatus: function() {
            if (profileData.isBanned == true) {
                return "Banned";
            }
            return "Active";
        },
        getCreationDate: function() {
            return $filter('date')(new Date(profileData.CreationDate * 1000), 'mediumDate');
        },
        getProfileStat: function(statName, showSummaryValue) {
            if (profileStatsData.hasOwnProperty(statName)) {
                if (showSummaryValue) {
                    return utilStatic.convertValueToDisplay("", profileStatsData[statName].Value || 0, $filter('number'), 'short', true);
                }
                return profileStatsData[statName].Value || 0;
            }
            return 0;
        },
        getProfileBadges: function() {
            if (profileStatsData.hasOwnProperty("Badges")) {
                return profileStatsData["Badges"];
            }
            return [];
        },
        getFollowers: function(userId, lastId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['cId'] = userId;
            if (lastId) {
                paramsForCall['params']['lId'] = lastId;
            }
            return $http.get("/api/cryptopian/followers/", paramsForCall);
        },
        getFollowing: function(userId, lastId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['cId'] = userId;
            if (lastId) {
                paramsForCall['params']['lId'] = lastId;
            }
            return $http.get("/api/cryptopian/following/", paramsForCall);
        },
        getAvatarUrl: function() {
            return profileData.AvatarUrl;
        },
        getId: function() {
            return profileData.Id;
        },
        getUsername: function() {
            return profileData.Username;
        },
        getComment: function() {
            return profileData.Comment;
        },
        getTotalActivity: function(showSummaryValue) {
            var totalActivities = 0;
            if (profileStatsData.hasOwnProperty('Posts')) {
                totalActivities += parseInt(profileStatsData.Posts.Value);
            }
            if (profileStatsData.hasOwnProperty('Reviews')) {
                totalActivities += parseInt(profileStatsData.Reviews.Value);
            }
            if (profileStatsData.hasOwnProperty('Following')) {
                totalActivities += parseInt(profileStatsData.Following.Value);
            }
            if (profileStatsData.hasOwnProperty('Comments')) {
                totalActivities += parseInt(profileStatsData.Comments.Value);
            }
            if (profileStatsData.hasOwnProperty('Agrees')) {
                totalActivities += parseInt(profileStatsData.Agrees.Value);
            }
            if (profileStatsData.hasOwnProperty('Disagrees')) {
                totalActivities += parseInt(profileStatsData.Disagrees.Value);
            }
            if (profileStatsData.hasOwnProperty('QuizzesTaken')) {
                totalActivities += parseInt(profileStatsData.QuizzesTaken.Value);
            }
            if (showSummaryValue) {
                return utilStatic.convertValueToDisplay("", totalActivities, $filter('number'), 'short', true);
            }
            return totalActivities;
        }
    };
}]);
angular.module('ccc-app').factory('userManager', ['$rootScope', '$http', 'toastNotifications', function userManagerFactory($rootScope, $http, toastNotifications) {
    var userProperties = {
        'isLoggedIn': false,
        'Id': '',
        'Username': '',
        'Activated': false,
        'AvatarUrl': '',
        'EmailAddress': '',
        'Roles': [],
        'Portfolios': [],
        'isFollowing': false,
        'isShowingLogin': false
    };
    var userProfileData = {};
    var setLoggedInPrivate = function(value) {
        userProperties.isLoggedIn = value;
        $rootScope.$emit("LoginValueChange", value);
    };
    var mergeUserProperties = function(newUserProperties) {
        for (var userProp in newUserProperties) {
            userProperties[userProp] = newUserProperties[userProp];
        }
    };
    return {
        FOLLOWING: {
            CRYPTOPIAN: 0,
            COIN: 1,
            EXCHANGE: 2
        },
        initUser: function(newUserProperties) {
            mergeUserProperties(newUserProperties);
        },
        setUserProfileData: function(apiResponse) {
            userProfileData = apiResponse["Data"];
        },
        updateProfileEmailNotificationsNoEmail: function(value) {
            if (userProfileData.hasOwnProperty('Notifications')) {
                var notifications = userProfileData['Notifications'];
                notifications[0].CurrentValue = value;
                if (value) {
                    for (var i = 1; i < notifications.length; i++) {
                        if (notifications[i].Type == 'checkbox') {
                            notifications[i].CurrentValue = false;
                        }
                        if (notifications[i].Type == 'dropdown') {
                            notifications[i].CurrentValue = notifications[i].Values[notifications[i].Values.length - 1];
                        }
                    }
                } else {
                    for (var i = 1; i < notifications.length; i++) {
                        if (notifications[i].Type == 'checkbox') {
                            notifications[i].CurrentValue = true;
                        }
                        if (notifications[i].Type == 'dropdown') {
                            notifications[i].CurrentValue = notifications[i].Values[0];
                        }
                    }
                }
                userProfileData['Notifications'] = notifications;
            }
        },
        setUserStatsData: function(apiResponse) {
            userStatsData = apiResponse["Data"];
        },
        setCryptopianRoles: function(value) {
            userProperties.Roles = value;
        },
        setLoggedIn: function(value) {
            setLoggedInPrivate(value);
        },
        setCryptopianId: function(value) {
            userProperties.Id = value;
        },
        setUsername: function(value) {
            userProperties.Username = value;
        },
        setAvatarUrl: function(value) {
            userProperties.AvatarUrl = value;
        },
        setEmailAddress: function(value) {
            userProperties.EmailAddress = value;
        },
        setActivated: function(value) {
            userProperties.Activated = value;
        },
        setFollowing: function(value) {
            userProperties.isFollowing = value;
        },
        setShowingLogin: function(value) {
            userProperties.isShowingLogin = value;
        },
        setPortfolioSummary: function(apiResponse) {
            userProperties.PortfolioSummary = apiResponse.Data;
        },
        getActivated: function() {
            return userProperties.Activated;
        },
        isFollowing: function() {
            return userProperties.isFollowing;
        },
        isLoggedIn: function() {
            return userProperties.isLoggedIn;
        },
        isShowingLogin: function() {
            return userProperties.isShowingLogin;
        },
        getCryptopianId: function() {
            return userProperties.Id;
        },
        getUsername: function() {
            return userProperties.Username;
        },
        getAvatarUrl: function() {
            return userProperties.AvatarUrl;
        },
        getEmailAddress: function() {
            return userProperties.EmailAddress;
        },
        getUserProfileData: function() {
            return userProfileData;
        },
        getUserStatsData: function() {
            return userStatsData;
        },
        getCryptopianAsFollower: function() {
            return {
                Id: userProperties.Id,
                Name: userProperties.Username,
                ImageUrl: userProperties.AvatarUrl,
                Url: "/profile/" + userProperties.Username + "/",
                Type: "Cryptopian"
            };
        },
        logout: function() {
            $http.get("/api/cryptopian/logout/").success(function(data, status, headers, config) {
                toastNotifications.addNotification('success', '<div>Logout successfull.</div>' + '<div>Bye, bye ' + userProperties.Username + '. We hope to see you again soon!</div>');
                setLoggedInPrivate(false);
                mergeUserProperties(data.Data);
            }).error(function(data, status, headers, config) {
                toastNotifications.addNotification('error', '<div>Could not log out.</div>' + '<div>It seems you are not logged in.</div>');
            });
        },
        updateFields: function(objectWithUpdateFields) {
            return $http.post("/api/cryptopian/update/", objectWithUpdateFields);
        },
        changeFollowingStatus: function(nodeId, followingType) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['id'] = nodeId;
            paramsForCall['params']['ft'] = followingType;
            return $http.get("/api/cryptopian/follow/", paramsForCall);
        },
        banCryptopian: function(nodeId, reason) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['id'] = nodeId;
            paramsForCall['params']['reason'] = reason;
            return $http.get("/api/cryptopian/ban/", paramsForCall);
        },
        unBanCryptopian: function(nodeId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['id'] = nodeId;
            return $http.get("/api/cryptopian/unban/", paramsForCall);
        },
        checkFollowingStatus: function(nodeId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['id'] = nodeId;
            return $http.get("/api/cryptopian/isfollowing/", paramsForCall);
        },
        getFollowers: function(userId, lastId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['cId'] = userId;
            if (lastId) {
                paramsForCall['params']['lId'] = lastId;
            }
            return $http.get("/api/cryptopian/followers/", paramsForCall);
        },
        deleteAllForumActivity: function(cryptopianId) {
            return $http.get("/api/forum/post/delete/", {
                params: {
                    cryptopianId: cryptopianId
                }
            });
        },
        getFollowing: function(userId, lastId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['cId'] = userId;
            if (lastId) {
                paramsForCall['params']['lId'] = lastId;
            }
            return $http.get("/api/cryptopian/following/", paramsForCall);
        },
        loadProfileDataFromApi: function() {
            return $http.get("/api/cryptopian/userinfo/");
        },
        hasSubscription: function(subName) {
            if (userProperties.Roles.length == 0) {
                return false;
            }
            if (userProperties.Roles.indexOf(subName) > -1) {
                return true;
            }
            return false;
        },
        canDelete: function() {
            if (userProperties.Roles.length == 0) {
                return false;
            }
            if (userProperties.Roles.indexOf("ForumMod") > -1) {
                return true;
            }
            return false;
        },
        canMakeSticky: function() {
            if (userProperties.Roles.length == 0) {
                return false;
            }
            if (userProperties.Roles.indexOf("Admin (do not use)") > -1) {
                return true;
            }
            return false;
        },
        canBan: function() {
            if (userProperties.Roles.length == 0) {
                return false;
            }
            if (userProperties.Roles.indexOf("ForumAdmin") > -1) {
                return true;
            }
            return false;
        },
        canDeleteAllForumActivity: function() {
            if (userProperties.Roles.length == 0) {
                return false;
            }
            if (userProperties.Roles.indexOf("Admin (do not use)") > -1) {
                return true;
            }
            return false;
        },
        canEdit: function(idOfOwner) {
            if (!userProperties.isLoggedIn) {
                return userProperties.isLoggedIn;
            }
            if (userProperties.Id == idOfOwner) {
                return true;
            }
            if (userProperties.Roles.length == 0) {
                return false;
            }
            if (userProperties.Roles.indexOf("Admin (do not use)") > -1) {
                return true;
            }
            return false;
        }
    };
}]);
angular.module('ccc-app').factory('totals', ['$filter', function totalsFactory($filter) {
    var totals = {};
    var utilStatic = CCC.STATIC.UTIL;
    var text = {
        'comment': {
            'p': 'comments',
            's': 'comment',
            'sValues': [1]
        },
        'pageView': {
            'p': 'page views',
            's': 'page view',
            'sValues': [1]
        }
    }
    var totalsInterface = {};
    totalsInterface.postsOnPage = function(pageId, apiResponse) {
        totals['totalPosts'] = apiResponse['Total'][pageId]['Posts'];
    };
    totalsInterface.pageViews = function(apiResponse) {
        if (apiResponse.Type == "100") {
            totals['totalPageViews'] = apiResponse.PageViews;
        } else {
            totals['totalPageViews'] = 0;
        }
    };
    totalsInterface.new = function(name, value) {
        totals[name] = value;
    };
    totalsInterface.exists = function(name) {
        if (totals.hasOwnProperty(name)) {
            return true;
        }
        return false;
    };
    totalsInterface.getText = function(name, base) {
        var currentTotal = totals[name] || 0;
        if (text.hasOwnProperty(base)) {
            if (text[base].sValues.indexOf(currentTotal) > -1) {
                return text[base].s;
            } else {
                return text[base].p;
            }
        }
        return "";
    };
    totalsInterface.inc = function(name, value) {
        if (totals.hasOwnProperty(name)) {
            totals[name] += value;
        }
    };
    totalsInterface.dec = function(name, value) {
        if (totals.hasOwnProperty(name)) {
            totals[name] -= value;
        }
    };
    totalsInterface.get = function(name) {
        if (totals.hasOwnProperty(name)) {
            return utilStatic.convertValueToDisplay('', totals[name], $filter('number'), 'short', true)
        }
        return 0;
    };
    totalsInterface.getFullNumber = function(name) {
        if (totals.hasOwnProperty(name)) {
            return utilStatic.convertValueToDisplay('', totals[name], $filter('number'), 'full', true)
        }
        return 0;
    };
    return totalsInterface;
}]);
angular.module('ccc-app').factory('pageInfo', ['$http', '$timeout', '$filter', '$window', '$location', 'dateParsing', function pageInfoFactory($http, $timeout, $filter, $window, $location, dateParsing) {
    var utilStatic = CCC.STATIC.UTIL;
    var sideBarSlot = {
        isActive: false,
        link: '',
        imageUrl: ''
    };
    var aboutItems = [];
    var displayAboutItems = [];
    var exchangesInfo = {};
    var pageTrackingCode = 0;
    var pageTrackingPromise;
    var pageTrackingType;
    var secondLevelNav = [];
    var currentPostId = 0;
    var currentReviewId = 0;
    var seoInfo = {};
    var initialSeoInfo = {};
    var generalInfo = {};
    var pageSubs = [];
    var streamerDataRaw = [];
    var pageViewRecorded = true;
    var ICOInfo = {};
    var ICOTableItems = [];
    return {
        trackPage: function(trackingCode, type) {
            if (trackingCode) {
                pageTrackingCode = trackingCode;
                pageTrackingType = type;
                if (pageTrackingPromise) {
                    $timeout.cancel(pageTrackingPromise);
                }
                pageTrackingPromise = $timeout(function() {
                    var objectToPost = {};
                    objectToPost.Code = pageTrackingCode;
                    objectToPost.Type = pageTrackingType;
                    $http.post("/api/tracking/pageview/", objectToPost);
                    if (!pageViewRecorded) {
                        $window.ga('send', 'pageview', {
                            page: $location.url()
                        });
                    } else {
                        pageViewRecorded = false;
                    }
                }, 10000, false);
            }
        },
        changeICOToOngoing: function() {
            if (ICOInfo.Status == "Upcoming") {
                ICOInfo.Status = "Ongoing"
            };
        },
        changeICOToFinished: function() {
            if (ICOInfo.Status == "Ongoing") {
                ICOInfo.Status = "Finished"
            };
        },
        isICOStage: function() {
            return ICOInfo.Status == "Ongoing" || ICOInfo.Status == "Upcoming";
        },
        isTradingStage: function() {
            return ICOInfo.Status == "N/A" || ICOInfo.Status == "Finished";
        },
        didNotDoAnICO: function() {
            return ICOInfo.Status == "N/A";
        },
        isICOOngoing: function() {
            return ICOInfo.Status == "Ongoing";
        },
        isICOUpcoming: function() {
            return ICOInfo.Status == "Upcoming";
        },
        isICOFinished: function() {
            return ICOInfo.Status == "Finished";
        },
        hasICOData: function() {
            return ICOInfo.Status != null && ICOInfo.Status != "N/A";
        },
        hasICOStartDate: function() {
            return ICOInfo.hasOwnProperty('Date') && ICOInfo.Date > 0;
        },
        hasICOEndDate: function() {
            return ICOInfo.hasOwnProperty('EndDate') && ICOInfo.EndDate > 0;
        },
        getICOFeatures: function() {
            return ICOInfo.Features;
        },
        getICOWebsite: function() {
            return ICOInfo.WebsiteLink;
        },
        getICOWhitePaper: function() {
            return ICOInfo.WhitePaperLink;
        },
        getTotalSupply: function() {
            return generalInfo.TotalCoinSupply;
        },
        getInvestorPercent: function() {
            return ICOInfo.TokenPercentageForInvestors;
        },
        getICOFundingTarget: function() {
            return ICOInfo.FundingTarget;
        },
        getICOFundinCap: function() {
            return ICOInfo.FundingCap;
        },
        getICOStartPrice: function() {
            if (ICOInfo.StartPrice == "N/A") {
                return ICOInfo.StartPrice
            };
            return utilStatic.convertValueToDisplay(ICOInfo.StartPriceCurrency, ICOInfo.StartPrice, $filter('number'), 'short', false)
        },
        getFundsRaisedUSD: function() {
            return ICOInfo.FundsRaisedUSD;
        },
        getAveragePriceUSD: function() {
            var avgPrice = "N/A";
            var funds = parseInt(ICOInfo.FundsRaisedUSD);
            var percent = parseInt(ICOInfo.TokenPercentageForInvestors);
            var tokens = parseInt(ICOInfo.ICOTokenSupply);
            if (isNaN(funds) || funds == 0) {
                return avgPrice;
            }
            if (isNaN(percent) || percent == 0) {
                return avgPrice;
            }
            if (isNaN(tokens) || tokens == 0) {
                return avgPrice;
            }
            avgPrice = funds / (percent / 100 * tokens);
            return utilStatic.convertValueToDisplay("USD", avgPrice, $filter('number'), 'short', false);
        },
        getICOCoinsOffered: function() {
            var coinsOffered = "N/A";
            var percent = parseInt(ICOInfo.TokenPercentageForInvestors);
            var tokens = parseInt(ICOInfo.ICOTokenSupply);
            if (isNaN(percent) || percent == 0) {
                return coinsOffered;
            }
            if (isNaN(tokens) || tokens == 0) {
                return coinsOffered;
            }
            coinsOffered = percent / 100 * tokens;
            return utilStatic.convertValueToDisplay('', coinsOffered, $filter('number'), 'short', false) + ' (' + percent + '%)';
        },
        convertStringToNumber: function(data) {
            if (data != '') {
                if (data == "0") {
                    return "Not Applicable";
                }
                return $filter('number')(data, 1);
            }
            return '-';
        },
        setCoinPageInfo: function(apiResponse) {
            seoInfo = apiResponse.Data.SEO;
            for (var attr in apiResponse.Data.SEO) {
                initialSeoInfo[attr] = apiResponse.Data.SEO[attr];
            }
            generalInfo = apiResponse.Data.General;
            ICOInfo = apiResponse.Data.ICO;
            pageSubs = apiResponse.Data.Subs;
            streamerDataRaw = apiResponse.Data.StreamerDataRaw;
            this.addDisplayAboutItem({
                'label': 'Max Supply',
                'text': this.convertStringToNumber(generalInfo.TotalCoinSupply),
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Algorithm',
                'text': generalInfo.Algorithm || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Proof Type',
                'text': generalInfo.ProofType || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Start Date',
                'text': generalInfo.StartDate || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Twitter',
                'text': '<a href="https://twitter.com/' + generalInfo.Twitter.replace('@', '') + '" target="_blank">' + generalInfo.Twitter + '</a>' || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Website',
                'text': generalInfo.Website || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'DifficultyAdj.',
                'text': generalInfo.DifficultyAdjustment || "-",
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'BlockRR.',
                'text': generalInfo.BlockRewardReduction || "-",
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'BlockNo.',
                'text': this.convertStringToNumber(generalInfo.BlockNumber),
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Network H/s',
                'text': this.convertStringToNumber(generalInfo.NetHashesPerSecond),
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Current Supply',
                'text': this.convertStringToNumber(generalInfo.TotalCoinsMined),
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Block Reward',
                'text': this.convertStringToNumber(generalInfo.BlockReward),
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            if (ICOInfo.Status != "N/A") {
                this.addICOTableItem({
                    'label': 'Status',
                    'text': ICOInfo.Status,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Token Platform',
                    'text': ICOInfo.TokenType,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Public Portfolio',
                    'text': ICOInfo.PublicPortfolioUrl,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Token Reserve Split',
                    'text': ICOInfo.TokenReserveSplit,
                    'visible': true,
                    'hasExtraInfo': true,
                    'extraInfo': 'T - team, partners, contributors, and avisers, B - bounties, C - held by company or foundation, O - other'
                });
                this.addICOTableItem({
                    'label': 'Token percentage for investors',
                    'text': ICOInfo.TokenPercentageForInvestors + "%",
                    'visible': true,
                    'hasExtraInfo': true,
                    'extraInfo': 'This is the percentage of token sale supply not of max supply.'
                });
                if (ICOInfo.ICOTokenSupply == "N/A") {
                    this.addICOTableItem({
                        'label': 'Total token supply',
                        'text': 'N/A',
                        'visible': true,
                        'hasExtraInfo': true,
                        'extraInfo': 'Total max supply is ' + this.convertStringToNumber(generalInfo.TotalCoinSupply)
                    });
                } else {
                    this.addICOTableItem({
                        'label': 'Total tokens supply',
                        'text': utilStatic.convertValueToDisplay("", ICOInfo.ICOTokenSupply, $filter('number'), 'short', false),
                        'visible': true,
                        'hasExtraInfo': true,
                        'extraInfo': 'Total max supply is ' + this.convertStringToNumber(generalInfo.TotalCoinSupply)
                    });
                }
                if (ICOInfo.Date > 0) {
                    this.addICOTableItem({
                        'label': 'Start Date',
                        'text': $filter('date')(ICOInfo.Date * 1000, "yyyy, dd MMM H:mm:ss"),
                        'visible': true,
                        'hasExtraInfo': false,
                        'extraInfo': ''
                    });
                } else {
                    this.addICOTableItem({
                        'label': 'Start Date',
                        'text': 'Not Available',
                        'visible': true,
                        'hasExtraInfo': false,
                        'extraInfo': ''
                    });
                }
                if (ICOInfo.EndDate > 0) {
                    this.addICOTableItem({
                        'label': 'End Date',
                        'text': $filter('date')(ICOInfo.EndDate * 1000, "yyyy, dd MMM H:mm:ss"),
                        'visible': true,
                        'hasExtraInfo': false,
                        'extraInfo': ''
                    });
                } else {
                    this.addICOTableItem({
                        'label': 'End Date',
                        'text': 'Not Available',
                        'visible': true,
                        'hasExtraInfo': false,
                        'extraInfo': ''
                    });
                }
                this.addICOTableItem({
                    'label': 'Token supply post sale',
                    'text': ICOInfo.TokenSupplyPostICO,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                if (ICOInfo.StartPrice == "N/A") {
                    this.addICOTableItem({
                        'label': 'Start price',
                        'text': 'N/A',
                        'visible': true,
                        'hasExtraInfo': false,
                        'extraInfo': ''
                    });
                } else {
                    this.addICOTableItem({
                        'label': 'Start price',
                        'text': utilStatic.convertValueToDisplay(ICOInfo.StartPriceCurrency, ICOInfo.StartPrice, $filter('number'), 'short', false),
                        'visible': true,
                        'hasExtraInfo': true,
                        'extraInfo': 'Full Price: ' + ICOInfo.StartPrice
                    });
                }
                this.addICOTableItem({
                    'label': 'Funding target',
                    'text': ICOInfo.FundingTarget,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Funding cap',
                    'text': ICOInfo.FundingCap,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Average price',
                    'text': this.getAveragePriceUSD(),
                    'visible': true,
                    'hasExtraInfo': true,
                    'extraInfo': 'This is calculated as:funds raised USD / (total tokens sold * pct sold to investors)'
                });
                this.addICOTableItem({
                    'label': 'Funds raised list',
                    'text': ICOInfo.FundsRaisedList,
                    'visible': true,
                    'hasExtraInfo': true,
                    'extraInfo': 'Funds raised in total over different payment methods'
                });
                if (ICOInfo.FundsRaisedUSD == "N/A") {
                    this.addICOTableItem({
                        'label': 'Funds raised USD',
                        'text': 'N/A',
                        'visible': true,
                        'hasExtraInfo': false,
                        'extraInfo': ''
                    });
                } else {
                    this.addICOTableItem({
                        'label': 'Funds raised USD',
                        'text': utilStatic.convertValueToDisplay("USD", ICOInfo.FundsRaisedUSD, $filter('number'), 'short', false),
                        'visible': true,
                        'hasExtraInfo': false,
                        'extraInfo': ''
                    });
                }
                this.addICOTableItem({
                    'label': 'Payment method',
                    'text': ICOInfo.PaymentMethod,
                    'visible': true,
                    'hasExtraInfo': true,
                    'extraInfo': 'Ways of contributing to the token sale'
                });
                this.addICOTableItem({
                    'label': 'Features',
                    'text': ICOInfo.Features,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Security Audit',
                    'text': ICOInfo.SecurityAuditCompany,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Legal Form',
                    'text': ICOInfo.LegalForm,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Jurisdiction',
                    'text': ICOInfo.Jurisdiction,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Legal Advisers',
                    'text': ICOInfo.LegalAdvisers,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Sale Website',
                    'text': ICOInfo.Website,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'Blog',
                    'text': ICOInfo.Blog,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
                this.addICOTableItem({
                    'label': 'White paper',
                    'text': ICOInfo.WhitePaper,
                    'visible': true,
                    'hasExtraInfo': false,
                    'extraInfo': ''
                });
            }
        },
        setCurrentPageSection: function(pageSection) {
            generalInfo.CurrentPageSection = pageSection;
        },
        setExchangePageInfo: function(apiResponse) {
            seoInfo = apiResponse.Data.SEO;
            for (var attr in apiResponse.Data.SEO) {
                initialSeoInfo[attr] = apiResponse.Data.SEO[attr];
            }
            generalInfo = apiResponse.Data.General;
            pageSubs = apiResponse.Data.Subs;
            streamerDataRaw = apiResponse.Data.StreamerDataRaw;
            this.addDisplayAboutItem({
                'label': 'Country',
                'text': generalInfo.Country || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Twitter',
                'text': '<a href="https://twitter.com/' + generalInfo.Twitter.replace('@', '') + '" target="_blank">' + generalInfo.Twitter + '</a>' || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
            this.addDisplayAboutItem({
                'label': 'Website',
                'text': generalInfo.Website || '-',
                'visible': true,
                'hasExtraInfo': false,
                'extraInfo': ''
            });
        },
        setAllExchangesInfo: function(apiResponse) {
            exchangesInfo = apiResponse.Data;
        },
        setPaymentMethods: function(methodsList) {
            generalInfo.PaymentMethods = [];
            if (methodsList != "") {
                generalInfo.PaymentMethods = methodsList.split(",");
            }
        },
        setDepositMethods: function(methodsList) {
            generalInfo.DepositMethods = [];
            if (methodsList != "") {
                generalInfo.DepositMethods = methodsList.split(",");
            }
        },
        setWithdrawalMethods: function(methodsList) {
            generalInfo.WithdrawalMethods = [];
            if (methodsList != "") {
                generalInfo.WithdrawalMethods = methodsList.split(",");
            }
        },
        setHistoricalPriceData: function(apiHistoricalData) {
            generalInfo.HistoricalPriceData = apiHistoricalData.Data;
        },
        setSideBarSlot: function(obj) {
            sideBarSlot = obj;
        },
        setPageId: function(id) {
            generalInfo.Id = id;
        },
        setBaseUrl: function(bUrl) {
            generalInfo.BaseAngularUrl = bUrl;
        },
        setDocumentType: function(dType) {
            generalInfo.DocumentType = dType;
        },
        setH1Text: function(value) {
            generalInfo.H1Text = value;
        },
        setSymbol: function(value) {
            generalInfo.Symbol = value;
        },
        setToSymbol: function(value) {
            generalInfo.ToSymbol = value;
        },
        setInfoName: function(value) {
            generalInfo.Name = value;
        },
        setInfoDescription: function(value) {
            generalInfo.Description = value;
        },
        setFeaturesInfo: function(value) {
            generalInfo.Features = value;
        },
        setTechnologyInfo: function(value) {
            generalInfo.Technology = value;
        },
        setLogo: function(value) {
            generalInfo.ImageUrl = value;
        },
        addICOTableItem: function(item) {
            ICOTableItems.push(item);
        },
        addDisplayAboutItem: function(item) {
            displayAboutItems.push(item);
        },
        setDisplayAboutItems: function(arrayOfObjects) {
            displayAboutItems = arrayOfObjects;
        },
        setForumId: function(value) {
            generalInfo.Id = value;
        },
        setReviewsId: function(value) {
            generalInfo.Id = value;
        },
        setSecondLevelNav: function(arrayOfObjects) {
            secondLevelNav = arrayOfObjects;
        },
        setCurrentPostId: function(postId) {
            currentPostId = postId;
        },
        setCurrentReviewId: function(reviewId) {
            currentReviewId = reviewId;
        },
        setBaseSEOTitle: function(baseSEOTitle) {
            seoInfo.BaseSEOTitle = baseSEOTitle;
        },
        setSEOTitle: function(seoTitle) {
            seoInfo.PageTitle = seoTitle;
        },
        setInitialSEOTitle: function() {
            seoInfo.BaseSEOTitle = initialSeoInfo.PageTitle.replace(generalInfo.H1Text + ' - ', '');
        },
        addToSymbolToSEOTitle: function() {
            seoInfo.PageTitle = generalInfo.H1Text + ' - ' + generalInfo.ToSymbol + ' - ' + seoInfo.BaseSEOTitle;
        },
        setBaseSEODescription: function(baseSEODescription) {
            seoInfo.BaseSEOPageDescription = baseSEODescription;
        },
        setSEODescription: function(seoDescription) {
            seoInfo.PageDescription = seoDescription;
        },
        setInitialSEODescription: function() {
            seoInfo.BaseSEOPageDescription = "{{currencyPair}} - " + initialSeoInfo.PageDescription;
        },
        addToSymbolToSEODescription: function() {
            seoInfo.PageDescription = seoInfo.BaseSEOPageDescription.replace(/{{currencyPair}}/g, generalInfo.H1Text + ' - ' + generalInfo.ToSymbol);
        },
        setOgImageWidth: function(ogImageWidth) {
            seoInfo.OgImageWidth = ogImageWidth;
        },
        setInitialOgImageWidth: function() {
            seoInfo.OgImageWidth = initialSeoInfo.OgImageWidth;
        },
        setOgImageHeight: function(ogImageHeight) {
            seoInfo.OgImageHeight = ogImageHeight;
        },
        setInitialOgImageHeight: function() {
            seoInfo.OgImageHeight = initialSeoInfo.OgImageHeight;
        },
        setOgImage: function(ogImageUrl) {
            seoInfo.OgImageUrl = ogImageUrl;
        },
        setInitialOgImage: function() {
            seoInfo.OgImage = initialSeoInfo.OgImage;
        },
        hasSponsor: function() {
            return generalInfo.hasOwnProperty("Sponsor");
        },
        getSponsorTextTop: function() {
            if (this.hasSponsor()) {
                if (generalInfo.Sponsor.hasOwnProperty("TextTop") && generalInfo.Sponsor.TextTop != "") {
                    return generalInfo.Sponsor.TextTop;
                }
            }
            return "";
        },
        getSponsorLink: function() {
            if (this.hasSponsor()) {
                return generalInfo.Sponsor.Link;
            }
            return "https://wwww.cryptocompare.com";
        },
        getSponsorImageUrl: function() {
            if (this.hasSponsor()) {
                return generalInfo.Sponsor.ImageUrl;
            }
            return "https://wwww.cryptocompare.com/media/351339/crypto-compare-70-18.png";
        },
        getBaseUrl: function() {
            return generalInfo.BaseAngularUrl;
        },
        getDocumentType: function() {
            return generalInfo.DocumentType;
        },
        getH1Text: function() {
            return generalInfo.H1Text;
        },
        getH1TextTrimChars: function(stringToTrim) {
            var index = generalInfo.H1Text.indexOf(stringToTrim);
            if (index != -1)
                return generalInfo.H1Text.substr(0, index)
            return generalInfo.H1Text;
        },
        getSymbol: function() {
            return generalInfo.Symbol;
        },
        getInfoName: function() {
            return generalInfo.Name;
        },
        getInfoDescription: function() {
            return generalInfo.Description;
        },
        getICODescription: function() {
            return ICOInfo.Description;
        },
        getICOStatus: function() {
            return ICOInfo.Status;
        },
        getICOTokenType: function() {
            return ICOInfo.TokenType;
        },
        getICOStartDate: function() {
            return ICOInfo.Date * 1000;
        },
        getICOEndDate: function() {
            return ICOInfo.EndDate * 1000;
        },
        getFeaturesInfo: function() {
            return generalInfo.Features;
        },
        getTechnologyInfo: function() {
            return generalInfo.Technology;
        },
        getLogo: function() {
            return generalInfo.ImageUrl;
        },
        getDisplayAboutItems: function() {
            return displayAboutItems;
        },
        getICOTableItems: function() {
            return ICOTableItems;
        },
        getPageId: function() {
            return generalInfo.Id;
        },
        getForumId: function() {
            return generalInfo.Id;
        },
        getReviewsId: function() {
            return generalInfo.Id;
        },
        getSecondLevelNav: function() {
            return secondLevelNav;
        },
        getCoinsMined: function() {
            return generalInfo.TotalCoinsMined;
        },
        getTwitterHandle: function() {
            return generalInfo.Twitter;
        },
        getTwitterHandleNoAtSign: function() {
            return generalInfo.Twitter.replace('@', '');
        },
        getCurrentPostId: function() {
            return currentPostId;
        },
        getCurrentReviewId: function() {
            return currentReviewId;
        },
        getGeneralInfoItem: function(itemName) {
            if (generalInfo.hasOwnProperty(itemName)) {
                return generalInfo[itemName];
            }
            return "";
        },
        getDangerTop: function() {
            return generalInfo.DangerTop;
        },
        getWarningTop: function() {
            return generalInfo.WarningTop;
        },
        getToSymbol: function() {
            return generalInfo.ToSymbol;
        },
        getInfoTop: function() {
            return generalInfo.InfoTop;
        },
        getSEOTitle: function() {
            return seoInfo.PageTitle;
        },
        getSEODescription: function() {
            return seoInfo.PageDescription;
        },
        getOgImageWidth: function() {
            return seoInfo.OgImageWidth;
        },
        getOgImageHeight: function() {
            return seoInfo.OgImageHeight;
        },
        getOgImage: function() {
            return seoInfo.OgImageUrl;
        },
        getPageSubs: function() {
            return pageSubs;
        },
        getStreamerDataRaw: function() {
            return streamerDataRaw;
        },
        getPaymentMethods: function() {
            return generalInfo.PaymentMethods || [];
        },
        getDepositMethods: function() {
            return generalInfo.DepositMethods || [];
        },
        getWithdrawalMethods: function() {
            return generalInfo.WithdrawalMethods || [];
        },
        getWebsite: function() {
            return generalInfo.AffiliateUrl || "";
        },
        getAllExchangesInfo: function() {
            return exchangesInfo;
        },
        hasHistoricalPriceData: function() {
            return generalInfo.hasOwnProperty("HistoricalPriceData");
        },
        getSideBarSlot: function() {
            return sideBarSlot;
        },
        getBasesCanURL: function() {
            if (generalInfo.hasOwnProperty('ToSymbol') && generalInfo.hasOwnProperty('CurrentPageSection')) {
                if (generalInfo.CurrentPageSection == "post") {
                    return seoInfo.BaseUrl + generalInfo.BaseAngularUrl + generalInfo.CurrentPageSection + '/p_' + currentPostId + '/';
                } else if (generalInfo.CurrentPageSection == "influence" || generalInfo.CurrentPageSection == "forum") {
                    return seoInfo.BaseUrl + generalInfo.BaseAngularUrl + generalInfo.CurrentPageSection + '/';
                } else {
                    return seoInfo.BaseUrl + generalInfo.BaseAngularUrl + generalInfo.CurrentPageSection + '/' + generalInfo.ToSymbol;
                }
            }
            return '';
        },
        getAMPURL: function() {
            if (generalInfo.CurrentPageSection == "post") {
                return seoInfo.BaseUrl + generalInfo.BaseAngularUrl + generalInfo.CurrentPageSection + '/p_' + currentPostId + '/';
            } else if (generalInfo.CurrentPageSection == "forum") {
                return seoInfo.BaseUrl + generalInfo.BaseAngularUrl + generalInfo.CurrentPageSection + '/';
            }
            if (generalInfo.hasOwnProperty('ToSymbol')) {
                return seoInfo.BaseUrl + generalInfo.BaseAngularUrl + 'overview/' + generalInfo.ToSymbol;
            }
            return seoInfo.BaseUrl + generalInfo.BaseAngularUrl + 'overview/USD';
        }
    };
}]);
angular.module('ccc-app').factory('pageAlerts', [function pageAlertsFactory() {
    var topAlerts = [];
    return {
        setTopAlerts: function(arrayOfObjects) {
            topAlerts = arrayOfObjects;
        },
        addDangerTopAlert: function(alertMessage) {
            topAlerts.push({
                type: 'danger',
                msg: alertMessage
            });
        },
        addWarningTopAlert: function(alertMessage) {
            topAlerts.push({
                type: 'warning',
                msg: alertMessage
            });
        },
        addSuccessTopAlert: function(alertMessage) {
            topAlerts.push({
                type: 'success',
                msg: alertMessage
            });
        },
        removeTopAlert: function(index) {
            topAlerts.splice(index, 1);
        },
        getTopAlerts: function() {
            return topAlerts;
        }
    };
}]);
angular.module('ccc-app').factory('toastNotifications', ['$timeout', '$http', function toastNotificationsFactory($timeout, $http) {
    var toastNotifications = [];
    var messageTypes = ['info', 'warning', 'error', 'success'];
    var messageTypeToTitle = {
        'info': "Update",
        'warning': "Warning...",
        'error': "Error!",
        'success': "Well done!"
    }
    var removeNotification = function(ts) {
        for (var i = 0, length = toastNotifications.length; i < length; i++) {
            if (toastNotifications[i].Timestamp == ts) {
                toastNotifications.splice(i, 1);
                return;
            }
        }
    }
    return {
        addNotification: function(type, message) {
            var timestamp = new Date().getTime();
            toastNotifications.push({
                'Timestamp': timestamp,
                'Title': messageTypeToTitle[type],
                'Type': type,
                'Message': message
            });
            $timeout(function() {
                removeNotification(timestamp)
            }, 8000);
        },
        deleteNotification: function(timestamp) {
            removeNotification(timestamp);
        },
        getNotifications: function() {
            return toastNotifications;
        }
    };
}]);
angular.module('ccc-app').factory('notificationsManager', ['$http', '$interval', function notificationsManagerFactory($http, $interval) {
    var notifications = [];
    var fakeUsernames = ['Vladadry', 'jgpgw', 'sorinilie', 'electronpozitive', 'ardeleanudaniela80', 'BitcoinPaul', 'AngularRocks', 'Sorinel', 'SorSorIlie', 'MeVlad'];
    var fakeDescription = ['Trezor wallet...', 'Coinbase wallet issue... ', 'Will bitcoin hit $200 this year?...', 'Bought nutella with bitcoin..', 'Bitfinex exchange fee...', 'Is now a good time to buy DRK...', 'What is SHA256 and how does it work?..', 'I think this is just temporary...', 'I diasgree, Jgpgw, I think...', 'Did you guys see...'];
    var notifTypes = ['Agree', 'Disagree', 'Comment', 'Favorit'];
    var toType = ['Post', 'Review', 'Comment'];
    var createNotification = function() {
        var randomNum = Math.floor(Math.random() * 15) + 1;
        var newNotif = {
            Type: notifTypes[randomNum % 4],
            Time: Math.floor(new Date() / 1000),
            From: {
                Type: 'Cryptopian',
                Username: fakeUsernames[randomNum % 10],
                AvatarUrl: 'https://randomuser.me/api/portraits/med/men/' + randomNum + '.jpg'
            },
            To: {
                Type: toType[randomNum % 3],
                ID: 2123,
                URL: '/forum/btc',
                Description: fakeDescription[randomNum % 10]
            },
            'isNew': true,
            'isRead': false
        };
        return newNotif;
    };
    return {
        addNotification: function(notificationObject) {
            notifications.unshift(notificationObject);
            if (notifications.length > 20) {
                var lastNotification = notifications.pop();
                lastNotification = null;
            }
        },
        setNotifications: function(notificationsArray) {
            notifications = notificationsArray;
        },
        getNotifications: function() {
            return notifications;
        },
        getNewNotificaticationsCount: function() {
            var count = 0;
            angular.forEach(notifications, function(notification) {
                count += notification.isRead ? 0 : 1;
            });
            return count;
        },
        markAsRead: function() {
            angular.forEach(notifications, function(notification) {
                notification.isRead = true;
            });
            $http.post('/api/notifications/read').success(function(data) {});
        }
    };
}]);
angular.module('ccc-app').factory('subscriptionManager', ['$rootScope', '$http', function subscriptionManagerFactory($rootScope, $http) {
    var utilStatic = CCC.STATIC.UTIL;
    var currentSubs = [];
    var currentToSymbol = '';
    var tradeSubs = [];
    var currentAGGSubsObj = {};
    var currentExchangesInfo = {};
    var currentSubsClasification = [];
    var currentSubsObject = {};
    var currentChartSubsObj = {};
    var currentTradeSubsObj = {};
    var currentAggKeysOrder = {};
    var orderOnEqual = {
        'BTC': 1,
        'USD': 2,
        'EUR': 3,
        'GBP': 4,
        'CNY': 5,
        'RUB': 7,
        'SGD': 8,
        'HKD': 9,
        'RON': 10
    };
    var currentAGGCharts = {};
    var currentOrderBookSubsObj = {};
    var defaultAggChart = {
        'exchange': 'N/A',
        'fromsymbol': 'N/A',
        'tosymbol': 'N/A'
    };
    var splitSub = function(sub) {
        var subParts = sub.split("~");
        var obj = {
            'TYPE': subParts[0]
        };
        switch (subParts[0]) {
            case CCC.STATIC.TYPE.TRADE:
                obj['EXCHANGE'] = subParts[1];
                obj['FROMSYMBOL'] = subParts[2];
                obj['TOSYMBOL'] = subParts[3];
                break;
            case CCC.STATIC.TYPE.CURRENTAGG:
            case CCC.STATIC.TYPE.CURRENT:
                obj['EXCHANGE'] = subParts[1];
                obj['FROMSYMBOL'] = subParts[2];
                obj['TOSYMBOL'] = subParts[3];
                break;
        }
        return obj;
    };
    var createTradeSub = function(obj) {
        return CCC.STATIC.TYPE.TRADE + '~' + obj.EXCHANGE + '~' + obj.FROMSYMBOL + '~' + obj.TOSYMBOL;
    };
    var createAggSub = function(obj) {
        return CCC.STATIC.TYPE.CURRENTAGG + '~CCCAGG~' + obj.FROMSYMBOL + '~' + obj.TOSYMBOL;
    };
    var createCurrentSub = function(obj) {
        return CCC.STATIC.TYPE.CURRENT + '~' + obj.EXCHANGE + '~' + obj.FROMSYMBOL + '~' + obj.TOSYMBOL;
    };
    var createOrderBookSub = function(obj) {
        return CCC.STATIC.TYPE.ORDERBOOK + '~' + obj.EXCHANGE + '~' + obj.FROMSYMBOL + '~' + obj.TOSYMBOL;
    };
    var createAggChart = function(obj) {
        return {
            'exchange': 'CCCAGG',
            'fromsymbol': obj.FROMSYMBOL,
            'tosymbol': obj.TOSYMBOL
        }
    };
    var createChartSub = function(obj) {
        return {
            'exchange': obj.EXCHANGE,
            'fromsymbol': obj.FROMSYMBOL,
            'tosymbol': obj.TOSYMBOL
        }
    };
    var aggSubsByToSymbol = function() {
        for (var i = 0; i < currentSubs.length; i++) {
            var addOrderBookSub = false;
            var subObj = splitSub(currentSubs[i]);
            if (!currentSubsObject.hasOwnProperty(subObj.TOSYMBOL)) {
                currentSubsObject[subObj.TOSYMBOL] = [];
            }
            if (!currentTradeSubsObj.hasOwnProperty(subObj.TOSYMBOL)) {
                currentTradeSubsObj[subObj.TOSYMBOL] = [];
            }
            if (!currentChartSubsObj.hasOwnProperty(subObj.TOSYMBOL)) {
                currentChartSubsObj[subObj.TOSYMBOL] = [];
            }
            if (!currentOrderBookSubsObj.hasOwnProperty(subObj.TOSYMBOL) && currentExchangesInfo.hasOwnProperty(subObj.EXCHANGE) && currentExchangesInfo[subObj.EXCHANGE].OrderBook == true) {
                currentOrderBookSubsObj[subObj.TOSYMBOL] = [];
                addOrderBookSub = true;
            }
            currentTradeSubsObj[subObj.TOSYMBOL].push(createTradeSub(subObj));
            currentSubsObject[subObj.TOSYMBOL].push(createCurrentSub(subObj));
            currentChartSubsObj[subObj.TOSYMBOL].push(createChartSub(subObj));
            if (addOrderBookSub) {
                currentOrderBookSubsObj[subObj.TOSYMBOL].push(createOrderBookSub(subObj));
            }
            if (!currentAGGCharts.hasOwnProperty(subObj.TOSYMBOL)) {
                currentAGGCharts[subObj.TOSYMBOL] = createAggChart(subObj);
            }
            if (!currentAGGSubsObj.hasOwnProperty(subObj.TOSYMBOL)) {
                currentAGGSubsObj[subObj.TOSYMBOL] = createAggSub(subObj);
            }
        }
        currentSubsClasification = Object.keys(currentSubsObject);
        if (currentSubsClasification.length > 1) {
            currentSubsClasification.sort(function(a, b) {
                if (currentSubsObject[a].length > currentSubsObject[b].length) {
                    return -1;
                }
                if (currentSubsObject[a].length < currentSubsObject[b].length) {
                    return 1;
                }
                if (orderOnEqual.hasOwnProperty(a)) {
                    if (orderOnEqual.hasOwnProperty(b)) {
                        if (orderOnEqual[a] < orderOnEqual[b]) {
                            return -1;
                        } else {
                            return 1;
                        }
                    } else {
                        return -1;
                    }
                } else if (orderOnEqual.hasOwnProperty(b)) {
                    return 1;
                }
                return 0;
            });
        };
    };
    return {
        hasSubs: function() {
            if (currentSubs.length > 0)
                return true;
            if (tradeSubs.length > 0)
                return true;
            return false;
        },
        setCurrentToSymbol: function(toSymbol) {
            currentToSymbol = toSymbol;
        },
        setCurrentSubs: function(subs, exchangesInfo) {
            currentSubs = subs;
            currentExchangesInfo = exchangesInfo;
            aggSubsByToSymbol();
            currentToSymbol = currentSubsClasification[0] || "";
        },
        setTradeSubs: function(subs) {
            tradeSubs = subs;
        },
        getTopCurrentSubs: function() {
            if (currentToSymbol != "" && currentSubsObject.hasOwnProperty(currentToSymbol))
                return currentSubsObject[currentToSymbol];
            return [];
        },
        getCurrentSubsObj: function() {
            return currentSubsObject;
        },
        getCurrentSubsByToSymbol: function(toSymbol) {
            return currentSubsObject[toSymbol] || [];
        },
        getCurrentSubsClassification: function() {
            return currentSubsClasification;
        },
        getCurrentDisplaySubs: function() {
            return currentSubsDisplay || [];
        },
        getComputedTradeSubsObj: function() {
            return currentTradeSubsObj;
        },
        getComputedTradeSubsBySymbol: function(toSymbol) {
            return currentTradeSubsObj[toSymbol] || [];
        },
        getComputedTradeSubs: function() {
            if (currentToSymbol != "" && currentTradeSubsObj.hasOwnProperty(currentToSymbol))
                return currentTradeSubsObj[currentToSymbol];
            return [];
        },
        getComputedOrderBookSubsObj: function() {
            return currentOrderBookSubsObj;
        },
        getComputedOrderBookSubsBySymbol: function(toSymbol) {
            return currentOrderBookSubsObj[toSymbol] || [];
        },
        getComputedOrderBookSubs: function() {
            if (currentToSymbol != "" && currentOrderBookSubsObj.hasOwnProperty(currentToSymbol))
                return currentOrderBookSubsObj[currentToSymbol];
            return [];
        },
        getInputTradeSubs: function() {
            return tradeSubs || [];
        },
        getCurrentAGGSubsObj: function(toSymbol) {
            return currentAGGSubsObj;
        },
        getCurrentAGGSubByToSymbol: function(toSymbol) {
            if (currentAGGSubsObj.hasOwnProperty(toSymbol))
                return [currentAGGSubsObj[toSymbol]]
            return [];
        },
        getCurrentAGGSub: function() {
            if (currentToSymbol != "" && currentAGGSubsObj.hasOwnProperty(currentToSymbol))
                return [currentAGGSubsObj[currentToSymbol]]
            return [];
        },
        getCurrentChartObj: function() {
            return currentChartSubsObj;
        },
        getCurrentChartDataSets: function() {
            if (currentToSymbol != "" && currentChartSubsObj.hasOwnProperty(currentToSymbol))
                return currentChartSubsObj[currentToSymbol];
            return [];
        },
        getCurrentChartDataSetsByToSymbol: function(toSymbol) {
            return currentChartSubsObj[toSymbol] || [];
        },
        getCurrentAggChartByToSymbol: function(toSymbol) {
            return currentAGGCharts[toSymbol] || defaultAggChart;
        },
        getCurrentAggChartObj: function() {
            return currentAGGCharts
        },
        getCurrentAggChart: function() {
            if (currentToSymbol != "" && currentAGGCharts.hasOwnProperty(currentToSymbol))
                return currentAGGCharts[currentToSymbol];
            return defaultAggChart;
        },
        changeCurrency: function(symbol) {
            if (symbol != currentToSymbol) {
                currentToSymbol = symbol;
                $rootScope.$emit("ChangeCurrency", symbol);
            }
        },
        changeView: function(viewName) {
            $rootScope.$emit("ChangeView", viewName);
        },
        getCurrentToSymbol: function() {
            return currentToSymbol;
        },
        getNameForExchange: function(exchangeName) {
            return utilStatic.getNameForExchange(exchangeName);
        },
        getTopPairsFromMinApi: function(fsym, limit) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['fsym'] = fsym;
            if (limit) {
                paramsForCall['params']['limit'] = limit;
            }
            return $http.get("https://min-api.cryptocompare.com/data/top/pairs", paramsForCall);
        },
        getTopExchangesFromMinApi: function(fsym, tsym, limit) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['fsym'] = fsym;
            paramsForCall['params']['tsym'] = tsym;
            if (limit) {
                paramsForCall['params']['limit'] = limit;
            }
            return $http.get("https://min-api.cryptocompare.com/data/top/exchanges", paramsForCall);
        }
    };
}]);
angular.module('ccc-app').factory('dateParsing', ['$filter', function dateParsingFactory($filter) {
    return {
        formatTimePast: function(timestamp) {
            var seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
            var interval = Math.floor(seconds / 31536000);
            if (interval > 1) {
                return interval + " years";
            } else if (interval == 1) {
                return "year";
            }
            interval = Math.floor(seconds / 2592000);
            if (interval > 1) {
                return interval + " months";
            } else if (interval == 1) {
                return "month";
            }
            interval = Math.floor(seconds / 86400);
            if (interval > 1) {
                return interval + " days";
            } else if (interval == 1) {
                return "day";
            }
            interval = Math.floor(seconds / 3600);
            if (interval > 1) {
                return interval + " hours";
            } else if (interval == 1) {
                return "hour";
            }
            interval = Math.floor(seconds / 60);
            if (interval >= 1) {
                return interval + " minutes";
            }
            return "minute";
        },
        formatFromNow: function(timestamp) {
            var seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
            var interval = Math.floor(seconds / 31536000);
            if (interval > 1) {
                return interval + " years ago";
            } else if (interval == 1) {
                return "1 year ago";
            }
            interval = Math.floor(seconds / 2592000);
            if (interval > 1) {
                return interval + " months ago";
            } else if (interval == 1) {
                return "1 month ago";
            }
            interval = Math.floor(seconds / 86400);
            if (interval > 1) {
                return interval + " days ago";
            } else if (interval == 1) {
                return "1 day ago";
            }
            interval = Math.floor(seconds / 3600);
            if (interval > 1) {
                return interval + " hours ago";
            } else if (interval == 1) {
                return "1 hour ago";
            }
            interval = Math.floor(seconds / 60);
            if (interval >= 1) {
                return interval + " min ago";
            }
            return "Just now";
        },
        formatFromNowDays: function(timestamp) {
            var seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
            var interval = Math.floor(seconds / 31536000);
            if (interval > 1) {
                return "over " + interval + " years ago";
            } else if (interval == 1) {
                return "over 1 year ago";
            }
            interval = Math.floor(seconds / 2592000);
            if (interval > 1) {
                if (interval == 12) {
                    return "1 year ago";
                }
                return interval + " months ago";
            } else if (interval == 1) {
                return "1 month ago";
            }
            interval = Math.floor(seconds / 86400);
            if (interval > 1) {
                return interval + " days ago";
            } else if (interval == 1) {
                return "yesterday";
            }
            return "today";
        },
        formatTimespan: function(seconds) {
            seconds = Math.floor(seconds);
            var d = Math.floor(seconds / 86400);
            var h = Math.floor(seconds % 86400 / 3600);
            var m = Math.floor(seconds % 3600 / 60);
            var s = Math.floor(seconds % 3600 % 60);
            return ((d > 0 ? d + "d:" : "") + (h > 0 ? (d > 0 && h < 10 ? "0" : "") + h + "h:" : "0h:") + (m > 0 ? (h > 0 && m < 10 ? "0" : "") + m + "m:" : "0m:") + (s < 10 ? "0" : "") + s + "s");
        },
        formatLongDate: function(timestamp) {
            return $filter('date')(new Date(timestamp), "EEEE, dd MMMM yyyy 'at' HH:mm");
        },
        formatShortDate: function(timestamp) {
            return $filter('date')(new Date(timestamp), "yyyy-MM-dd");
        },
        formatShortTime: function(timestamp) {
            return $filter('date')(new Date(timestamp), "HH:mm");
        },
        formatShortYear: function(timestamp) {
            return $filter('date')(new Date(timestamp), "yyyy");
        },
        formatMediumDateNoTime: function(timestamp) {
            return $filter('date')(new Date(timestamp), "dd MMMM yyyy");
        },
        formatLongDateNoTime: function(timestamp) {
            return $filter('date')(new Date(timestamp), "EEEE, dd MMMM yyyy");
        },
        formatDateMonthYear: function(timestamp) {
            return $filter('date')(new Date(timestamp), "MMMM yyyy");
        },
        formatLongDateNoTimeWS: function(timestamp) {
            var dayOfWeek = new Date(timestamp).getDay();
            var diffFromCurrentToWeekStart = new Date(timestamp).getDate() - dayOfWeek + (dayOfWeek == 0 ? -6 : 1);
            var startOfWeek = new Date(new Date(timestamp).setDate(diffFromCurrentToWeekStart));
            return $filter('date')(startOfWeek, "dd MMMM yyyy");
        },
        formatLongDateNoTimeWE: function(timestamp) {
            var dayOfWeek = new Date(timestamp).getDay();
            var diffFromCurrentToWeekStart = new Date(timestamp).getDate() - dayOfWeek + (dayOfWeek == 0 ? -6 : 1);
            var endOfWeek = new Date(new Date(timestamp).setDate(diffFromCurrentToWeekStart + 6));
            return $filter('date')(endOfWeek, "dd MMMM yyyy");
        },
        formatLongDateNoTimeMS: function(timestamp) {
            var currentDate = new Date(timestamp);
            var startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            return $filter('date')(startOfMonth, "dd MMMM yyyy");
        },
        formatLongDateNoTimeME: function(timestamp) {
            var currentDate = new Date(timestamp);
            var endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
            return $filter('date')(endOfMonth, "dd MMMM yyyy");
        },
        unixTimestamp: function(secondsToSubstract) {
            return Math.round((new Date()).getTime() / 1000) - secondsToSubstract;
        }
    }
}]);
angular.module('ccc-app').service('cModalService', ['$uibModal', 'userManager', function($uibModal, userManager) {
    this.showLoginModal = function(messageForLogin) {
        var modalInstance = $uibModal.open({
            templateUrl: '/angular/cryptopian/login',
            controller: 'LoginRegisterCtrl',
            size: 'cm',
            resolve: {
                params: function() {
                    return {
                        ActionStage: 0,
                        Message: messageForLogin
                    };
                }
            }
        });
        modalInstance.result.then(function(message) {
            userManager.setShowingLogin(false);
        }, function() {
            userManager.setShowingLogin(false);
        });
    };
    this.showPasswordResetModal = function() {
        var modalInstance = $uibModal.open({
            templateUrl: '/angular/cryptopian/login',
            controller: 'LoginRegisterCtrl',
            size: 'md',
            resolve: {
                params: function() {
                    return {
                        ActionStage: 2,
                        Message: ''
                    };
                }
            }
        });
        modalInstance.result.then(function(message) {
            userManager.setShowingLogin(false);
        }, function() {
            userManager.setShowingLogin(false);
        });
    };
    this.showChangeAvatarModal = function() {
        var modalInstance = $uibModal.open({
            templateUrl: '/angular/cryptopian/changeavatar',
            controller: 'ChangeAvatarCtrl'
        });
    };
    this.showActivationReminderModal = function() {
        var modalInstance = $uibModal.open({
            templateUrl: '/angular/cryptopian/activationreminder',
            controller: 'ActivationReminderCtrl'
        });
    }
    this.showBanModal = function(passedCryptopian) {
        var modalInstance = $uibModal.open({
            templateUrl: '/angular/cryptopian/ban',
            controller: 'BanCtrl',
            size: 'md',
            resolve: {
                passedCryptopian: function() {
                    return passedCryptopian;
                }
            }
        });
    }
}]);
angular.module('ccc-app').service('gModalService', ['$uibModal', '$log', function($uibModal, $log) {
    this.showMessageModal = function(message) {
        var modalInstance = $uibModal.open({
            templateUrl: 'gModalService/showMessage.html',
            controller: 'ShowMessageCtrl',
            resolve: {
                message: function() {
                    return message;
                }
            }
        });
    };
    this.showTipUsModal = function() {
        var message = {
            btcQr: false,
            ltcQr: false,
            dogeQr: false,
            dashQr: false,
            nmcQr: false,
            show: function(item) {
                this.btcQr = false;
                this.ltcQr = false;
                this.dogeQr = false;
                this.dashQr = false;
                this.nmcQr = false;
                this[item] = true;
            },
            hide: function(item) {
                this[item] = false;
            }
        };
        var modalInstance = $uibModal.open({
            templateUrl: 'gModalService/showTipMessage.html',
            controller: 'ShowMessageCtrl',
            resolve: {
                message: function() {
                    return message;
                }
            }
        });
    };
    this.showFeedbackModal = function(debugInfo) {
        var modalInstance = $uibModal.open({
            templateUrl: '/angular/sendfeedback',
            controller: 'ShowFeedackCtrl',
            resolve: {
                debugInfo: function() {
                    return debugInfo;
                }
            }
        });
    };
    this.showCryptopianList = function(obj) {
        var modalInstance = $uibModal.open({
            templateUrl: '/angular/forum-list/cryptopians/',
            controller: 'CryptopianListModalCtrl',
            size: 'cm',
            resolve: {
                initObj: function() {
                    return obj;
                }
            }
        });
    };
}]);
angular.module('ccc-app').factory('chartUtil', ['$rootScope', '$filter', '$http', function chartUtilFactory($rootScope, $filter, $http) {
    var chartsData = {};
    var chartPeriods = [];
    var currentStatus = {
        'fromSymbol': '',
        'toSymbol': '',
        'dataLoaded': false,
        'dataIsLoading': true,
        'period': {},
        'data': [],
        'stats': {},
        'tableDisplay': []
    };
    var makeKey = function(type, e, fsym, tsym, limit) {
        return type + '~' + e + '~' + fsym + '~' + tsym + '~' + limit;
    }
    var util = CCC.STATIC.UTIL;
    var displayCurrency = CCC.STATIC.CURRENCY;
    var colorOptions = CCC.STATIC.UTIL.chartColors;
    return {
        availableChartPeriods: function(periods) {
            chartPeriods = periods;
        },
        isPeriodSelected: function(periodId) {
            return currentStatus.period.name == chartPeriods[periodId].name;
        },
        setFromSymbol: function(symbol) {
            currentStatus.fromSymbol = symbol;
        },
        setToSymbol: function(symbol) {
            currentStatus.toSymbol = symbol;
        },
        saveCurrentPeriod: function(period) {
            currentStatus.period = period;
        },
        handleNewPeriod: function(periodId) {
            $rootScope.$emit("ChartPeriodChange", periodId);
        },
        saveCurrentData: function(dataSet) {
            currentStatus.data = dataSet;
            var tableDisplayData = [];
            var prevValue = "";
            for (var i = 0, length = dataSet.length; i < length; i++) {
                if (i % currentStatus.period.periodForTable == 0) {
                    var objectToAdd = {};
                    objectToAdd.dateDisplay = $filter('date')(new Date(dataSet[i].time), 'yyyy-MM-dd HH:mm');
                    objectToAdd.close = dataSet[i].close;
                    objectToAdd.priceDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), objectToAdd.close);
                    if (i > 0) {
                        objectToAdd.chgValue = this.convertValueForChart(objectToAdd.close - prevValue.close);
                        objectToAdd.chgValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), objectToAdd.chgValue);
                        var pctChange = (objectToAdd.chgValue / prevValue.close) * 100;
                        if (pctChange < 1) {
                            objectToAdd.pct = pctChange.toFixed(2);
                        } else {
                            objectToAdd.pct = this.convertValueToDisplay('', pctChange);
                        }
                    } else {
                        objectToAdd.chgValue = 0;
                        objectToAdd.chgValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), objectToAdd.chgValue);
                        objectToAdd.pct = 0;
                    }
                    prevValue = objectToAdd;
                    tableDisplayData.push(objectToAdd);
                }
            }
            currentStatus.tableDisplay = tableDisplayData.reverse();
        },
        setChartStats: function(stats) {
            currentStatus.stats = stats;
            currentStatus.stats.chgValue = this.convertValueForChart(stats['close'] - stats['open']);
            currentStatus.stats.pct = this.convertValueToDisplay('', (currentStatus.stats.chgValue / stats['open']) * 100);
            currentStatus.stats.chgValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.chgValue);
            currentStatus.stats.highValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.high);
            currentStatus.stats.lowValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.low);
            currentStatus.stats.openValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.open);
            currentStatus.stats.closeValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.close);
            currentStatus.stats.volumeFromValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.fromSymbol), stats.volumefrom);
            currentStatus.stats.volumeToValueDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.volumeto);
            currentStatus.stats.highDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.high);
            currentStatus.stats.lowDisplay = this.convertValueToDisplay(this.getSymbolFromCurrencyCode(currentStatus.toSymbol), stats.low);
        },
        getChartStats: function() {
            return currentStatus.stats;
        },
        setLoaded: function(isLoaded) {
            currentStatus.dataLoaded = isLoaded;
        },
        setLoading: function(isLoading) {
            currentStatus.dataIsLoading = isLoading;
        },
        getToSymbol: function() {
            return currentStatus.toSymbol;
        },
        getLoaded: function() {
            return currentStatus.dataLoaded;
        },
        getLoading: function() {
            return currentStatus.dataIsLoading;
        },
        getCurrentPeriod: function() {
            return currentStatus.period;
        },
        getAvailableChartPeriods: function() {
            return chartPeriods;
        },
        getCurrentData: function() {
            return currentStatus.data;
        },
        getTableDisplay: function() {
            return currentStatus.tableDisplay;
        },
        saveData: function(type, e, fsym, tsym, limit, chartData) {
            var key = makeKey(type, e, fsym, tsym, limit);
            chartsData[key] = chartData;
        },
        hasData: function(type, e, fsym, tsym, limit) {
            var key = makeKey(type, e, fsym, tsym, limit);
            if (chartsData.hasOwnProperty(key)) {
                return true;
            }
            return false;
        },
        getHistoFromMemory: function(type, e, fsym, tsym, limit) {
            var key = makeKey(type, e, fsym, tsym, limit);
            return chartsData[key];
        },
        getSocialHistoFromApi: function(type, id, limit, aggregate, position) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['id'] = id;
            paramsForCall['params']['limit'] = limit;
            if (aggregate) {
                paramsForCall['params']['aggregate'] = aggregate;
            }
            if (position) {
                paramsForCall['params']['position'] = position;
            }
            return $http.get("/api/data/socialstatshisto" + type + "/", paramsForCall);
        },
        getHistoFromApi: function(type, e, fsym, tsym, limit, aggregate, position) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['e'] = e;
            paramsForCall['params']['fsym'] = fsym;
            paramsForCall['params']['tsym'] = tsym;
            paramsForCall['params']['limit'] = limit;
            if (aggregate) {
                paramsForCall['params']['aggregate'] = aggregate;
            }
            if (position) {
                paramsForCall['params']['position'] = position;
            }
            return $http.get("/api/data/histo" + type + "/", paramsForCall);
        },
        getHistoFromMinApi: function(type, e, fsym, tsym, limit, aggregate, position, toTs) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['e'] = e;
            paramsForCall['params']['fsym'] = fsym;
            paramsForCall['params']['tsym'] = tsym;
            if (limit) {
                paramsForCall['params']['limit'] = limit;
            } else {
                paramsForCall['params']['allData'] = true;
            }
            if (aggregate) {
                paramsForCall['params']['aggregate'] = aggregate;
            } else {
                paramsForCall['params']['aggregate'] = 1;
            }
            if (toTs) {
                paramsForCall['params']['toTs'] = toTs;
            }
            paramsForCall['params']['extraParams'] = 'CryptoCompare';
            paramsForCall['params']['tryConversion'] = false;
            return $http.get("https://min-api.cryptocompare.com/data/histo" + type, paramsForCall);
        },
        getPortfolioHistoFromMinApi: function(type, e, fsym, tsym, limit, aggregate, position, toTs, cacheReset) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['e'] = e;
            paramsForCall['params']['fsym'] = fsym;
            paramsForCall['params']['tsym'] = tsym;
            if (limit) {
                paramsForCall['params']['limit'] = limit;
            } else {
                paramsForCall['params']['allData'] = true;
            }
            if (aggregate) {
                paramsForCall['params']['aggregate'] = aggregate;
            } else {
                paramsForCall['params']['aggregate'] = 1;
            }
            if (toTs) {
                paramsForCall['params']['toTs'] = toTs;
            }
            if (cacheReset !== undefined && cacheReset == true) {
                paramsForCall['params']['cb'] = Math.floor(Date.now());
            }
            paramsForCall['params']['extraParams'] = 'CC_Portfolio';
            paramsForCall['params']['tryConversion'] = true;
            return $http.get("https://min-api.cryptocompare.com/data/histo" + type, paramsForCall);
        },
        getSymbolFromCurrencyCode: function(currencyCode) {
            return displayCurrency.getSymbol(currencyCode);
        },
        getDaysSoFarInYear: function() {
            var currentDate = new Date();
            var startOfYear = new Date(currentDate.getFullYear(), 0, 0);
            var diffInMilliSeconds = currentDate - startOfYear;
            var oneDayInMilliSeconds = 86400000;
            var currentDay = Math.floor(diffInMilliSeconds / oneDayInMilliSeconds);
            if (currentDay == 0) {
                currentDay = 1;
            }
            return currentDay - 1;
        },
        convertValueForChart: function(value) {
            return util.reduceFloatVal(value);
        },
        convertValueToDisplay: function(symbol, value) {
            return util.convertValueToDisplay(symbol, value, $filter('number'), 'short', false);
        },
        convertValueToDisplayLong: function(symbol, value) {
            return util.convertValueToDisplay(symbol, value, $filter('number'));
        },
        convertExchangeName: function(value) {
            return util.getNameForExchange(value);
        },
        topVolumeColumn: function(graphs, text, valuefield) {
            graphs.push({
                id: "base",
                valueField: valuefield,
                type: "column",
                fillAlphas: 0.8,
                lineColor: '#006098',
                title: text + " Volume",
                balloonText: "<span style='font-size:12px;'>[[title]]:<br><span style='font-size:16px;'>[[value]]</span></span>"
            });
        },
        addGuideLine: function(guides, value, text, color) {
            guides.push({
                value: value,
                label: text,
                lineAlpha: 0.5,
                lineThickness: 1,
                color: color,
                inside: true,
                position: "right",
                lineColor: color
            });
        },
        topLineSerial: function(graphs, text, valuefield, currencyField) {
            graphs.push({
                id: "base",
                valueField: valuefield,
                type: "line",
                fillAlphas: 0.1,
                lineColor: '#006098',
                title: text,
                balloonText: "<span style='font-size:12px;'>[[title]]:<br><span style='font-size:16px;'>" + currencyField + " [[value]]</span></span>"
            });
        },
        topLineSerialWithBullet: function(graphs, text, valuefield, bulletField, currencyField) {
            graphs.push({
                id: "base",
                valueField: valuefield,
                type: "line",
                bulletField: bulletField,
                fillAlphas: 0.1,
                lineColor: '#006098',
                title: text,
                balloonText: "<span style='font-size:12px;'>[[title]]:<br><span style='font-size:16px;'>" + currencyField + " [[value]]</span></span>"
            });
        },
        topLineSerialSecondary: function(graphs, text, valuefield, currencyField) {
            graphs.push({
                id: "secondary",
                valueField: valuefield,
                type: "line",
                fillAlphas: 0,
                lineColor: '#00FF00',
                title: text,
                balloonText: "<span style='font-size:12px;'>[[title]]:<br><span style='font-size:16px;'>" + currencyField + " [[value]]</span></span>"
            });
        },
        topLineSerialVolatility: function(graphs, text, valuefield) {
            graphs.push({
                id: "volatility",
                valueField: valuefield,
                type: "line",
                fillAlphas: 0.1,
                lineColor: '#006098',
                title: text,
                balloonText: "<span style='font-size:12px;'>[[title]]:<br><span style='font-size:16px;'>[[value]]%</span></span>"
            });
        },
        topPositiveNegativeBarsSerial: function(graphs, text, valuefield, currencyField) {
            graphs.push({
                id: "base",
                valueField: valuefield,
                type: "column",
                fillAlphas: 0.8,
                useDataSetColors: false,
                lineColor: colorOptions.Green.Hex,
                negativeLineColor: colorOptions.Red.Hex,
                negativeFillColors: colorOptions.Red.Hex,
                title: text,
                balloonText: "<span style='font-size:12px;'>[[title]]:<br><span style='font-size:16px;'>" + currencyField + " [[value]]</span></span>"
            });
        },
        topStacked: function(graphs, text, valuefield, colorHex) {
            graphs.push({
                id: text + '_' + valuefield,
                valueField: text + '_' + valuefield,
                lineAlpha: 0.8,
                fillAlphas: 0.4,
                lineColor: colorHex,
                fillColor: colorHex,
                title: text,
                balloonText: "<span style='font-size:11px;'>[[title]] : [[value]] ([[percents]]%)</span>"
            });
        },
        bottomVolume: function(dataSet, panel, text) {
            dataSet.fieldMappings.push({
                fromField: "volumefrom",
                toField: "volumefrom"
            });
            panel.title = "Volume " + text;
            panel.stockGraphs.push({
                valueField: "volumefrom",
                type: "column",
                fillAlphas: 0.8
            });
        },
        bottomVolumeTo: function(dataSet, panel, text) {
            var field = dataSet
            dataSet.fieldMappings.push({
                fromField: "volumeto",
                toField: "volumeto"
            });
            panel.title = "Volume " + text;
            panel.stockGraphs.push({
                valueField: "volumeto",
                type: "column",
                fillAlphas: 0.8
            });
        },
        topCandleStick: function(dataSet, panel, text) {
            dataSet.fieldMappings.push({
                fromField: "close",
                toField: "close",
            });
            dataSet.fieldMappings.push({
                fromField: "open",
                toField: "open"
            });
            dataSet.fieldMappings.push({
                fromField: "high",
                toField: "high"
            });
            dataSet.fieldMappings.push({
                fromField: "low",
                toField: "low"
            });
            panel.stockGraphs.push({
                id: "base",
                type: "candlestick",
                balloonText: "Open:<b>[[open]]</b><br>Low:<b>[[low]]</b><br>High:<b>[[high]]</b><br>Close:<b>[[close]]</b><br>",
                closeField: "close",
                fillColors: "#3d9400",
                highField: "high",
                lineColor: "#3d9400",
                lineAlpha: 1,
                lowField: "low",
                fillAlphas: 0.8,
                negativeFillColors: "#d14836",
                negativeLineColor: "#d14836",
                openField: "open",
                valueField: "close",
                valueAxis: "a1",
                legendValueText: "[[close]] " + text,
                proCandlesticks: false
            });
            panel.stockLegend.valueTextRegular = "[[close]] " + text;
        },
        topLine: function(dataSet, panel, text, withFill) {
            dataSet.fieldMappings.push({
                fromField: "close",
                toField: "close",
            });
            var lineChart = {
                id: "base",
                valueField: "close",
                lineThickness: 1,
                balloonText: "Close:<b>[[close]]</b>",
                valueAxis: "a1",
                legendValueText: "[[close]] " + text,
                bullet: "none"
            };
            if (withFill) {
                lineChart.fillAlphas = 0.1;
            };
            panel.stockGraphs.push(lineChart);
            panel.stockLegend.valueTextRegular = "[[close]] " + text;
        },
        topOHLC: function(dataSet, panel, text) {
            dataSet.fieldMappings.push({
                fromField: "close",
                toField: "close",
            });
            dataSet.fieldMappings.push({
                fromField: "open",
                toField: "open"
            });
            dataSet.fieldMappings.push({
                fromField: "high",
                toField: "high"
            });
            dataSet.fieldMappings.push({
                fromField: "low",
                toField: "low"
            });
            panel.stockGraphs.push({
                id: "base",
                type: "ohlc",
                balloonText: "Open:<b>[[open]]</b><br>Low:<b>[[low]]</b><br>High:<b>[[high]]</b><br>Close:<b>[[close]]</b><br>",
                closeField: "close",
                fillColors: "#3d9400",
                highField: "high",
                lineColor: "#3d9400",
                lineAlpha: 1,
                lowField: "low",
                fillAlphas: 0.8,
                negativeFillColors: "#d14836",
                negativeLineColor: "#d14836",
                openField: "open",
                valueField: "close",
                legendValueText: "[[close]] " + text,
                valueAxis: "a1",
                proCandlesticks: false
            });
            panel.stockLegend.valueTextRegular = "[[close]] " + text;
        },
        addDownloadButtonToChart: function() {
            return [{
                label: "<i class='fa fa-floppy-o'></i>",
                title: "Save as... ",
                menu: [{
                    label: "PNG",
                    click: function() {
                        if (this.drawing.buffer.enabled) {
                            this.drawing.handler.done();
                            this.toPNG({}, function(data) {
                                this.download(data, "image/png", this.config.fileName + Date.now() + '.png');
                            });
                        } else {
                            this.capture({}, function() {
                                this.toPNG({}, function(data) {
                                    this.download(data, "text/xml", this.config.fileName + Date.now() + '.png');
                                });
                            });
                        }
                    }
                }, {
                    label: "JPG",
                    click: function() {
                        if (this.drawing.buffer.enabled) {
                            this.drawing.handler.done();
                            this.toJPG({}, function(data) {
                                this.download(data, "image/jpg", this.config.fileName + Date.now() + '.jpg');
                            });
                        } else {
                            this.capture({}, function() {
                                this.toJPG({}, function(data) {
                                    this.download(data, "text/xml", this.config.fileName + Date.now() + '.jpg');
                                });
                            });
                        }
                    }
                }, {
                    label: "SVG",
                    click: function() {
                        if (this.drawing.buffer.enabled) {
                            this.drawing.handler.done();
                            this.toSVG({}, function(data) {
                                this.download(data, "text/xml", this.config.fileName + Date.now() + '.svg');
                            });
                        } else {
                            this.capture({}, function() {
                                this.toSVG({}, function(data) {
                                    this.download(data, "text/xml", this.config.fileName + Date.now() + '.svg');
                                });
                            });
                        }
                    }
                }, {
                    label: "CSV",
                    click: function() {
                        this.toCSV({}, function(data) {
                            this.download(data, "text/plain", this.config.fileName + Date.now() + ".csv");
                        });
                    }
                }, {
                    label: "JSON",
                    click: function() {
                        this.toJSON({}, function(data) {
                            this.download(data, "text/plain", this.config.fileName + Date.now() + ".json");
                        });
                    }
                }, {
                    label: "XLSX",
                    click: function() {
                        this.toXLSX({}, function(data) {
                            this.download(data, "application/octet-stream", this.config.fileName + Date.now() + ".xlsx");
                        });
                    }
                }]
            }];
        },
        appendData: function(originalDataSet, newDataSet, field, prefix) {
            var indexODS = 0;
            var indexNDS = 0;
            if (originalDataSet.length == 0) {
                for (var i = 0, len = newDataSet.length; i < len; i++) {
                    var newObj = {};
                    newObj['time'] = newDataSet[i]['time'];
                    newObj['timeDate'] = new Date(newObj['time']);
                    newObj[prefix + '_' + field] = newDataSet[i][field];
                    originalDataSet.push(newObj);
                }
                return;
            }
            if (newDataSet.length == 0) {
                for (var i = 0, len = originalDataSet.length; i < len; i++) {
                    originalDataSet[i][prefix + '_' + field] = 0;
                }
                return;
            }
            while (indexODS < originalDataSet.length && originalDataSet[indexODS]['time'] < newDataSet[indexNDS]['time']) {
                originalDataSet[indexODS][prefix + '_' + field] = 0;
                indexODS++;
            }
            var newDataSetToAdd = [];
            while (originalDataSet[indexODS]['time'] > newDataSet[indexNDS]['time']) {
                var newObj = {};
                for (var propertyName in originalDataSet[indexODS]) {
                    newObj[propertyName] = 0;
                }
                newObj['time'] = newDataSet[indexNDS]['time'];
                newObj['timeDate'] = new Date(newDataSet[indexNDS]['time']);
                newObj[prefix + '_' + field] = newDataSet[indexNDS][field];
                newDataSetToAdd.push(newObj);
                indexNDS++;
            }
            if (newDataSetToAdd.length > 0) {
                indexODS = newDataSetToAdd.length;
                originalDataSet = newDataSetToAdd.concat(originalDataSet);
            }
            while (indexODS < originalDataSet.length && indexNDS < newDataSet.length && originalDataSet[indexODS]['time'] == newDataSet[indexNDS]['time']) {
                originalDataSet[indexODS][prefix + '_' + field] = newDataSet[indexNDS][field];
                indexNDS++;
                indexODS++;
            }
            while (indexODS < originalDataSet.length && originalDataSet[indexODS]['time'] > newDataSet[indexNDS]['time']) {
                originalDataSet[indexODS][prefix + '_' + field] = 0;
                indexODS++;
            }
            while (indexNDS < newDataSet.length && originalDataSet[indexODS]['time'] < newDataSet[indexNDS]['time']) {
                var newObj = {};
                for (var propertyName in originalDataSet[indexODS]) {
                    newObj[propertyName] = 0;
                }
                newObj['time'] = newDataSet[indexNDS]['time'];
                newObj['timeDate'] = new Date(newObj['time']);
                newObj[prefix + '_' + field] = newDataSet[indexNDS][field];
                originalDataSet.push(newObj);
                indexNDS++;
                indexODS++;
            }
        },
        polyfillSocialData: function(chartData, interval) {
            var arrayToReturn = [];
            var valueToAddAtEnd = {};
            var allData = chartData['Data'];
            var timestampToStop;
            var currentTimestamp = chartData.TimeFrom;
            if (!chartData.hasOwnProperty('Data')) {
                return arrayToReturn;
            }
            if (allData.length > 0) {
                timestampToStop = allData[0]['time'];
            } else {
                timestampToStop = chartData.TimeTo;
            }
            if (!chartData.FirstValueInArray) {
                var initalValue = {};
                for (var attrname in chartData['FirstValue']) {
                    initalValue[attrname] = chartData['FirstValue'][attrname];
                }
                initalValue['time'] = chartData.TimeFrom * 1000;
                initalValue['timeDate'] = new Date(initalValue['time']);
                arrayToReturn.push(initalValue);
                currentTimestamp = currentTimestamp + interval;
                while (currentTimestamp < timestampToStop) {
                    var newValue = {};
                    for (var attrname in chartData['FirstValue']) {
                        newValue[attrname] = chartData['FirstValue'][attrname];
                    }
                    newValue['time'] = currentTimestamp * 1000;
                    newValue['timeDate'] = new Date(newValue['time']);
                    arrayToReturn.push(newValue);
                    currentTimestamp = currentTimestamp + interval;
                }
            }
            if (allData.length == 0) {
                return arrayToReturn;
            }
            var newValue = {};
            currentTimestamp = allData[0]['time'];
            for (var attrname in allData[0]) {
                newValue[attrname] = allData[0][attrname];
            }
            newValue['time'] = currentTimestamp * 1000;
            newValue['timeDate'] = new Date(newValue['time']);
            arrayToReturn.push(newValue);
            currentTimestamp = currentTimestamp + interval;
            for (var i = 1; i < allData.length; i++) {
                timestampToStop = allData[i]['time'];
                while (currentTimestamp < timestampToStop) {
                    var newValue = {};
                    for (var attrname in allData[i - 1]) {
                        newValue[attrname] = allData[i - 1][attrname];
                    }
                    newValue['time'] = currentTimestamp * 1000;
                    newValue['timeDate'] = new Date(newValue['time']);
                    arrayToReturn.push(newValue);
                    currentTimestamp = currentTimestamp + interval;
                }
                var newValue = {};
                for (var attrname in allData[i]) {
                    newValue[attrname] = allData[i][attrname];
                }
                newValue['time'] = currentTimestamp * 1000;
                newValue['timeDate'] = new Date(newValue['time']);
                valueToAddAtEnd = newValue;
                arrayToReturn.push(newValue);
                currentTimestamp = currentTimestamp + interval;
            };
            timestampToStop = chartData.TimeTo;
            while (currentTimestamp <= timestampToStop) {
                var newValue = {};
                for (var attrname in valueToAddAtEnd) {
                    newValue[attrname] = valueToAddAtEnd[attrname];
                }
                newValue['time'] = currentTimestamp * 1000;
                newValue['timeDate'] = new Date(newValue['time']);
                arrayToReturn.push(newValue);
                currentTimestamp = currentTimestamp + interval;
            }
            return arrayToReturn;
        },
        generateEmptyData: function(interval, totalPoints, initalTS) {
            var emptyDataArray = [];
            for (var i = 0; i < totalPoints; i++) {
                var emptyValueToAdd = {};
                emptyValueToAdd['time'] = (initalTS + (interval * i)) * 1000;
                emptyValueToAdd['timeDate'] = new Date(emptyValueToAdd['time']);
                emptyValueToAdd['close'] = 0;
                emptyValueToAdd['high'] = 0;
                emptyValueToAdd['low'] = 0;
                emptyValueToAdd['open'] = 0;
                emptyValueToAdd['volumefrom'] = 0;
                emptyValueToAdd['volumeto'] = 0;
                emptyDataArray.push(emptyValueToAdd);
            }
            return emptyDataArray;
        },
        roundCurrentDateToInterval: function(interval) {
            var currentDate = Math.floor(new Date().getTime() / 1000);
            return currentDate - currentDate % interval;
        },
        polyfillChartData: function(chartData, interval, indexForStats, dateFormat) {
            var chartStats = {
                close: 0,
                high: 0,
                low: 0,
                open: 0,
                volumefrom: 0,
                volumeto: 0
            };
            var arrayToReturn = [];
            var prevClose;
            var allData = chartData['Data'];
            var timestampToStop;
            var currentTimestamp = chartData.TimeFrom;
            if (!chartData.hasOwnProperty('Data')) {
                return {
                    data: arrayToReturn,
                    stats: chartStats
                };
            }
            if (allData.length > 0) {
                timestampToStop = allData[0]['time'];
            } else {
                timestampToStop = chartData.TimeTo;
            }
            if (!chartData.FirstValueInArray) {
                if (chartData.hasOwnProperty("FirstValue")) {
                    prevClose = util.reduceFloatVal(chartData.FirstValue['close']);
                } else {
                    if (allData.length > 0) {
                        prevClose = util.reduceFloatVal(allData[0]['close']);
                    } else {
                        prevClose = 0;
                    }
                }
                var initalValue = {};
                initalValue['time'] = chartData.TimeFrom * 1000;
                initalValue['timeDate'] = new Date(initalValue['time']);
                initalValue['close'] = prevClose;
                initalValue['high'] = prevClose;
                initalValue['low'] = prevClose;
                initalValue['open'] = prevClose;
                initalValue['volumefrom'] = 0;
                initalValue['volumeto'] = 0;
                if (dateFormat) {
                    initalValue['formatedDate'] = $filter('date')(new Date(initalValue['time']), dateFormat);
                }
                arrayToReturn.push(initalValue);
                prevClose = initalValue['close'];
                currentTimestamp = currentTimestamp + interval;
                while (currentTimestamp < timestampToStop) {
                    var newValue = {};
                    newValue['time'] = currentTimestamp * 1000;
                    newValue['timeDate'] = new Date(newValue['time']);
                    newValue['close'] = prevClose;
                    newValue['high'] = prevClose;
                    newValue['low'] = prevClose;
                    newValue['open'] = prevClose;
                    newValue['volumefrom'] = 0;
                    newValue['volumeto'] = 0;
                    if (dateFormat) {
                        newValue['formatedDate'] = $filter('date')(new Date(newValue['time']), dateFormat);
                    }
                    arrayToReturn.push(newValue);
                    currentTimestamp = currentTimestamp + interval;
                }
            }
            if (allData.length == 0) {
                chartStats['high'] = arrayToReturn[0]['high'];
                chartStats['tsHigh'] = arrayToReturn[0]['time'];
                chartStats['low'] = arrayToReturn[0]['low'];
                chartStats['tsLow'] = arrayToReturn[0]['time'];
                chartStats['close'] = arrayToReturn[0]['close'];
                chartStats['open'] = arrayToReturn[0]['open'];
                chartStats['volumefrom'] = arrayToReturn[0]['volumefrom'];
                chartStats['volumeto'] = arrayToReturn[0]['volumeto'];
                return {
                    data: arrayToReturn,
                    stats: chartStats
                };
            }
            var newValue = {};
            currentTimestamp = allData[0]['time'];
            newValue['time'] = currentTimestamp * 1000;
            newValue['timeDate'] = new Date(newValue['time']);
            newValue['close'] = util.reduceFloatVal(allData[0]['close']);
            newValue['high'] = util.reduceFloatVal(allData[0]['high']);
            newValue['low'] = util.reduceFloatVal(allData[0]['low']);
            newValue['open'] = util.reduceFloatVal(allData[0]['open']);
            newValue['volumefrom'] = util.reduceFloatVal(allData[0]['volumefrom']);
            newValue['volumeto'] = util.reduceFloatVal(allData[0]['volumeto']);
            if (arrayToReturn.length >= indexForStats) {
                chartStats['high'] = allData[0]['high'];
                chartStats['tsHigh'] = allData[0]['time'];
                chartStats['low'] = allData[0]['low'];
                chartStats['tsLow'] = allData[0]['time'];
                chartStats['open'] = allData[0]['open'];
                chartStats['volumefrom'] = allData[0]['volumefrom'];
                chartStats['volumeto'] = allData[0]['volumeto'];
            }
            if (dateFormat) {
                newValue['formatedDate'] = $filter('date')(new Date(newValue['time']), dateFormat);
            }
            arrayToReturn.push(newValue);
            prevClose = newValue['close'];
            currentTimestamp = currentTimestamp + interval;
            for (var i = 1; i < allData.length; i++) {
                timestampToStop = allData[i]['time'];
                while (currentTimestamp < timestampToStop) {
                    var newValue = {};
                    newValue['time'] = currentTimestamp * 1000;
                    newValue['timeDate'] = new Date(newValue['time']);
                    newValue['close'] = prevClose;
                    newValue['high'] = prevClose;
                    newValue['low'] = prevClose;
                    newValue['open'] = prevClose;
                    newValue['volumefrom'] = 0;
                    newValue['volumeto'] = 0;
                    if (dateFormat) {
                        newValue['formatedDate'] = $filter('date')(new Date(newValue['time']), dateFormat);
                    }
                    arrayToReturn.push(newValue);
                    currentTimestamp = currentTimestamp + interval;
                }
                var newValue = {};
                newValue['time'] = currentTimestamp * 1000;
                newValue['timeDate'] = new Date(newValue['time']);
                newValue['close'] = util.reduceFloatVal(allData[i]['close']);
                newValue['high'] = util.reduceFloatVal(allData[i]['high']);
                newValue['low'] = util.reduceFloatVal(allData[i]['low']);
                newValue['open'] = util.reduceFloatVal(allData[i]['open']);
                newValue['volumefrom'] = util.reduceFloatVal(allData[i]['volumefrom']);
                newValue['volumeto'] = util.reduceFloatVal(allData[i]['volumeto']);
                if (dateFormat) {
                    newValue['formatedDate'] = $filter('date')(new Date(newValue['time']), dateFormat);
                }
                arrayToReturn.push(newValue);
                prevClose = newValue['close'];
                if (arrayToReturn.length > indexForStats && chartStats['open'] > 0) {
                    chartStats['close'] = allData[i]['close'];
                    if (allData[i]['high'] >= chartStats['high']) {
                        chartStats['tsHigh'] = allData[i]['time'];
                        chartStats['high'] = allData[i]['high'];
                    }
                    if (allData[i]['low'] <= chartStats['low']) {
                        chartStats['tsLow'] = allData[i]['time'];
                        chartStats['low'] = allData[i]['low'];
                    }
                    chartStats['volumefrom'] += allData[i]['volumefrom'];
                    chartStats['volumeto'] += allData[i]['volumeto'];
                } else if (arrayToReturn.length == indexForStats || chartStats['open'] == 0) {
                    chartStats['close'] = allData[i]['close'];
                    chartStats['open'] = allData[i]['open'];
                    chartStats['high'] = allData[i]['high'];
                    chartStats['tsHigh'] = allData[i]['time'];
                    chartStats['low'] = allData[i]['low'];
                    chartStats['tsLow'] = allData[i]['time'];
                    chartStats['volumefrom'] = allData[i]['volumefrom'];
                    chartStats['volumeto'] = allData[i]['volumeto'];
                }
                currentTimestamp = currentTimestamp + interval;
            };
            timestampToStop = chartData.TimeTo;
            while (currentTimestamp <= timestampToStop) {
                var newValue = {};
                newValue['time'] = currentTimestamp * 1000;
                newValue['timeDate'] = new Date(newValue['time']);
                newValue['close'] = prevClose;
                newValue['high'] = prevClose;
                newValue['low'] = prevClose;
                newValue['open'] = prevClose;
                newValue['volumefrom'] = 0;
                newValue['volumeto'] = 0;
                if (dateFormat) {
                    newValue['formatedDate'] = $filter('date')(new Date(newValue['time']), dateFormat);
                }
                arrayToReturn.push(newValue);
                currentTimestamp = currentTimestamp + interval;
            }
            return {
                data: arrayToReturn,
                stats: chartStats
            };
        }
    };
}]);
angular.module('ccc-app').filter('parseUrlFilter', function() {
    var urlPattern = /(http|https):\/\/[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?/gi;
    var imagePattern = /(\.jpeg|\.jpg|\.png|\.gif)/;
    var noFollow = '';
    return function(text, target) {
        return text.replace(urlPattern, function(url) {
            if (imagePattern.test(url)) {
                return '<img src="' + url + '" class="forum-image-embed"/>';
            }
            if (url.length < 29 && url.substring(0, 29) !== 'https://www.cryptocompare.com') {
                noFollow = 'rel="nofollow" ';
            }
            return '<a target="' + target + '" href="' + url + '" ' + noFollow + 'class="link-external"><span class="fa fa-external-link"></span>' + url + '</a>';
        });
    };
});
angular.module('ccc-app').filter('cutText', function() {
    return function(value, wordwise, max, tail) {
        if (!value) return '';
        value = value.replace(/<br\/>/g, '')
        max = parseInt(max, 10);
        if (!max) return value;
        if (value.length <= max) return value;
        value = value.substr(0, max);
        if (wordwise) {
            var lastspace = value.lastIndexOf(' ');
            if (lastspace != -1) {
                value = value.substr(0, lastspace);
            }
        }
        return value + (tail || ' …');
    };
});;;;
angular.module('ccc-app').controller('HeaderSEOCtrl', ['$scope', 'pageInfo', function($scope, pageInfo) {
    $scope.pageInfo = pageInfo;
}]);
angular.module('ccc-app').controller('DropdownCtrl', ['$scope', function($scope) {
    $scope.menuCoins = false;
    $scope.menuExchanges = false;
    $scope.menuMining = false;
    $scope.menuWallets = false;
    $scope.menuForum = false;
    $scope.status = {
        isopen: false
    };
    $scope.toggled = function(open) {};
    $scope.toggleDropdown = function($event) {
        $event.preventDefault();
        $event.stopPropagation();
        $scope.status.isopen = !$scope.status.isopen;
    };
}]);
angular.module('ccc-app').controller('RatingCtrl', ['$scope', function($scope) {
    $scope.currentStars = 0;
    $scope.initStars = function(stars) {
        $scope.currentStars = stars;
    };
}]);
angular.module('ccc-app').controller('UsernameOptionsCtrl', ['$scope', '$window', 'userManager', 'gModalService', 'cModalService', 'toastNotifications', function($scope, $window, userManager, gModalService, cModalService, toastNotifications) {
    $scope.changingFollowStatus = false;
    $scope.userManager = userManager;
    $scope.followingHover = false;
    $scope.status = {
        isopen: false
    };
    $scope.alreadyFollowing = false;
    $scope.alreadyBanned = false;
    $scope.itIsMe = false;
    $scope.isLoadingFollowing = false;
    $scope.isDeleting = false;
    $scope.toggleDropdown = function($event) {
        $event.preventDefault();
        $event.stopPropagation();
        if ($scope.isLoadingFollowing) {
            return;
        }
        if (!$scope.status.isopen) {
            if (userManager.getCryptopianId() == $scope.cryptopian.Id) {
                $scope.itIsMe = true;
                $scope.status.isopen = !$scope.status.isopen;
                return;
            }
            if (userManager.isLoggedIn()) {
                $scope.isLoadingFollowing = true;
                userManager.checkFollowingStatus($scope.cryptopian.Id).success(function(data) {
                    $scope.isLoadingFollowing = false;
                    if (data.Type == 100) {
                        $scope.alreadyFollowing = true;
                    }
                    if (data.Type == 200) {
                        $scope.alreadyFollowing = false;
                    }
                    $scope.status.isopen = !$scope.status.isopen;
                });
            } else {
                $scope.status.isopen = !$scope.status.isopen;
                $scope.alreadyFollowing = false;
            }
        } else {
            $scope.status.isopen = !$scope.status.isopen;
        }
    };
    $scope.profileUrl = '/profile/' + $scope.cryptopian.Name + '/';
    $scope.goToProfile = function() {
        console.log($scope.profileUrl);
        $window.location = $scope.profileUrl;
    };
    $scope.changeFollowingStatus = function() {
        if ($scope.changingFollowStatus) {
            return;
        }
        $scope.changingFollowStatus = true;
        userManager.changeFollowingStatus($scope.cryptopian.Id, userManager.FOLLOWING.CRYPTOPIAN).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 100) {
                    toastNotifications.addNotification('success', 'Following ' + $scope.cryptopian.Name + '!');
                    $scope.alreadyFollowing = true;
                }
                if (data.Type == 200) {
                    toastNotifications.addNotification('success', 'Unfollowed ' + $scope.cryptopian.Name + '!');
                    $scope.alreadyFollowing = false;
                }
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal();
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
            }
            $scope.changingFollowStatus = false;
        });
    };
    $scope.deleteAllForumActivityCryptopian = function() {
        if ($scope.isDeleting) {
            return;
        }
        var warning = {
            'Title': 'Confirm delete all forum activity',
            'Body': 'Are you sure you want to delete all comments and posts made by this cryptopian?',
            'Type': 'warning',
            'ShowOk': true,
            'OkAction': function() {
                $scope.isDeleting = true;
                userManager.deleteAllForumActivity($scope.cryptopian.Id).success(function(data) {
                    if (data["Response"] == "Success") {
                        $scope.isDeleted = true;
                        toastNotifications.addNotification('success', 'All posts and comments have been succesfully deleted');
                    } else {
                        toastNotifications.addNotification('error', 'We could not delete all posts and comments because: ' + data["Message"]);
                    }
                    $scope.isDeleting = false;
                }).error(function() {
                    $scope.isDeleting = false;
                    toastNotifications.addNotification('error', 'We could not delete all posts and comments because there was an internal error!');
                });
            }
        };
        gModalService.showMessageModal(warning);
    };
    $scope.banOrUnbanCryptopian = function() {
        if (!$scope.alreadyBanned) {
            cModalService.showBanModal({
                Id: $scope.cryptopian.Id,
                Name: $scope.cryptopian.Name,
                setBanned: function() {
                    $scope.alreadyBanned = true;
                }
            });
        }
        if ($scope.alreadyBanned) {
            userManager.unBanCryptopian($scope.cryptopian.Id).success(function(data) {
                if (data["Response"] == "Success") {
                    if (data.Type == 100) {
                        toastNotifications.addNotification('success', 'Cryptopian ' + $scope.cryptopian.Name + ' successfully un-banned!');
                        $scope.alreadyBanned = false;
                    }
                } else {
                    if (data.Type == 1) {
                        cModalService.showLoginModal();
                    }
                    if (data.Type == 5) {
                        cModalService.showActivationReminderModal();
                    };
                    if (data.Type == 10) {
                        toastNotifications.addNotification('success', 'Cryptopian ' + $scope.cryptopian.Name + ' is already un-banned. Somebody beat you to it!');
                        $scope.alreadyBanned = false;
                    };
                }
            });
        }
    }
}]);
angular.module('ccc-app').controller('FollowableItemOptionsCtrl', ['$scope', '$window', 'userManager', 'cModalService', 'toastNotifications', function($scope, $window, userManager, cModalService, toastNotifications) {
    $scope.changingFollowStatus = false;
    $scope.followingHover = false;
    $scope.status = {
        isopen: false
    };
    $scope.alreadyFollowing = false;
    $scope.itIsMe = false;
    $scope.isLoadingFollowing = false;
    $scope.toggleDropdown = function($event) {
        $event.preventDefault();
        $event.stopPropagation();
        if ($scope.isLoadingFollowing) {
            return;
        }
        if (!$scope.status.isopen) {
            if (userManager.getCryptopianId() == $scope.item.Id) {
                $scope.itIsMe = true;
                $scope.status.isopen = !$scope.status.isopen;
                return;
            }
            if (userManager.isLoggedIn()) {
                $scope.isLoadingFollowing = true;
                userManager.checkFollowingStatus($scope.item.Id).success(function(data) {
                    $scope.isLoadingFollowing = false;
                    if (data.Type == 100) {
                        $scope.alreadyFollowing = true;
                    }
                    if (data.Type == 200) {
                        $scope.alreadyFollowing = false;
                    }
                    $scope.status.isopen = !$scope.status.isopen;
                });
            } else {
                $scope.status.isopen = !$scope.status.isopen;
                $scope.alreadyFollowing = false;
            }
        } else {
            $scope.status.isopen = !$scope.status.isopen;
        }
    };
    $scope.profileUrl = $scope.item.Url;
    $scope.goToProfile = function() {
        $window.location = $scope.profileUrl;
    };
    $scope.changeFollowingStatus = function() {
        if ($scope.changingFollowStatus) {
            return;
        }
        $scope.changingFollowStatus = true;
        var followingType = userManager.FOLLOWING.CRYPTOPIAN;
        if ($scope.item.Type == "Webpagecoinp") {
            followingType = userManager.FOLLOWING.COIN;
        }
        if ($scope.item.Type == "Webpageexchangep") {
            followingType = userManager.FOLLOWING.EXCHANGE;
        }
        userManager.changeFollowingStatus($scope.item.Id, followingType).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 100) {
                    toastNotifications.addNotification('success', 'Following ' + $scope.item.Name + '!');
                    $scope.alreadyFollowing = true;
                }
                if (data.Type == 200) {
                    toastNotifications.addNotification('success', 'Unfollowed ' + $scope.item.Name + '!');
                    $scope.alreadyFollowing = false;
                }
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal();
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
            }
            $scope.changingFollowStatus = false;
        });
    };
}]);
angular.module('ccc-app').controller('FollowPageItemOptionsCtrl', ['$scope', '$window', 'userManager', 'cModalService', 'toastNotifications', function($scope, $window, userManager, cModalService, toastNotifications) {
    $scope.changingFollowStatus = false;
    $scope.followingHover = false;
    $scope.status = {
        isopen: false
    };
    $scope.alreadyFollowing = false;
    $scope.itIsMe = false;
    $scope.isLoadingFollowing = false;
    $scope.toggleDropdown = function($event) {
        $event.preventDefault();
        $event.stopPropagation();
        if ($scope.isLoadingFollowing) {
            return;
        }
        if (!$scope.status.isopen) {
            if (userManager.getCryptopianId() == $scope.item.Data.Id) {
                $scope.itIsMe = true;
                $scope.status.isopen = !$scope.status.isopen;
                return;
            }
            if (userManager.isLoggedIn()) {
                $scope.isLoadingFollowing = true;
                userManager.checkFollowingStatus($scope.item.Data.Id).success(function(data) {
                    $scope.isLoadingFollowing = false;
                    if (data.Type == 100) {
                        $scope.alreadyFollowing = true;
                    }
                    if (data.Type == 200) {
                        $scope.alreadyFollowing = false;
                    }
                    $scope.status.isopen = !$scope.status.isopen;
                });
            } else {
                $scope.status.isopen = !$scope.status.isopen;
                $scope.alreadyFollowing = false;
            }
        } else {
            $scope.status.isopen = !$scope.status.isopen;
        }
    };
    $scope.profileUrl = $scope.item.Data.Url;
    $scope.goToProfile = function() {
        $window.location = $scope.profileUrl;
    };
    $scope.changeFollowingStatus = function() {
        if ($scope.changingFollowStatus) {
            return;
        }
        $scope.changingFollowStatus = true;
        var followingType = userManager.FOLLOWING.CRYPTOPIAN;
        if ($scope.item.Data.DocumentType == "Webpagecoinp") {
            followingType = userManager.FOLLOWING.COIN;
        }
        if ($scope.item.Data.DocumentType == "Webpageexchangep") {
            followingType = userManager.FOLLOWING.EXCHANGE;
        }
        userManager.changeFollowingStatus($scope.item.Data.Id, followingType).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 100) {
                    toastNotifications.addNotification('success', 'Following ' + $scope.item.Data.Name + '!');
                    $scope.alreadyFollowing = true;
                    $scope.item.isFollowing = true;
                }
                if (data.Type == 200) {
                    toastNotifications.addNotification('success', 'Unfollowed ' + $scope.item.Data.Name + '!');
                    $scope.alreadyFollowing = false;
                    $scope.item.isFollowing = false;
                }
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal();
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
            }
            $scope.changingFollowStatus = false;
        });
    };
}]);
angular.module('ccc-app').controller('CookieNotificationPopupCtrl', ['$scope', 'cccLocalStorage', function($scope, cccLocalStorage) {
    $scope.cookiePopupSeen = true;
    $scope.hideCookieNotification = function() {
        $scope.cookiePopupSeen = true;
    }
}]);
angular.module('ccc-app').controller('SocialShareCtrl', ['$scope', function($scope) {
    $scope.shareTwitter = function() {
        var url = "https://twitter.com/intent/tweet?text=";
        var hashTags = "%23CryptoCompare%20" + encodeURIComponent(document.URL);
        url += encodeURIComponent(document.title.replace(" | CryptoCompare.com", "")) + "%20" + hashTags;
        var width = 600;
        var height = 400;
        var left = (screen.width / 2) - (width / 2);
        var top = (screen.height / 2) - (height / 2);
        var jsPopupDetails = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, height=' + height + ',width=' + width + ',top=' + top + ', left=' + left;
        newwindow = window.open(url, 'name', jsPopupDetails);
        if (window.focus) {
            newwindow.focus()
        }
        return false;
    };
    $scope.shareFacebook = function() {
        var url = "https://www.facebook.com/sharer/sharer.php?u=";
        url += encodeURIComponent(document.URL);
        var width = 600;
        var height = 400;
        var left = (screen.width / 2) - (width / 2);
        var top = (screen.height / 2) - (height / 2);
        var jsPopupDetails = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, height=' + height + ',width=' + width + ',top=' + top + ', left=' + left;
        newwindow = window.open(url, 'name', jsPopupDetails);
        if (window.focus) {
            newwindow.focus()
        }
        return false;
    };
    $scope.shareGooglePlus = function() {
        var url = "https://plus.google.com/share?url=";
        url += encodeURIComponent(document.URL);
        var width = 500;
        var height = 400;
        var left = (screen.width / 2) - (width / 2);
        var top = (screen.height / 2) - (height / 2);
        var jsPopupDetails = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, height=' + height + ',width=' + width + ',top=' + top + ', left=' + left;
        newwindow = window.open(url, 'name', jsPopupDetails);
        if (window.focus) {
            newwindow.focus()
        }
        return false;
    };
}]);
angular.module('ccc-app').controller('DropdownMenuUserSectionCtrl', ['$rootScope', '$scope', 'userManager', 'notificationsManager', 'cModalService', 'gModalService', 'cccLightsService', function($rootScope, $scope, userManager, notificationsManager, cModalService, gModalService, cccLightsService) {
    $scope.status = {
        isopen: false
    };
    $scope.userManager = userManager;
    $scope.notificationsManager = notificationsManager;
    $scope.LightsStatus = "Off";
    if (cccLightsService.isOn()) {
        $scope.LightsStatus = "Off";
    } else {
        $scope.LightsStatus = "On";
    }
    $rootScope.$on('LightsChange', function(event, isOn) {
        if (isOn == '1') {
            $scope.LightsStatus = "On";
        } else {
            $scope.LightsStatus = "Off";
        }
    });
    $scope.toggled = function(open, type) {
        if (open && type == 'notifications') {
            notificationsManager.markAsRead();
        }
    };
    $scope.showLogin = function() {
        cModalService.showLoginModal();
    };
    $scope.showTipUs = function() {
        gModalService.showTipUsModal();
    };
    $scope.toggleDropdown = function($event) {
        $event.preventDefault();
        $event.stopPropagation();
        $scope.status.isopen = !$scope.status.isopen;
    };
    $scope.switchLights = function() {
        if (cccLightsService.isOn()) {
            cccLightsService.turnOff();
        } else {
            cccLightsService.turnOn();
        }
    }
}]);
angular.module('ccc-app').controller('LoginButtonCtrl', ['$scope', 'userManager', 'notificationsManager', 'cModalService', function($scope, userManager, notificationsManager, cModalService) {
    $scope.status = {
        isopen: false
    };
    $scope.userManager = userManager;
    $scope.notificationsManager = notificationsManager;
    $scope.toggled = function(open, type) {
        if (open && type == 'notifications') {
            notificationsManager.markAsRead();
        }
    };
    $scope.showLogin = function() {
        cModalService.showLoginModal();
    };
    $scope.showPasswordReset = function() {
        cModalService.showPasswordResetModal();
    };
    $scope.toggleDropdown = function($event) {
        $event.preventDefault();
        $event.stopPropagation();
        $scope.status.isopen = !$scope.status.isopen;
    };
}]);
angular.module('ccc-app').controller('AutosuggestCtrl', ['$scope', '$http', function($scope, $http) {
    $scope.asyncDataResult = "";
    $scope.getAutosuggest = function(val) {
        return $http.get('/api/autosuggest/all/', {
            params: {
                q: val,
                maxRows: 10
            }
        }).then(function(response) {
            if (response.data.Type > 99) {
                return response.data.Results;
            }
        });
    };
    $scope.onSelect = function($item, $model, $label) {
        window.location.href = $item.fullPath;
    };
}]);
angular.module('ccc-app').controller('ShowMessageCtrl', ['$scope', '$uibModalInstance', 'message', function($scope, $uibModalInstance, message) {
    $scope.message = message;
    $scope.cancel = function() {
        $uibModalInstance.dismiss('Cancel');
    };
    $scope.doOkAction = function() {
        if ($scope.message.hasOwnProperty("OkAction")) {
            $scope.message.OkAction();
        }
        $uibModalInstance.close('Ok');
    };
}]);
angular.module('ccc-app').controller('ShowFeedackCtrl', ['$rootScope', '$scope', '$http', '$uibModalInstance', '$templateCache', 'gModalService', 'cModalService', 'toastNotifications', 'userManager', 'debugInfo', function($rootScope, $scope, $http, $uibModalInstance, $templateCache, gModalService, cModalService, toastNotifications, userManager, debugInfo) {
    $scope.debugInfo = debugInfo;
    $scope.title = debugInfo.Title || "Website Feeback";
    $scope.sendingFeedback = false;
    $scope.requestType = "Support";
    $scope.debugInfo.ModalLoaded = new Date();
    $scope.cancel = function() {
        $uibModalInstance.dismiss('Cancel');
    };
    $scope.sendFeedback = function() {
        if (!$scope.feedbackText || $scope.feedbackText.trim() == "") {
            var message = {
                'Title': 'Feedback text appears to be blank...',
                'Body': 'It seems that the feedback box is empty. Please write something and try to send your feedback again.',
                'Type': 'warning'
            };
            gModalService.showMessageModal(message);
            return;
        }
        $scope.sendingFeedback = true;
        $scope.debugInfo.FeedbackText = $scope.feedbackText;
        $scope.debugInfo.RequestType = $scope.requestType;
        $http.post('/api/cryptopian/sendfeedback', $scope.debugInfo).success(function(response, status, headers, config) {
            $scope.sendingFeedback = false;
            if (response.Type > 99) {
                toastNotifications.addNotification('success', '<div>Message sent.</div>' + '<div>Our team will address you issue, request or suggestion as soon as possible</div>');
                $uibModalInstance.dismiss("Message sent");
                return;
            }
            if (response.Type == 1) {
                cModalService.showLoginModal();
            }
            if (response.Type == 2) {
                $scope.alerts = [{
                    type: 'danger',
                    msg: "There was no data to update."
                }];
            }
            if (response.Type == 99) {
                $scope.alerts = [{
                    type: 'danger',
                    msg: 'Oops! Something went wrong. Please refresh the page and try again.',
                    contact: true
                }];
            }
        }).error(function(response, status, headers, config) {
            $scope.sendingFeedback = false;
            $scope.alerts = [{
                type: 'danger',
                msg: 'Oops! Something went wrong. Please refresh the page and try again.',
                contact: true
            }];
        });
    };
}]);
angular.module('ccc-app').controller('ContactUsFooterCtrl', ['$rootScope', '$scope', '$http', 'gModalService', 'userManager', 'cccLightsService', function($rootScope, $scope, $http, gModalService, userManager, cccLightsService) {
    $scope.pageLoaded = new Date();
    $scope.LightsStatus = "Off";
    if (cccLightsService.isOn()) {
        $scope.LightsStatus = "Off";
    } else {
        $scope.LightsStatus = "On";
    }
    $scope.debugInfo = {
        "URL": document.URL,
        "PageLoaded": $scope.pageLoaded
    }
    $rootScope.$on('LightsChange', function(event, isOn) {
        if (isOn == '1') {
            $scope.LightsStatus = "On";
        } else {
            $scope.LightsStatus = "Off";
        }
    });
    $scope.switchLights = function() {
        if (cccLightsService.isOn()) {
            cccLightsService.turnOff();
        } else {
            cccLightsService.turnOn();
        }
    }
    $scope.sendFeedback = function() {
        $scope.debugInfo.Title = 'Website Feedback';
        $scope.debugInfo.Action = 'footerFeedback';
        $scope.debugInfo.ReportLinkClicked = new Date();
        $scope.debugInfo.UserName = userManager.getUsername();
        gModalService.showFeedbackModal($scope.debugInfo);
    };
    $scope.sendProblem = function(location) {
        $scope.debugInfo.Title = 'Website Issue';
        $scope.debugInfo.Action = location;
        $scope.debugInfo.ReportLinkClicked = new Date();
        $scope.debugInfo.UserName = userManager.getUsername();
        gModalService.showFeedbackModal($scope.debugInfo);
    }
    $scope.contactUs = function() {
        $scope.debugInfo.Title = 'Contact Us';
        $scope.debugInfo.Action = 'footerContactUs';
        $scope.debugInfo.ReportLinkClicked = new Date();
        $scope.debugInfo.UserName = userManager.getUsername();
        gModalService.showFeedbackModal($scope.debugInfo);
    };
    $scope.showTipUs = function() {
        gModalService.showTipUsModal();
    };
}]);
angular.module('ccc-app').controller('LoginRegisterCtrl', ['$scope', '$timeout', '$uibModalInstance', '$templateCache', '$http', 'cccLocalStorage', 'cModalService', 'userManager', 'params', 'toastNotifications', function($scope, $timeout, $uibModalInstance, $templateCache, $http, cccLocalStorage, cModalService, userManager, params, toastNotifications) {
    $scope.tabSelected = "Login";
    $scope.actionTypeToTitle = {
        0: 'Sign in',
        1: 'Sign out',
        2: 'Forgotten Password',
        3: 'Email sent'
    }
    $scope.cryptopian = {};
    $scope.loginStatus = params.ActionStage;
    $scope.loginMessage = params.Message || '';
    $scope.signingIn = false;
    $scope.signingInFacebook = false;
    $scope.signingInGoogle = false;
    $scope.sendingPassResetEmail = false;
    $scope.registering = false;
    $scope.canSubmit = true;
    $scope.alerts = [];
    userManager.setShowingLogin(true);
    $scope.ok = function() {
        $uibModalInstance.close();
    };
    $scope.cancel = function() {
        $uibModalInstance.dismiss('Cancel');
    };
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.init = function(loginStatus, b) {
        if (loginStatus != 1) {
            return;
        }
        $scope.loginStatus = loginStatus;
    };
    $scope.showPassReset = function() {
        $scope.loginStatus = 2;
    };
    $scope.backToLogin = function() {
        $scope.loginStatus = 0;
    };
    $scope.selectTabClick = function(tabName) {
        $scope.tabSelected = tabName;
        $scope.loginForm.email.$valid = true;
        $scope.loginForm.email.$invalid = false;
        $scope.loginForm.password.$valid = true;
        $scope.loginForm.password.$invalid = false;
    };
    $scope.sendPassResetEmail = function() {
        $scope.sendingPassResetEmail = true;
        $scope.canSubmit = false;
        return $http.post('/api/cryptopian/passrequest/', {
            "Username": $scope.cryptopian.email
        }).then(function(response) {
            $scope.sendingPassResetEmail = false;
            $scope.canSubmit = true;
            $scope.passReset.email.$valid = true;
            $scope.passReset.email.$invalid = false;
            $scope.passResetAlerts = [];
            if (response["data"]["Type"] === 100) {
                $scope.loginStatus = 3;
            }
        }, function(response) {
            $scope.sendingPassResetEmail = false;
            $scope.canSubmit = true;
            $scope.passReset.email.$valid = true;
            $scope.passReset.email.$invalid = false;
            $scope.passResetAlerts = [];
            if (response["data"]["Type"] < 100) {
                var currentAlert = {
                    type: 'danger',
                    msg: response["data"]["Message"]
                };
                $scope.passResetAlerts.push(currentAlert);
            }
            if (response["data"]["Type"] === 2 || response["data"]["Type"] === 1) {
                $scope.passReset.email.$valid = false;
                $scope.passReset.email.$invalid = true;
            }
        });
    };
    $scope.loginFacebookAuthorize = function(response) {
        $scope.alerts = [];
        if (response.authResponse) {
            var accessToken = response.authResponse.accessToken;
            $http.post('/api/cryptopian/loginfacebook/', {
                "AccessToken": accessToken
            }).then(function(response) {
                $scope.signingInFacebook = false;
                $scope.canSubmit = true;
                if (response["data"]["Type"] === 100 || response["data"]["Type"] === 101) {
                    $scope.loginStatus = 1;
                    $uibModalInstance.dismiss("Facebook Login");
                    userManager.setLoggedIn(true);
                    userManager.initUser(response["data"]["Data"]);
                    toastNotifications.addNotification('success', '<div>Login successfull.</div>' + '<div>Good to see you again ' + userManager.getUsername() + '!</div>');
                    return;
                }
            }, function(response) {
                $scope.signingInFacebook = false;
                $scope.canSubmit = true;
                if (response["data"]["Type"] < 100) {
                    $scope.alerts.push({
                        type: 'danger',
                        msg: response["data"]["Message"]
                    });
                }
            });
        } else {
            $scope.signingInFacebook = false;
            $scope.canSubmit = true;
            $scope.alerts.push({
                type: 'danger',
                msg: "It seems that you have cancelled the login box. Please try again or use another authetication method."
            });
            $scope.$apply();
        }
    };
    $scope.loginFacebook = function() {
        $scope.signingInFacebook = true;
        $scope.canSubmit = false;
        FB.login(function(response) {
            $scope.loginFacebookAuthorize(response);
        }, {
            scope: 'email, public_profile',
            auth_type: 'rerequest'
        });
    };
    $scope.loginGooglePlusAuthorize = function(authResult) {
        $scope.alerts = [];
        if (authResult['status']['signed_in'] && authResult['status']['method'] == 'PROMPT') {
            if (cccLocalStorage.getText("creating_g_account") != "") {
                return;
            }
            cccLocalStorage.setItem("creating_g_account", 1);
            var accessToken = authResult['access_token'];
            $http.post('/api/cryptopian/logingoogleplus/', {
                "AccessToken": accessToken
            }).then(function(response) {
                $scope.signingInGoogle = false;
                cccLocalStorage.removeItem("creating_g_account");
                $scope.canSubmit = true;
                if (response["data"]["Type"] === 100 || response["data"]["Type"] === 101) {
                    $scope.loginStatus = 1;
                    $uibModalInstance.dismiss("Google Login");
                    userManager.setLoggedIn(true);
                    userManager.initUser(response["data"]["Data"]);
                    toastNotifications.addNotification('success', '<div>Login successfull.</div>' + '<div>Good to see you again ' + userManager.getUsername() + '!</div>');
                    return;
                }
            }, function(response) {
                $scope.signingInGoogle = false;
                cccLocalStorage.removeItem("creating_g_account");
                $scope.canSubmit = true;
                if (response["data"]["Type"] < 100) {
                    $scope.alerts.push({
                        type: 'danger',
                        msg: response["data"]["Message"]
                    });
                }
            });
        } else if (authResult['error'] !== 'immediate_failed') {
            $scope.signingInGoogle = false;
            cccLocalStorage.removeItem("creating_g_account");
            $scope.canSubmit = true;
            $scope.alerts.push({
                type: 'danger',
                msg: "It seems that you have cancelled the login box. Please try again or use another authetication method."
            });
            $scope.$apply();
        }
    };
    $scope.loginGooglePlus = function() {
        $scope.signingInGoogle = true;
        $scope.canSubmit = false;
        var googlePlusParams = {
            'clientid': '972420808852-gjedh6d1hset5i78tk68iloak1rs2gdk.apps.googleusercontent.com',
            'cookiepolicy': 'single_host_origin',
            'scope': 'email'
        };
        if (gapi.auth.getToken() == null) {
            googlePlusParams['callback'] = $scope.loginGooglePlusAuthorize;
        } else {
            $uibModalInstance.dismiss("Google Login");
        }
        gapi.auth.signIn(googlePlusParams);
    };
    $scope.login = function(u, p) {
        $scope.signingIn = true;
        $scope.canSubmit = false;
        u = u || "";
        p = p || "";
        return $http.post('/api/cryptopian/login/', {
            "Username": u,
            "Password": p
        }).then(function(response) {
            $scope.signingIn = false;
            $scope.canSubmit = true;
            $scope.loginForm.email.$valid = true;
            $scope.loginForm.email.$invalid = false;
            $scope.loginForm.password.$valid = true;
            $scope.loginForm.password.$invalid = false;
            $scope.alerts = [];
            if (response["data"]["Type"] === 100) {
                $scope.loginStatus = 1;
                $uibModalInstance.close("Website Login");
                userManager.setLoggedIn(true);
                userManager.initUser(response["data"]["Data"]);
                toastNotifications.addNotification('success', '<div>Login successfull.</div>' + '<div>Good to see you again ' + userManager.getUsername() + '!</div>');
                return;
            };
        }, function(response) {
            $scope.signingIn = false;
            $scope.canSubmit = true;
            $scope.loginForm.email.$valid = true;
            $scope.loginForm.email.$invalid = false;
            $scope.loginForm.password.$valid = true;
            $scope.loginForm.password.$invalid = false;
            $scope.alerts = [];
            if (response["data"]["Type"] == 5) {
                $scope.loginStatus = 1;
                $uibModalInstance.close("Showing Activation Reminder");
                userManager.setLoggedIn(true);
                userManager.initUser(response["data"]["Data"]);
                cModalService.showActivationReminderModal();
                return;
            };
            if (response["data"]["Type"] < 100) {
                $scope.alerts.push({
                    type: 'danger',
                    msg: response["data"]["Message"]
                });
            };
            if (response["data"]["Type"] === 2 || response["data"]["Type"] === 1) {
                $scope.loginForm.email.$valid = false;
                $scope.loginForm.email.$invalid = true;
            };
            if (response["data"]["Type"] === 3 || response["data"]["Type"] === 1) {
                $scope.loginForm.password.$valid = false;
                $scope.loginForm.password.$invalid = true;
            };
        });
    };
    $scope.register = function(u, p) {
        $scope.registering = true;
        $scope.canSubmit = false;
        u = u || "";
        p = p || "";
        return $http.post('/api/cryptopian/register/', {
            "Username": u,
            "Password": p
        }).then(function(response) {
            $scope.registering = false;
            $scope.canSubmit = true;
            $scope.loginForm.email.$valid = true;
            $scope.loginForm.email.$invalid = false;
            $scope.loginForm.password.$valid = true;
            $scope.loginForm.password.$invalid = false;
            $scope.alerts = [];
            if (response["data"]["Type"] === 100) {
                $scope.loginStatus = 1;
                $uibModalInstance.close("Website Registration");
                userManager.setLoggedIn(true);
                userManager.initUser(response["data"]["Data"]);
                toastNotifications.addNotification('success', '<div>Registration successfull.</div>' + '<div>Welcome ' + userManager.getUsername() + '!</div>');
            }
        }, function(response) {
            $scope.registering = false;
            $scope.canSubmit = true;
            $scope.loginForm.email.$valid = true;
            $scope.loginForm.email.$invalid = false;
            $scope.loginForm.password.$valid = true;
            $scope.loginForm.password.$invalid = false;
            $scope.alerts = [];
            if (response["data"]["Type"] < 100) {
                $scope.alerts.push({
                    type: 'danger',
                    msg: response["data"]["Message"]
                });
            }
            if (response["data"]["Type"] === 2 || response["data"]["Type"] === 1) {
                $scope.loginForm.email.$valid = false;
                $scope.loginForm.email.$invalid = true;
            }
            if (response["data"]["Type"] === 3 || response["data"]["Type"] === 1) {
                $scope.loginForm.password.$valid = false;
                $scope.loginForm.password.$invalid = true;
            }
        });
    };
    $scope.logout = function() {
        toastNotifications.addNotification('success', '<div>Logout successfull.</div>' + '<div>Bye, bye ' + userManager.getUsername() + '. We hope to see you again soon!</div>');
        userManager.logout();
        $scope.loginStatus = 0;
    };
}]);
angular.module('ccc-app').controller('ActivationReminderCtrl', ['$scope', '$uibModalInstance', '$http', '$templateCache', 'cModalService', 'userManager', function($scope, $uibModalInstance, $http, $templateCache, cModalService, userManager) {
    $scope.alerts = [];
    $scope.email = "";
    $scope.previousEmail = "";
    $scope.activationStep = 1;
    $scope.canSubmit = true;
    $scope.changingEmail = false;
    $scope.sendingActivationReminder = false;
    $scope.email = userManager.getEmailAddress();
    $scope.previousEmail = userManager.getEmailAddress();
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.cancel = function() {
        $templateCache.remove('/angular/activationreminder');
        $uibModalInstance.dismiss('Cancel');
    };
    $scope.sendActivationReminder = function() {
        $scope.alerts = [];
        $scope.canSubmit = false;
        $scope.sendingActivationReminder = true;
        return $http.post('/api/cryptopian/activationreminder/').success(function(response, status, headers, config) {
            $scope.canSubmit = true;
            $scope.sendingActivationReminder = false;
            if (response.Type == 3) {
                $scope.activationStep = 3;
                return;
            }
            if (response.Type == 1) {
                return;
            }
            $scope.activationStep = 2;
        }).error(function(response, status, headers, config) {
            $scope.canSubmit = true;
            $scope.sendingActivationReminder = false;
            $scope.alerts = [{
                type: 'danger',
                msg: 'Oops! Something went wrong. Please refresh the page and try again.',
                contact: true
            }];
        });
    };
    $scope.changeEmail = function() {
        if (!$scope.email || $scope.email.trim() == "") {
            $scope.alerts = [{
                type: 'danger',
                msg: 'It seems that the email address you have typed in is invalid',
                contact: false
            }];
            return;
        }
        $scope.email = $scope.email.trim();
        if ($scope.email == $scope.previousEmail) {
            $scope.alerts = [{
                type: 'warning',
                msg: 'It seems that you have not typed in a different email address.',
                contact: false
            }];
            return;
        }
        $scope.alerts = [];
        $scope.canSubmit = false;
        $scope.changingEmail = true;
        $http.post('/api/cryptopian/update', {
            'Email': $scope.email
        }).success(function(response, status, headers, config) {
            $scope.canSubmit = true;
            $scope.changingEmail = false;
            if (response.Type > 99) {
                $scope.previousEmail = $scope.email;
                $scope.alerts = [{
                    type: 'success',
                    msg: 'Email address successfully changed. You can now request the verfification email to be sent to this address if you clik on the Send Verification Email button.',
                    contact: false
                }];
                $templateCache.remove('/angular/activationreminder');
            }
            if (response.Type == 4) {
                $scope.alerts = [{
                    type: 'danger',
                    msg: "Could not update your email because " + $scope.email + " is already registered under a different account.",
                    contact: false
                }];
                $scope.email = $scope.previousEmail;
            } else if (response.Type == 3) {
                $scope.alerts = [{
                    type: 'danger',
                    msg: "Could not update your email becasue " + $scope.email + " is not a valid email address.",
                    contact: false
                }];
                $scope.email = $scope.previousEmail;
            } else {
                $scope.alerts = [{
                    type: 'danger',
                    msg: 'Oops! Something went wrong. Please refresh the page and try again.',
                    contact: true
                }];
            }
        }).error(function(response, status, headers, config) {
            $scope.canSubmit = true;
            $scope.changingEmail = false;
            $scope.alerts = [{
                type: 'danger',
                msg: "Could not update your email because of an internal server error.",
                contact: false
            }];
        });
    };
}]);
angular.module('ccc-app').controller('BanCtrl', ['$scope', '$uibModalInstance', 'cModalService', '$http', 'userManager', 'toastNotifications', 'passedCryptopian', function($scope, $uibModalInstance, cModalService, $http, userManager, toastNotifications, passedCryptopian) {
    $scope.selectedBanReason = 0;
    $scope.randomBanJokeAsArray = ['Loading....'];
    $http({
        method: 'GET',
        url: 'https://icanhazdadjoke.com/',
        headers: {
            'Accept': 'application/json'
        }
    }).then(function successCallback(response) {
        $scope.randomBanJokeAsArray = response.data.joke.replace(/\r\n\r\n/, '\r\n').split('\r\n');
    }, function errorCallback(response) {
        $scope.randomBanJokeAsArray = ['Sorry, no random joke available. Check back later.'];
    });
    $scope.otherReasonText = '';
    $scope.banReasons = [{
        'Key': 'Spam',
        'DisplayName': 'Spam',
        'Description': 'Spamming the forum by posting links with no added value for the rest of the community'
    }, {
        'Key': 'InappropriateBehaviour',
        'DisplayName': 'Inappropriate Behaviour',
        'Description': 'Threatening, trying to scam or trick other users, using offensive language or generally behaving in an unpleasant manner.'
    }, {
        'Key': 'AffiliateLinks',
        'DisplayName': 'Affiliate Links',
        'Description': 'Adding a post or a review that has one or more affilate links. '
    }];
    $scope.isBanningUser = false;
    $scope.cancel = function() {
        $uibModalInstance.dismiss('Cancel');
    };
    $scope.banUser = function() {
        $scope.isBanningUser = true;
        var banReasonDescription = '';
        if ($scope.selectedBanReason == 'Other') {
            banReasonDescription = $scope.otherReasonText;
        } else {
            banReasonDescription = $scope.banReasons[$scope.selectedBanReason].Description;
        }
        userManager.banCryptopian(passedCryptopian.Id, banReasonDescription).then(function(response) {
            var data = response.data;
            $scope.isBanningUser = false;
            if (data["Response"] == "Success") {
                if (data.Type == 100) {
                    passedCryptopian.setBanned();
                    toastNotifications.addNotification('success', 'Cryptopian ' + passedCryptopian.Name + ' successfully banned!');
                    $uibModalInstance.close("Banned");
                }
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal();
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
                if (data.Type == 10) {
                    passedCryptopian.setBanned();
                    toastNotifications.addNotification('success', 'Cryptopian ' + passedCryptopian.Name + ' is already banned. Somebody beat you to it!');
                    $uibModalInstance.close("Already Banned");
                };
            }
        }, function(response) {
            $scope.isBanningUser = false;
            toastNotifications.addNotification('error', 'Cryptopian ' + passedCryptopian.Name + ' count not be banned, there was an error, try again later');
            $uibModalInstance.close("Error: Could Not Ban");
        })
    };
}]);
angular.module('ccc-app').controller('CryptopianListModalCtrl', ['$rootScope', '$scope', '$uibModalInstance', 'userManager', 'toastNotifications', 'cModalService', 'initObj', function($rootScope, $scope, $uibModalInstance, userManager, toastNotifications, cModalService, initObj) {
    $scope.allCryptopianIds = [];
    $scope.showLoadingStatus = false;
    for (var iCList = 0, lCList = initObj.Data.length; iCList < lCList; iCList++) {
        initObj.Data[iCList].changingFollowStatus = false;
        $scope.allCryptopianIds.push(initObj.Data[iCList].Data.Id);
    }
    $scope.cryptopianList = initObj;
    $scope.itIsMe = function(cryptopianId) {
        if (!userManager.isLoggedIn()) {
            return false;
        }
        return userManager.getCryptopianId() == cryptopianId;
    }
    $scope.cancel = function() {
        $scope.loginChange();
        $uibModalInstance.dismiss('Cancel');
    };
    $scope.closingModal = $scope.$on("modal.closing", function(event, newValue) {
        $scope.loginChange();
        $scope.closingModal();
    });
    $scope.loadFollowingStatus = function(newValue) {
        if (newValue == true) {
            userManager.checkFollowingStatus($scope.allCryptopianIds.join()).success(function(data) {
                if (data.Type == 100) {
                    $scope.cryptopianList.Data.map(function(item) {
                        if (data.Followed.indexOf(item.Data.Id) > -1) {
                            item.amFollowing = true;
                        } else {
                            item.amFollowing = false;
                        }
                        if (data.Following.indexOf(item.Data.Id) > -1) {
                            item.isFollowing = true;
                        } else {
                            item.isFollowing = false;
                        }
                        return item;
                    });
                } else {
                    $scope.cryptopianList.Data.map(function(item) {
                        item.isFollowing = false;
                        item.amFollowing = false;
                        return item;
                    });
                }
                $scope.showLoadingStatus = false;
            });
        } else {
            $scope.cryptopianList.Data.map(function(item) {
                item.isFollowing = false;
                item.amFollowing = false;
                return item;
            });
            $scope.showLoadingStatus = false;
        }
    };
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        $scope.showLoadingStatus = true;
        $scope.loadFollowingStatus(newValue);
    });
    $scope.changeFollowingStatus = function(cryptopian) {
        if (cryptopian.changingFollowStatus == true) {
            return;
        }
        cryptopian.changingFollowStatus = true;
        userManager.changeFollowingStatus(cryptopian.Data.Id, userManager.FOLLOWING.CRYPTOPIAN).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 100) {
                    toastNotifications.addNotification('success', 'Following ' + cryptopian.Data.Name + '!');
                    cryptopian.amFollowing = true;
                }
                if (data.Type == 200) {
                    toastNotifications.addNotification('success', 'Unfollowed ' + cryptopian.Data.Name + '!');
                    cryptopian.amFollowing = false;
                }
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal("Please login or signup and you'll be able to follow " + cryptopian.Data.Name + '.');
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
            }
            cryptopian.changingFollowStatus = false;
        });
    };
    $scope.loadMore = function() {
        if (initObj.ActionType == "0") {
            initObj.LoadMoreService.getAgreeCryptopians($scope.cryptopianList.ItemId, $scope.cryptopianList.Data[$scope.cryptopianList.Data.length - 1].Id).success(function(data) {
                $scope.cryptopianList.MoreAvailable = data.MoreAvailable;
                for (var iAgree = 0, lAgree = data.Data.length; iAgree < lAgree; iAgree++) {
                    $scope.cryptopianList.Data.push(data.Data[iAgree]);
                }
            });
        } else {
            initObj.LoadMoreService.getDisagreeCryptopians($scope.cryptopianList.ItemId, $scope.cryptopianList.Data[$scope.cryptopianList.Data.length - 1].Id).success(function(data) {
                $scope.cryptopianList.MoreAvailable = data.MoreAvailable;
                for (var iDisagree = 0, lDisagree = data.Data.length; iDisagree < lDisagree; iDisagree++) {
                    $scope.cryptopianList.Data.push(data.Data[iDisagree]);
                }
            });
        }
    };
}]);
angular.module('ccc-app').controller('PasswordResetCtrl', ['$scope', '$http', 'cModalService', 'userManager', 'toastNotifications', function($scope, $http, cModalService, userManager, toastNotifications) {
    $scope.alerts = [];
    $scope.resetStage = 1;
    $scope.sendingNewPass = false;
    $scope.cryptopian = {
        'newPassword': '',
        'hash': ''
    };
    $scope.initPasswordReset = function(hashValue) {
        $scope.cryptopian.hash = hashValue;
    }
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.passwordReset = function() {
        if (!$scope.cryptopian.newPassword || $scope.cryptopian.newPassword.trim() == "") {
            $scope.alerts = [{
                type: 'danger',
                msg: 'It seems that the new password you have typed in is invalid',
                contact: false
            }];
            return;
        }
        $scope.alerts = [];
        $scope.sendingNewPass = true;
        $http.post('/api/cryptopian/passreset/', $scope.cryptopian).success(function(response, status, headers, config) {
            $scope.sendingNewPass = false;
            if (response.Type > 99) {
                $scope.resetStage = 2;
                userManager.initUser(response["Data"]);
                toastNotifications.addNotification('success', '<div>Pass reset successfull.</div>' + '<div>Welcome back ' + userManager.getUsername() + '!</div>');
                userManager.setLoggedIn(true);
            }
        }).error(function(response, status, headers, config) {
            $scope.sendingNewPass = false;
            if (response.Type < 100) {
                $scope.alerts = [{
                    type: 'danger',
                    msg: response["Message"],
                    contact: false
                }];
            } else {
                $scope.alerts = [{
                    type: 'danger',
                    msg: 'Oops! Something went wrong. Please refresh the page and try again.',
                    contact: true
                }];
            }
        });
    };
}]);
angular.module('ccc-app').controller('ChangeAvatarCtrl', ['$scope', '$uibModalInstance', '$timeout', '$templateCache', 'cModalService', 'userManager', 'toastNotifications', function($scope, $uibModalInstance, $timeout, $templateCache, cModalService, userManager, toastNotifications) {
    $scope.alerts = [];
    $scope.canSubmit = true;
    $scope.changingAvatar = false;
    $scope.oldCryptopianAvatar = userManager.getAvatarUrl();
    $scope.newCryptopianAvatar = userManager.getAvatarUrl();
    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
    $scope.cancel = function() {
        $uibModalInstance.dismiss('Cancel');
    };
    $scope.handleFileSelect = function(currentTarget) {
        if (currentTarget.files.length != 1) {
            return;
        }
        var file = currentTarget.files[0];
        var reader = new FileReader();
        reader.onload = function(_file) {
            $scope.$apply(function($scope) {
                $scope.oldCryptopianAvatar = _file.target.result;
            });
        };
        reader.readAsDataURL(file);
    };
    $scope.selectFile = function() {
        $timeout(function() {
            angular.element('#newImageFile').trigger('click')
        }, 100);
    }
    $scope.sendNewImageToServer = function() {
        if ($scope.oldCryptopianAvatar == $scope.newCryptopianAvatar) {
            $scope.alerts = [{
                type: 'warning',
                msg: 'It seems that you have not selected a new avatar.',
                contact: false
            }];
            return;
        }
        $scope.alerts = [];
        $scope.canSubmit = false;
        $scope.changingAvatar = true;
        var objectWithUpdateFields = {};
        objectWithUpdateFields['NewAvatar'] = $scope.newCryptopianAvatar;
        userManager.updateFields(objectWithUpdateFields).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.changingAvatar = false;
                var newAvatarUrl = data["Cryptopian"].AvatarUrl;
                $scope.oldCryptopianAvatar = $scope.newCryptopianAvatar;
                userManager.setAvatarUrl($scope.newCryptopianAvatar)
                toastNotifications.addNotification('success', 'Profile image succesfully updated!');
                $scope.canSubmit = true;
                $uibModalInstance.dismiss('Avatar Changed');
            }
        }).error(function(response, status, headers, config) {
            toastNotifications.addNotification('error', 'Oops! Something went wrong. Please refresh the page and try again.');
            $scope.canSubmit = true;
            $scope.changingAvatar = false;
            $scope.alerts = [{
                type: 'danger',
                msg: 'Oops! Something went wrong. Please refresh the page and try again.',
                contact: true
            }];
        });
    };
}]);;;;
angular.module('ccc-app').directive('ngMetaUpdateContent', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            scope.$watch(attrs.ngMetaUpdateContent, function(value) {
                attrs.$set('content', value);
            });
        }
    };
});
angular.module('ccc-app').directive('includeExtrenalScriptInTemplate', ['$compile', function($compile) {
    return {
        restrict: 'E',
        link: function(scope, element, attr) {
            if (attr.externalScriptUrl) {
                var domElem = '<script src="' + attr.externalScriptUrl + '" async defer></script>';
                $(element).append($compile(domElem)(scope));
            }
        }
    };
}]);
angular.module('ccc-app').directive('ngClassForLights', ['$rootScope', 'cccLightsService', function($rootScope, cccLightsService) {
    return {
        restrict: 'A',
        link: function(scope, elem, attrs) {
            if (cccLightsService.isOn()) {
                angular.element(elem).addClass('lights-on').removeClass('lights-off');
            } else {
                angular.element(elem).addClass('lights-off').removeClass('lights-on');
            }
            $rootScope.$on("LightsChange", function() {
                if (cccLightsService.isOn()) {
                    angular.element(elem).addClass('lights-on').removeClass('lights-off');
                } else {
                    angular.element(elem).addClass('lights-off').removeClass('lights-on');
                }
            });
        }
    };
}]);
angular.module('ccc-app').directive('ngMetaBaseCanUrl', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            scope.$watch(attrs.ngMetaBaseCanUrl, function(value) {
                if (value != "") {
                    attrs.$set('rel', 'canonical');
                    attrs.$set('href', value);
                } else {
                    attrs.$set('rel', '');
                    attrs.$set('href', '');
                }
            });
        }
    };
});
angular.module('ccc-app').directive('ngMetaBaseAmpUrl', function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            scope.$watch(attrs.ngMetaBaseAmpUrl, function(value) {
                if (value != "") {
                    attrs.$set('rel', 'amphtml');
                    attrs.$set('href', value);
                } else {
                    attrs.$set('rel', '');
                    attrs.$set('href', '');
                }
            });
        }
    };
});
angular.module('ccc-app').directive('notificationAction', [function() {
    return {
        restrict: 'E',
        templateUrl: 'general/notification-user-action.html',
        controller: ['$scope', 'dateParsing', function($scope, dateParsing) {
            $scope.DateParsing = dateParsing;
            $scope.markAsRead = function() {
                $scope.notification.isRead = true;
            };
            $scope.markAsNotNew = function() {
                $scope.notification.isNew = false;
            };
            $scope.getActionText = function() {
                switch ($scope.notification.Type) {
                    case "Agree":
                        return ' agrees with ';
                        break;
                    case 'Disagree':
                        return ' disagrees with ';
                        break;
                    case 'Comment':
                        return ' commented on ';
                        break;
                    case 'Favorit':
                        return ' favorited ';
                        break;
                    default:
                        return ' something ';
                        break;
                }
            }
        }],
        scope: {
            notification: "="
        },
        link: function(scope, element, attrs) {}
    };
}]);
angular.module('ccc-app').directive('topAlerts', ['$compile', 'pageAlerts', function($compile, pageAlerts) {
    return {
        restrict: 'E',
        templateUrl: 'general/top-alerts.html',
        controller: function($scope) {},
        scope: {},
        link: function(scope, element, attrs) {
            scope.pageAlerts = pageAlerts;
        }
    };
}]);
angular.module('ccc-app').directive('usernameOptions', [function() {
    return {
        restrict: 'E',
        templateUrl: 'general/username-options.html',
        controller: 'UsernameOptionsCtrl',
        scope: {
            cryptopian: "=",
            icon: "=",
            avatar: "="
        },
        link: function(scope, element, attrs) {}
    };
}]);
angular.module('ccc-app').directive('followableItemOptions', [function() {
    return {
        restrict: 'E',
        templateUrl: 'general/followable-item-options.html',
        controller: 'FollowableItemOptionsCtrl',
        scope: {
            item: "=",
            icon: "=",
            avatar: "=",
            bubbleAlign: "@?bubbleAlign"
        },
        link: function(scope, element, attrs) {}
    };
}]);
angular.module('ccc-app').directive('followPageItemOptions', [function() {
    return {
        restrict: 'E',
        templateUrl: 'general/follow-page-item-options.html',
        controller: 'FollowPageItemOptionsCtrl',
        scope: {
            item: "=",
            icon: "=",
            avatar: "="
        },
        link: function(scope, element, attrs) {}
    };
}]);
angular.module('ccc-app').directive('showTotal', ['$compile', 'totals', function($compile, totals) {
    return {
        restrict: 'E',
        template: '<meta itemprop="interactionCount" content="UserComments:{{totals.get(totalName)}}"/>' + '<span class="total-value" ng-class="totalName" ng-title="{{totals.getFullNumber(totalName)}}">{{totals.get(totalName)}} {{totals.getText(totalName,text)}}</span>',
        controller: function($scope) {},
        scope: {},
        link: function(scope, element, attrs) {
            scope.totals = totals;
            scope.totalName = attrs["name"];
            scope.text = attrs["text"];
        }
    };
}]);
angular.module('ccc-app').directive('showTotalPageViews', ['$compile', 'totals', function($compile, totals) {
    return {
        restrict: 'E',
        template: '<span class="total-value" ng-class="totalName" title="{{totals.getFullNumber(totalName)}} {{totals.getText(totalName,text)}}">{{totals.get(totalName)}}</span>',
        controller: function($scope) {},
        scope: {},
        link: function(scope, element, attrs) {
            scope.totals = totals;
            scope.totalName = attrs["name"];
            scope.text = attrs["text"];
        }
    };
}]);
angular.module('ccc-app').directive('toastNotifications', ['$compile', 'toastNotifications', function($compile, toastNotifications) {
    return {
        restrict: 'E',
        templateUrl: 'general/toast-notifications.html',
        controller: function($scope) {},
        scope: {},
        link: function(scope, element, attrs) {
            scope.toastNotifications = toastNotifications;
        }
    };
}]);
angular.module('ccc-app').directive('cookieNotificationPopup', [function() {
    return {
        restrict: 'E',
        templateUrl: 'general/cookie-notification-popup.html',
        controller: 'CookieNotificationPopupCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
}]);
angular.module('ccc-app').directive('infiniteScroll', ['$rootScope', '$window', '$timeout', function($rootScope, $window, $timeout) {
    return {
        restrict: 'A',
        scope: {
            scrollControllerObject: '='
        },
        link: function(scope, elem, attrs) {
            $window = angular.element($window);
            handler = function() {
                var windowBottom, elementBottom, remaining, loadMore;
                windowBottom = $window.height() + $window.scrollTop();
                elementBottom = elem.offset().top + elem.height();
                remaining = elementBottom - windowBottom;
                loadMore = remaining <= $window.height();
                if (loadMore) {
                    $timeout(function() {
                        scope.scrollControllerObject.loadMoreOnScroll();
                    }, 0, true);
                }
            };
            $window.on('scroll', handler);
            var isScrolling = true;
            scope.$on('$destroy', function() {
                if (isScrolling) {
                    isScrolling = false;
                    return $window.off('scroll', handler);
                }
            });
            scope.newView = $rootScope.$on('$stateChangeSuccess', function(event) {
                if (!isScrolling) {
                    $window.on('scroll', handler);
                }
            });
            scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
                isScrolling = false;
                $window.off('scroll', handler);
                scope.changeView();
                scope.newView();
            });
        }
    };
}]);;;;
$(function() {
    var $swiper_charts = false;
    var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    var isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
    if (isSafari) {
        $('html').addClass('safari');
    } else {
        $('html').addClass('other');
    }

    function team_hover() {
        if ($(window).width() < 769) {
            $('.item-team').removeClass('with-hover');
        } else {
            $('.item-team').addClass('with-hover');
        }
    }

    function remove_ribbon() {
        if ($(window).width() < 1210) {
            $('.marker-ribbon').removeClass('ribbon-content');
        } else {
            $('.marker-ribbon').addClass('ribbon-content');
        }
    }
    remove_ribbon();
    team_hover();
    $(document).on('click', '.nav-login-modal li a', function() {
        $('.nav-login-modal li').removeClass('active');
        $(this).parent('li').addClass('active');
        if ($(this).hasClass('activate-login')) {
            $('.btn-login').removeClass('hidden');
            $('.btn-signup').addClass('hidden');
            $('.modal-footer-login').addClass('hidden');
        }
        if ($(this).hasClass('activate-signup')) {
            $('.btn-signup').removeClass('hidden');
            $('.btn-login').addClass('hidden');
            $('.modal-footer-login').removeClass('hidden');
        }
    });
    $(window).resize(function() {
        remove_ribbon();
    });
});;;;
$(function() {
    function changeOffset() {
        $windowWidth = $('.main-wrapper').width() + 8;
        if ($('.header-coin').data('bs.affix') != undefined) {
            if ($windowWidth <= 992) {
                $('.header-coin').data('bs.affix').options.offset = 125;
            } else {
                $('.header-coin').data('bs.affix').options.offset = 85;
            }
        }
    }

    function resizeFixed() {
        $topHeight = $(document).scrollTop();
        $sidebarWidth = $('.sidebar-right')[0].getBoundingClientRect().width.toFixed(2);
        $windowWidth = $('.main-wrapper').width() + 8;
        if ($windowWidth >= 992 && $windowWidth < 1200 && $topHeight >= 100) {
            $('.profile-things').css('width', $sidebarWidth + 'px');
        }
        if ($windowWidth >= 1200 && $topHeight >= 100) {
            $('.profile-things').css('width', $sidebarWidth + 'px');
        }
    }

    function resizeSmallName() {
        $topHeight = $(document).scrollTop();
        $sidebarWidth = $('.sidebar-right')[0].getBoundingClientRect().width.toFixed(2);
        if ($(window).width() >= 1200)
            $('.coin-name-small').removeClass('small-small').addClass('small-big');
        else
            $('.coin-name-small').removeClass('small-big').addClass('small-small');
    }
    var $lastScrollTop = 0;
    window.addEventListener("scroll", function() {
        var $st = window.pageYOffset || document.documentElement.scrollTop;
        $headerElement = document.getElementById('header-profile');
        $navElement = document.getElementById('toolbar-wrapper');
        $headerHeight = $headerElement.offsetHeight;
        $topHeight = document.body.scrollTop;
        $windowWidth = $('.main-wrapper').width() + 8;
        resizeFixed();
        resizeSmallName();
        if ($st >= $headerHeight - 44) {
            $navElement.className = '';
            $navElement.className = 'toolbar-wrapper affix-top container';
        } else {
            $navElement.className = '';
            $navElement.className = 'toolbar-wrapper';
        }
        if ($windowWidth >= 1200) {
            if ($topHeight >= 158) {
                $('.wrapper-ci').addClass('ci-absolute');
                $('.profile-things').addClass('ci-fixed');
            } else {
                $('.wrapper-ci').removeClass('ci-absolute');
                $('.profile-things').removeClass('ci-fixed');
                $('.profile-things').removeAttr('style');
            }
        }
        if ($windowWidth >= 992 && $windowWidth <= 1200) {
            if ($topHeight >= 160) {
                $('.wrapper-ci').addClass('ci-absolute');
                $('.profile-things').addClass('ci-fixed');
            } else {
                $('.wrapper-ci').removeClass('ci-absolute');
                $('.profile-things').removeClass('ci-fixed');
                $('.profile-things').removeAttr('style');
            }
        }
    }, false);

    function secondaryMenu() {
        $windowWidth = $(window).width();
    }
    $(window).resize(function() {
        secondaryMenu();
        changeOffset();
        resizeFixed();
        resizeSmallName();
    });
    changeOffset();
    resizeFixed();
    resizeSmallName();
});;;;
angular.module('ccc-app').factory('socketWrapper', ['$rootScope', '$interval', function socketWrapperFactory($rootScope, $interval) {
    $interval(function() {
        $rootScope.$apply();
    }, 200, 0, false);
    return io.connect('https://streamer.cryptocompare.com/', {
        secure: true
    });
}]);
angular.module('ccc-app').factory('streamerUtilities', ['$rootScope', '$filter', 'socketWrapper', 'subscriptionManager', 'orderBook', function streamerUtilitiesFactory($rootScope, $filter, socketWrapper, subscriptionManager, orderBook) {
    var displaySettings = CCC.CURRENT.DISPLAY.FIELDS;
    var displayFlagsLinked = CCC.CURRENT.DISPLAY.FLAGSLINK;
    var tradeDisplaySettings = CCC.TRADE.DISPLAY.FIELDS;
    var displayCurrency = CCC.STATIC.CURRENCY;
    var utilStatic = CCC.STATIC.UTIL;
    var isStreaming = true;
    var isConnected = false;
    var alreadyStopped = false;
    var globalPageSubs = {};
    var globalAuthKey = "";
    var streamerUtilitiesInstance = {};
    var cachedMessages = {};
    var aggPreLoaded = false;
    var monitorPreLoaded = false;
    socketWrapper.on('connect', function(data) {
        isConnected = true;
        $rootScope.$emit("SocketConnected", true);
    });
    socketWrapper.on('reconnect', function() {
        if (!isConnected) {
            isConnected = true;
            $rootScope.$emit("SocketConnected", true);
        } else {}
    });
    socketWrapper.on('reconnecting', function() {
        if (isConnected) {
            globalPageSubs = {};
            isConnected = false;
        }
    });
    socketWrapper.on('m', function(message) {
        var messageType = message.substring(0, message.indexOf("~"));
        switch (messageType) {
            case CCC.STATIC.TYPE.TRADE:
                streamerUtilitiesInstance.emitCurrentTrade('TradeMessage', message);
                break;
            case CCC.STATIC.TYPE.CURRENT:
                streamerUtilitiesInstance.emitCurrentMessage('CurrentMessage', message);
                break;
            case CCC.STATIC.TYPE.CURRENTAGG:
                streamerUtilitiesInstance.emitCurrentMessage('CurrentAggMessage', message);
                break;
            case CCC.STATIC.TYPE.ORDERBOOK:
                streamerUtilitiesInstance.emitOrderBookMessage('OrderBookMessage', message);
                break;
            case CCC.STATIC.TYPE.FULLORDERBOOK:
                streamerUtilitiesInstance.emitFullOrderBookMessage('FullOrderBookMessage', message);
                break;
            case CCC.STATIC.TYPE.ACTIVATION:
                streamerUtilitiesInstance.emitActivationMessage('ActivationMessage', message);
                break;
            case CCC.STATIC.TYPE.LOADCOMPLATE:
                if (!isStreaming && !alreadyStopped) {
                    streamerUtilitiesInstance.stopStreaming();
                    alreadyStopped = true;
                }
                break;
            case CCC.STATIC.TYPE.UNAUTHORIZED:
                console.log(message);
                break;
        }
    });
    streamerUtilitiesInstance.setGlobalAuthKey = function(authKey) {
        globalAuthKey = authKey;
    };
    streamerUtilitiesInstance.getStreamingStatus = function() {
        return isStreaming;
    };
    streamerUtilitiesInstance.stopStreaming = function() {
        var subsToSend = [];
        for (var sub in globalPageSubs) {
            if (globalPageSubs.hasOwnProperty(sub)) {
                subsToSend.push(sub);
            }
        }
        if (subsToSend.length > 0) {
            socketWrapper.emit('SubRemove', {
                subs: subsToSend
            });
            isStreaming = false;
            return true;
        }
        return false;
    };
    streamerUtilitiesInstance.startStreaming = function() {
        var subsToSend = [];
        if (isStreaming) {
            return false;
        }
        for (var sub in globalPageSubs) {
            if (globalPageSubs.hasOwnProperty(sub)) {
                subsToSend.push(sub);
            }
        }
        if (subsToSend.length > 0) {
            socketWrapper.emit('SubAdd', {
                subs: subsToSend,
                auth: globalAuthKey
            });
            isStreaming = true;
            return true;
        }
        return false;
    };
    streamerUtilitiesInstance.addGlobalPageSubs = function(subs, callback) {
        var subsToSend = [];
        for (var i = 0; i < subs.length; i++) {
            var currentSub = subs[i];
            if (globalPageSubs.hasOwnProperty(currentSub)) {
                globalPageSubs[currentSub] = globalPageSubs[currentSub] + 1;
                if (cachedMessages.hasOwnProperty(currentSub)) {
                    callback(cachedMessages[currentSub]);
                }
            } else {
                globalPageSubs[currentSub] = 1;
                subsToSend.push(currentSub);
                if (cachedMessages.hasOwnProperty(currentSub)) {
                    callback(cachedMessages[currentSub]);
                }
            }
        }
        if (subsToSend.length > 0) {
            socketWrapper.emit('SubAdd', {
                subs: subsToSend,
                auth: globalAuthKey
            });
        }
        alreadyStopped = false;
    };
    streamerUtilitiesInstance.removeGlobalPageSubs = function(subs) {
        var subsToRemove = [];
        for (var i = 0; i < subs.length; i++) {
            if (globalPageSubs.hasOwnProperty(subs[i])) {
                globalPageSubs[subs[i]] = globalPageSubs[subs[i]] - 1;
                if (globalPageSubs[subs[i]] == 0) {
                    subsToRemove.push(subs[i]);
                    delete globalPageSubs[subs[i]];
                }
            }
        }
        if (subsToRemove.length > 0) {
            socketWrapper.emit('SubRemove', {
                subs: subsToRemove
            });
        }
    };
    streamerUtilitiesInstance.initConnection = function() {
        return {
            connected: isConnected,
            loadingData: true,
            aggPreLoaded: aggPreLoaded,
            monitorPreLoaded: monitorPreLoaded,
            subs: [],
            data: [],
            orderbook: orderBook,
            keyToPosition: {},
            totalvolume24hour: 0
        };
    };
    streamerUtilitiesInstance.initProgressBar = function() {
        if (isConnected) {
            return {
                current: 2,
                message: 'Loading data...',
                max: 3
            };
        } else {
            return {
                current: 1,
                message: 'Connecting...',
                max: 3
            };
        }
    };
    streamerUtilitiesInstance.initOrdering = function() {
        return {
            isAscending: false,
            sortingField: ''
        };
    };
    streamerUtilitiesInstance.emitOrderBookMessage = function(messageType, messageRaw) {
        var messageToEmit = {};
        var currentOBMessage = CCC.ORDER.unpack(messageRaw);
        var subKey = CCC.ORDER.getKey(currentOBMessage);
        var orderBookKey = CCC.ORDER.getOrderBookKey(currentOBMessage);
        orderBook.decorateDisplayProperties(currentOBMessage);
        messageToEmit.Raw = messageRaw;
        messageToEmit.SubKey = subKey;
        messageToEmit.OrderBookKey = orderBookKey;
        messageToEmit.Obj = currentOBMessage;
        $rootScope.$emit(messageType, messageToEmit);
    };
    streamerUtilitiesInstance.emitFullOrderBookMessage = function(messageType, messageRaw) {
        var messageToEmit = {};
        var orderBookKey = orderBook.getKeyFromPacked(messageRaw);
        var subKey = CCC.STATIC.TYPE.ORDERBOOK + '~' + orderBookKey;
        messageToEmit.Raw = messageRaw;
        messageToEmit.SubKey = subKey;
        messageToEmit.OrderBookKey = orderBookKey;
        $rootScope.$emit(messageType, messageToEmit);
    };
    streamerUtilitiesInstance.emitActivationMessage = function(messageType, messageRaw) {
        var messageToEmit = {};
        var subKey = CCC.STATIC.TYPE.ACTIVATION + '~ACTIVATION';
        var currentParts = messageRaw.split('~');
        var currentActivationMessage = {};
        currentActivationMessage.T = CCC.STATIC.TYPE.ACTIVATION;
        currentActivationMessage.COUNTRY = currentParts[2] || 'N/A';
        messageToEmit.Raw = messageRaw;
        messageToEmit.SubKey = subKey;
        messageToEmit.Obj = currentActivationMessage;
        $rootScope.$emit(messageType, messageToEmit);
    };
    streamerUtilitiesInstance.emitCurrentTrade = function(messageType, messageRaw) {
        var currentTrade = CCC.TRADE.unpack(messageRaw);
        var subKey = CCC.TRADE.getKey(currentTrade);
        var currentDisplay = {};
        for (var property in currentTrade) {
            if (tradeDisplaySettings[property].Show) {
                switch (tradeDisplaySettings[property].Filter) {
                    case 'Date':
                        currentDisplay[property] = $filter('date')(currentTrade[property] * 1000, tradeDisplaySettings[property].Format);
                        break;
                    case 'Number':
                        var symbolType = tradeDisplaySettings[property].Symbol;
                        currentDisplay[property] = utilStatic.convertValueToDisplay(currentDisplay[symbolType], currentTrade[property], $filter('number'));
                        break;
                    case 'Text':
                        currentDisplay[property] = currentTrade[property];
                        break;
                    case 'CurrencySymbol':
                        currentDisplay[property] = displayCurrency.getSymbol(currentTrade[property]);
                        break;
                    case 'Market':
                        currentDisplay[property] = subscriptionManager.getNameForExchange(currentTrade[property]);
                        break
                    case 'TradeFlag':
                        if (parseInt(currentTrade[property], 16) & CCC.TRADE.FLAGS.SELL) {
                            currentDisplay[property] = 'Sell';
                        } else if (parseInt(currentTrade[property], 16) & CCC.TRADE.FLAGS.BUY) {
                            currentDisplay[property] = 'Buy';
                        } else {
                            currentDisplay[property] = 'Unknown';
                        }
                        break;
                }
            }
        }
        currentTrade['ARRIVEDON'] = new Date();
        currentTrade['highlight'] = true;
        currentTrade['DISPLAY'] = currentDisplay;
        var messageToEmit = {};
        messageToEmit.Raw = messageRaw;
        messageToEmit.SubKey = subKey;
        messageToEmit.Obj = currentTrade;
        $rootScope.$emit(messageType, messageToEmit);
    };
    streamerUtilitiesInstance.mergeObjects = function(obj1, obj2) {
        for (var attrname in obj2) {
            obj1[attrname] = obj2[attrname];
        }
        return obj1;
    }
    streamerUtilitiesInstance.copyObject = function(obj1) {
        var obj2 = {};
        for (var attrname in obj1) {
            obj1[attrname] = obj2[attrname];
        }
        return obj2;
    }
    streamerUtilitiesInstance.decorateCurrent = function(prevMessage, newMessage) {
        prevMessage = prevMessage || {};
        prevMessage['SUBKEY'] = prevMessage['SUBKEY'] || newMessage.SubKey;
        prevMessage['DATA'] = newMessage.Obj;
        prevMessage['DISPLAY'] = newMessage.Display;
        if (prevMessage['VISUAL']) {
            prevMessage['VISUAL'] = streamerUtilitiesInstance.mergeObjects(prevMessage['VISUAL'], newMessage.Visual);
        } else {
            prevMessage['VISUAL'] = newMessage.Visual;
        }
        return prevMessage;
    };
    streamerUtilitiesInstance.populatePortfolioPrice = function(price, secondPrice, conversionType) {
        var calculatedPrice = 0;
        switch (conversionType) {
            case "multiply":
                calculatedPrice = price * secondPrice;
                break;
            case "divide":
            case "invert_divide":
                calculatedPrice = price / secondPrice;
                break;
            case "invert_muliply":
                calculatedPrice = 1 / (price * secondPrice);
                break;
        }
        return calculatedPrice;
    };
    streamerUtilitiesInstance.populateConvertedVisual = function(coin, subs, subIndex) {
        var isFirstObject = subIndex == 0;
        var newMessage = subs[subIndex];
        var subKey = newMessage.SubKey;
        var setOppositeDirection = function(visualObject) {
            coin.VISUAL = {};
            coin.VISUAL["PRICEUP"] = visualObject["PRICEDOWN"];
            coin.VISUAL["PRICEDOWN"] = visualObject["PRICEUP"];
            coin.VISUAL["PRICEUNCHANGED"] = visualObject["PRICEUNCHANGED"];
        };
        switch (coin.Coin.Conversion) {
            case "direct":
            case "multiply":
                streamerUtilitiesInstance.mergeObjects(coin.VISUAL, newMessage.Visual);
                break;
            case "divide":
            case "invert_divide":
                if (isFirstObject) {
                    streamerUtilitiesInstance.mergeObjects(coin.VISUAL, newMessage.Visual);
                } else {
                    setOppositeDirection(newMessage.Visual);
                }
                break;
            case "invert":
            case "invert_muliply":
                if (isFirstObject) {
                    setOppositeDirection(newMessage.Visual);
                } else {
                    streamerUtilitiesInstance.mergeObjects(coin.VISUAL, newMessage.Visual);
                }
                break;
        }
    };
    streamerUtilitiesInstance.populateVisualBasedOnPrice = function(previousPriceValue, previousPriceDisplay, currentPriceValue, currentPriceDisplay) {
        var newVisual = {};
        if (previousPriceDisplay != currentPriceDisplay) {
            var dateNow = new Date();
            var animationExpires = dateNow.setMilliseconds(dateNow.getMilliseconds() + 900);
            if (previousPriceValue > currentPriceValue) {
                newVisual["PRICEDOWN"] = animationExpires;
            } else {
                newVisual["PRICEUP"] = animationExpires;
            }
        }
        return newVisual;
    };
    streamerUtilitiesInstance.decorateICOUpcomingOngoingMember = function(coin, subsNeeded, subIndex) {
        var conversion = coin.Coin.Conversion;
        var currentMessage = coin.DATA;
        var currentDisplay = coin.DISPLAY;
        if (isNaN(coin.CommonData.ICOStartPrice) || coin.CommonData.ICOStartPrice == 0) {
            currentMessage.ICOSTARTPRICE = 0;
            currentDisplay.ICOSTARTPRICE = "-";
            return coin;
        }
        var previousPriceValue = currentMessage.ICOSTARTPRICE || 0;
        var previousPriceDisplay = currentDisplay.ICOSTARTPRICE || "0";
        if (conversion == 'direct') {
            currentMessage.ICOSTARTPRICE = subsNeeded[0].Obj.PRICE * coin.CommonData.ICOStartPrice;
            currentMessage.OPEN24HOUR = subsNeeded[0].Obj.OPEN24HOUR * coin.CommonData.ICOStartPrice;
        } else if (conversion == 'invert') {
            currentMessage.ICOSTARTPRICE = coin.CommonData.ICOStartPrice / coin.subsNeeded[0].Obj.PRICE;
            currentMessage.OPEN24HOUR = coin.CommonData.ICOStartPrice / coin.subsNeeded[0].Obj.OPEN24HOUR;
        } else {
            currentMessage.ICOSTARTPRICE = streamerUtilitiesInstance.populatePortfolioPrice(coin.subsNeeded[0].Obj.PRICE, coin.subsNeeded[1].Obj.PRICE, conversion) * coin.CommonData.ICOStartPrice;
            currentMessage.OPEN24HOUR = streamerUtilitiesInstance.populatePortfolioPrice(coin.subsNeeded[0].Obj.OPEN24HOUR, coin.subsNeeded[1].Obj.OPEN24HOUR, conversion) * coin.CommonData.ICOStartPrice;
        }
        if (currentMessage.ICOSTARTPRICE > 0 && currentMessage.OPEN24HOUR > 0) {
            currentMessage.CHANGE24HOUR = currentMessage.ICOSTARTPRICE - currentMessage.OPEN24HOUR;
        }
        currentDisplay.ICOSTARTPRICE = utilStatic.convertValueToDisplay("$", currentMessage.ICOSTARTPRICE, $filter('number'));
        var newVisual = streamerUtilitiesInstance.populateVisualBasedOnPrice(previousPriceValue, previousPriceDisplay, currentMessage.ICOSTARTPRICE, currentDisplay.ICOSTARTPRICE);
        streamerUtilitiesInstance.mergeObjects(coin.VISUAL, newVisual);
        return coin;
    };
    streamerUtilitiesInstance.decorateICOPastMember = function(coin, subsNeeded, subIndex) {
        var conversion = coin.Coin.Conversion;
        var currentMessage = coin.DATA;
        var currentDisplay = coin.DISPLAY;
        var previousPriceValue = currentMessage.PRICE;
        var previousPriceDisplay = currentDisplay.PRICE;
        if (conversion == 'direct') {
            currentMessage.PRICE = subsNeeded[0].Obj.PRICE;
            currentMessage.OPEN24HOUR = subsNeeded[0].Obj.OPEN24HOUR;
        } else if (conversion == 'invert') {
            currentMessage.PRICE = 1 / subsNeeded[0].Obj.PRICE;
            currentMessage.OPEN24HOUR = 1 / subsNeeded[0].Obj.OPEN24HOUR;
        } else {
            currentMessage.PRICE = streamerUtilitiesInstance.populatePortfolioPrice(subsNeeded[0].Obj.PRICE, subsNeeded[1].Obj.PRICE, conversion);
            currentMessage.OPEN24HOUR = streamerUtilitiesInstance.populatePortfolioPrice(subsNeeded[0].Obj.OPEN24HOUR, subsNeeded[1].Obj.OPEN24HOUR, conversion);
        }
        currentDisplay.PRICE = utilStatic.convertValueToDisplay("$", currentMessage.PRICE, $filter('number'));
        currentDisplay.OPEN24HOUR = utilStatic.convertValueToDisplay("$", currentMessage.OPEN24HOUR, $filter('number'));
        var newCHANGE24HOUR = currentMessage.PRICE - currentMessage.OPEN24HOUR;
        currentMessage.CHANGE24HOUR = newCHANGE24HOUR;
        currentMessage.CHANGEPCT24HOUR = currentMessage.CHANGE24HOUR / currentMessage.OPEN24HOUR * 100;
        if (Math.abs(currentMessage.CHANGE24HOUR) > 10000) {
            currentDisplay.CHANGE24HOUR = '$ ' + $filter('number')(currentMessage.CHANGE24HOUR, 0);
        } else if (Math.abs(currentMessage.CHANGE24HOUR) > 1) {
            currentDisplay.CHANGE24HOUR = '$ ' + $filter('number')(currentMessage.CHANGE24HOUR, 2);
        } else {
            currentDisplay.CHANGE24HOUR = '$ ' + currentMessage.CHANGE24HOUR.toPrecision(2);
        }
        currentDisplay.CHANGEPCT24HOUR = $filter('number')(currentMessage.CHANGEPCT24HOUR, 2) + "%";
        if (isNaN(coin.CommonData.TotalCoinsMined) || coin.CommonData.TotalCoinsMined == 0) {
            currentMessage.MKTCAP = 0;
            currentDisplay.MKTCAP = "-";
        } else {
            currentMessage.MKTCAP = currentMessage.PRICE * coin.CommonData.TotalCoinsMined;
            currentDisplay.MKTCAP = utilStatic.convertValueToDisplay("$", currentMessage.MKTCAP, $filter('number'), 'short');
        }
        if (currentMessage.ICOPRICE) {
            currentMessage.ROI = (currentMessage.PRICE / coin.DATA.ICOPRICE - 1) * 100;
            currentDisplay.ROI = utilStatic.convertValueToDisplay("", currentMessage.ROI, $filter('number'), 'short') + "%";
        } else {
            currentMessage.ROI = 0;
            currentDisplay.ROI = "-";
        }
        var newVisual = streamerUtilitiesInstance.populateVisualBasedOnPrice(previousPriceValue, previousPriceDisplay, currentMessage.PRICE, currentDisplay.PRICE);
        streamerUtilitiesInstance.mergeObjects(coin.VISUAL, newVisual);
        return coin;
    };
    streamerUtilitiesInstance.decorateCurrentPorfolioMember = function(prevMessage, newMessage, type, portfolioCurrency, conversionType) {
        var dateNow = new Date();
        var animationExpires = dateNow.setMilliseconds(dateNow.getMilliseconds() + 900);
        prevMessage.PriceInfo[type].RAW = newMessage.Obj;
        prevMessage.PriceInfo[type].DISPLAY = newMessage.Display;
        var currentPrice = newMessage.Obj.PRICE;
        var currentOpen = newMessage.Obj.OPEN24HOUR;
        var lastUpdate = newMessage.Obj.LASTUPDATE;
        var displaySymbol = displayCurrency.getSymbol(portfolioCurrency);
        var isRealatedToConversion = false;
        prevMessage.PriceInfo.PortfolioValues.RAW.LastUpdate = lastUpdate;
        switch (type) {
            case 'Current':
                prevMessage.PriceInfo.PortfolioValues.RAW.PrevPrice = prevMessage.PriceInfo.PortfolioValues.RAW.Price;
                if (conversionType == 'invert') {
                    prevMessage.PriceInfo.PortfolioValues.RAW.Price = 1 / currentPrice;
                    prevMessage.PriceInfo.PortfolioValues.RAW.Open24Hour = 1 / currentOpen;
                } else {
                    prevMessage.PriceInfo.PortfolioValues.RAW.Price = currentPrice;
                    prevMessage.PriceInfo.PortfolioValues.RAW.Open24Hour = currentOpen;
                }
                break;
            case 'Conversion':
                if (prevMessage.PriceInfo.SubOne.RAW.hasOwnProperty('PRICE')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.PrevPrice = prevMessage.PriceInfo.PortfolioValues.RAW.Price;
                    prevMessage.PriceInfo.PortfolioValues.RAW.Price = streamerUtilitiesInstance.populatePortfolioPrice(prevMessage.PriceInfo.SubOne.RAW.PRICE, currentPrice, conversionType);
                }
                if (prevMessage.PriceInfo.SubOne.RAW.hasOwnProperty('OPEN24HOUR')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.Open24Hour = streamerUtilitiesInstance.populatePortfolioPrice(prevMessage.PriceInfo.SubOne.RAW.OPEN24HOUR, currentOpen, conversionType);
                }
                break;
            case 'SubOne':
                if (prevMessage.PriceInfo.Conversion.RAW.hasOwnProperty('PRICE')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.PrevPrice = prevMessage.PriceInfo.PortfolioValues.RAW.Price;
                    prevMessage.PriceInfo.PortfolioValues.RAW.Price = streamerUtilitiesInstance.populatePortfolioPrice(currentPrice, prevMessage.PriceInfo.Conversion.RAW.PRICE, conversionType);
                }
                if (prevMessage.PriceInfo.Conversion.RAW.hasOwnProperty('OPEN24HOUR')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.Open24Hour = streamerUtilitiesInstance.populatePortfolioPrice(currentOpen, prevMessage.PriceInfo.Conversion.RAW.OPEN24HOUR, conversionType);
                }
                break;
            case 'CurrentBuy':
                if (conversionType == 'invert') {
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionPrice = 1 / currentPrice;
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionOpen24Hour = 1 / currentOpen;
                } else {
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionPrice = currentPrice;
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionOpen24Hour = currentOpen;
                }
                isRealatedToConversion = true;
                break;
            case 'ConversionBuy':
                if (prevMessage.PriceInfo.ConversionBuySubOne.RAW.hasOwnProperty('PRICE')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionPrice = streamerUtilitiesInstance.populatePortfolioPrice(prevMessage.PriceInfo.ConversionBuySubOne.RAW.PRICE, currentPrice, conversionType);
                    isRealatedToConversion = true;
                }
                if (prevMessage.PriceInfo.ConversionBuySubOne.RAW.hasOwnProperty('OPEN24HOUR')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionOpen24Hour = streamerUtilitiesInstance.populatePortfolioPrice(prevMessage.PriceInfo.ConversionBuySubOne.RAW.OPEN24HOUR, currentOpen, conversionType);
                    isRealatedToConversion = true;
                }
                break;
            case 'ConversionBuySubOne':
                if (prevMessage.PriceInfo.ConversionBuy.RAW.hasOwnProperty('PRICE')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionPrice = streamerUtilitiesInstance.populatePortfolioPrice(currentPrice, prevMessage.PriceInfo.ConversionBuy.RAW.PRICE, conversionType);
                    isRealatedToConversion = true;
                }
                if (prevMessage.PriceInfo.ConversionBuy.RAW.hasOwnProperty('OPEN24HOUR')) {
                    prevMessage.PriceInfo.PortfolioValues.RAW.BuyConversionOpen24Hour = streamerUtilitiesInstance.populatePortfolioPrice(currentOpen, prevMessage.PriceInfo.ConversionBuy.RAW.OPEN24HOUR, conversionType);
                    isRealatedToConversion = true;
                }
                break;
        }
        if (isRealatedToConversion == true) {
            prevMessage.PriceInfo.Visual.CONVERSIONBUY = animationExpires;
        }
        return prevMessage;
    };
    streamerUtilitiesInstance.decorateCurrentWithMktCap = function(prevMessage, newMessage, totalCoinsMined) {
        prevMessage = prevMessage || {};
        prevMessage['SUBKEY'] = prevMessage['SUBKEY'] || newMessage.SubKey;
        prevMessage['DATA'] = newMessage.Obj;
        prevMessage['DISPLAY'] = newMessage.Display;
        prevMessage.DATA.MKTCAP = 0;
        prevMessage.DISPLAY.MKTCAP = "N/A";
        if (totalCoinsMined != 0) {
            prevMessage.DATA.MKTCAP = prevMessage['DATA'].PRICE * totalCoinsMined;
            prevMessage.DISPLAY.MKTCAP = utilStatic.convertValueToDisplay(prevMessage.DISPLAY.TOSYMBOL, prevMessage.DATA.MKTCAP, $filter('number'), 'short');
        }
        if (prevMessage['VISUAL']) {
            prevMessage['VISUAL'] = streamerUtilitiesInstance.mergeObjects(prevMessage['VISUAL'], newMessage.Visual);
        } else {
            prevMessage['VISUAL'] = newMessage.Visual;
        }
        return prevMessage;
    };
    streamerUtilitiesInstance.decorateMktCap = function(messageInfo, totalCoinsMined) {
        var messageToReturn = {};
        messageToReturn.DATA = {};
        messageToReturn.DISPLAY = {};
        var currentPrice = messageInfo.Obj.PRICE;
        var displaySymbol = messageInfo.Display.TOSYMBOL;
        messageToReturn.DATA.PRICE = currentPrice;
        messageToReturn.DATA.MKTCAP = 0;
        messageToReturn.DISPLAY.PRICE = utilStatic.convertValueToDisplay(displaySymbol, currentPrice, $filter('number'));
        messageToReturn.DISPLAY.MKTCAP = "Not Available";
        if (totalCoinsMined != 0) {
            messageToReturn.DATA.MKTCAP = currentPrice * totalCoinsMined;
            messageToReturn.DISPLAY.MKTCAP = utilStatic.convertValueToDisplay(displaySymbol, messageToReturn.DATA.MKTCAP, $filter('number'), 'short');
        }
        return messageToReturn;
    };
    streamerUtilitiesInstance.decorateCurrenyMktShare = function(messageInfo, totalVolume) {
        var messageToReturn = {};
        messageToReturn.DATA = {};
        messageToReturn.DISPLAY = {};
        var volumeForm = messageInfo.Obj.VOLUME24HOUR;
        var volumeTo = messageInfo.Obj.VOLUME24HOURTO;
        var displayToSymbol = messageInfo.Display.TOSYMBOL;
        var displayFromSymbol = messageInfo.Display.FROMSYMBOL;
        messageToReturn.DATA.VOLUME24HOUR = volumeForm;
        messageToReturn.DATA.VOLUME24HOURTO = volumeTo;
        messageToReturn.DISPLAY.VOLUME24HOUR = utilStatic.convertValueToDisplay(displayFromSymbol, volumeForm, $filter('number'));
        messageToReturn.DISPLAY.VOLUME24HOURTO = utilStatic.convertValueToDisplay(displayToSymbol, volumeTo, $filter('number'));
        messageToReturn.DISPLAY.TOSYMBOL = displayToSymbol;
        messageToReturn.DISPLAY.FROMSYMBOL = displayFromSymbol;
        return messageToReturn;
    };
    streamerUtilitiesInstance.initMonitorFromServer = function(rawDataArray) {
        for (var i = 0, length = rawDataArray.length; i < length; i++) {
            streamerUtilitiesInstance.emitCurrentMessage('CurrentMessage', rawDataArray[i]);
        }
        monitorPreLoaded = true;
    };
    streamerUtilitiesInstance.initAggFromServer = function(rawDataArray) {
        for (var i = 0, length = rawDataArray.length; i < length; i++) {
            streamerUtilitiesInstance.emitCurrentMessage('CurrentAggMessage', rawDataArray[i]);
        }
        aggPreLoaded = true;
    };
    streamerUtilitiesInstance.generateCurrentMessage = function(messageRaw) {
        var lastestMessage = CCC.CURRENT.unpack(messageRaw);
        var subKey = CCC.CURRENT.getKey(lastestMessage);
        var dateNow = new Date();
        var animationExpires = dateNow.setMilliseconds(dateNow.getMilliseconds() + 900);
        var currentMessageFull = cachedMessages[subKey] || {};
        var currentMessage = currentMessageFull['Obj'] || {};
        var currentDisplay = currentMessageFull['Display'] || {};
        var currentVisual = {};
        currentDisplay.FROMSYMBOL = displayCurrency.getSymbol(lastestMessage.FROMSYMBOL);
        currentDisplay.TOSYMBOL = displayCurrency.getSymbol(lastestMessage.TOSYMBOL);
        for (var flag in CCC.CURRENT.FLAGS) {
            if (parseInt(lastestMessage['FLAGS'], 16) & CCC.CURRENT.FLAGS[flag]) {
                currentVisual[flag] = animationExpires;
                for (var i = 0; i < displayFlagsLinked[flag].length; i++) {
                    currentVisual[displayFlagsLinked[flag][i]] = false;
                }
            }
        }
        for (var property in lastestMessage) {
            currentMessage[property] = lastestMessage[property];
            if (displaySettings[property].Show) {
                currentVisual[property] = animationExpires;
                switch (displaySettings[property].Filter) {
                    case 'Date':
                        currentDisplay[property] = $filter('date')(lastestMessage[property] * 1000, displaySettings[property].Format);
                        break;
                    case 'Number':
                        var symbolType = displaySettings[property].Symbol;
                        currentDisplay[property] = utilStatic.convertValueToDisplay(currentDisplay[symbolType], lastestMessage[property], $filter('number'));
                        if (displaySettings[property].SortNumberAsWell == true) {
                            currentDisplay[property + '_SHORT'] = utilStatic.convertValueToDisplay(currentDisplay[symbolType], lastestMessage[property], $filter('number'), 'short');
                        }
                        break;
                    case 'String':
                        currentDisplay[property] = lastestMessage[property];
                        break;
                    case 'Market':
                        currentDisplay[property] = subscriptionManager.getNameForExchange(lastestMessage[property]);
                        break
                }
            }
        }
        var newCHANGE24HOUR = currentMessage.PRICE - currentMessage.OPEN24HOUR;
        currentVisual.CHANGE24HOUR = animationExpires;
        currentMessage.CHANGE24HOUR = newCHANGE24HOUR;
        currentMessage.CHANGEPCT24HOUR = currentMessage.CHANGE24HOUR / currentMessage.OPEN24HOUR * 100;
        if (Math.abs(currentMessage.CHANGE24HOUR) > 10000) {
            currentDisplay.CHANGE24HOUR = currentDisplay.TOSYMBOL + ' ' + $filter('number')(currentMessage.CHANGE24HOUR, 0);
        } else if (Math.abs(currentMessage.CHANGE24HOUR) > 1) {
            currentDisplay.CHANGE24HOUR = currentDisplay.TOSYMBOL + ' ' + $filter('number')(currentMessage.CHANGE24HOUR, 2);
        } else {
            currentDisplay.CHANGE24HOUR = currentDisplay.TOSYMBOL + ' ' + currentMessage.CHANGE24HOUR.toPrecision(2);
        }
        currentDisplay.CHANGEPCT24HOUR = $filter('number')(currentMessage.CHANGEPCT24HOUR, 2);
        if (currentMessage.CHANGE24HOUR > 0) {
            currentDisplay.CHANGE24HOURUP = animationExpires;
            currentDisplay.CHANGE24HOURUNCHANGED = false;
            currentDisplay.CHANGE24HOURDOWN = false;
        } else if (currentMessage.CHANGE24HOUR < 0) {
            currentDisplay.CHANGE24HOURDOWN = animationExpires;
            currentDisplay.CHANGE24HOURUNCHANGED = false;
            currentDisplay.CHANGE24HOURUP = false;
        } else {
            currentDisplay.CHANGE24HOURUNCHANGED = animationExpires;
            currentDisplay.CHANGE24HOURDOWN = false;
            currentDisplay.CHANGE24HOURUP = false;
        }
        var messageToEmit = {};
        messageToEmit.Raw = messageRaw;
        messageToEmit.SubKey = subKey;
        messageToEmit.Obj = currentMessage;
        messageToEmit.Visual = currentVisual;
        messageToEmit.Display = currentDisplay;
        cachedMessages[subKey] = messageToEmit;
        return messageToEmit;
    };
    streamerUtilitiesInstance.emitCurrentMessage = function(messageType, messageRaw) {
        $rootScope.$emit(messageType, streamerUtilitiesInstance.generateCurrentMessage(messageRaw));
    };
    return streamerUtilitiesInstance;
}]);
angular.module('ccc-app').factory('orderBook', ['$rootScope', '$filter', '$interval', function orderBookFactory($rootScope, $filter, $interval) {
    var displayCurrency = CCC.STATIC.CURRENCY;
    var utilStatic = CCC.STATIC.UTIL;
    var orderDisplaySettings = CCC.ORDER.DISPLAY.FIELDS;
    var orderBookInstance = {};
    var DATA = {};
    var KEYS = {};
    var ORDERSARRAY = {};
    var AGGREGATING = false;
    orderBookInstance.reset = function() {
        KEYS = {};
        DATA = {};
        ORDERSARRAY = {};
    };
    orderBookInstance.initOrderBookKey = function(orderBookKey, seq) {
        if (!seq) {
            seq = 0;
        }
        KEYS[orderBookKey] = {};
        KEYS[orderBookKey][CCC.ORDER.SIDE.BID] = [];
        KEYS[orderBookKey][CCC.ORDER.SIDE.ASK] = [];
        KEYS[orderBookKey]['SEQUENCE'] = parseFloat(seq);
        KEYS[orderBookKey]['LOADING'] = true;
        if (!KEYS[orderBookKey].hasOwnProperty('QUEUE')) {
            KEYS[orderBookKey]['QUEUE'] = [];
        }
        DATA[orderBookKey] = {};
        ORDERSARRAY[orderBookKey] = {};
        ORDERSARRAY[orderBookKey][CCC.ORDER.SIDE.BID] = [];
        ORDERSARRAY[orderBookKey][CCC.ORDER.SIDE.ASK] = [];
    };
    orderBookInstance.resetOrderBookKeepQueue = function(orderBookKey, seq) {
        if (!KEYS.hasOwnProperty(orderBookKey)) {
            KEYS[orderBookKey] = {};
            KEYS[orderBookKey]['QUEUE'] = [];
        }
        KEYS[orderBookKey][CCC.ORDER.SIDE.BID] = [];
        KEYS[orderBookKey][CCC.ORDER.SIDE.ASK] = [];
        KEYS[orderBookKey]['SEQUENCE'] = parseFloat(seq);
        DATA[orderBookKey] = {};
        ORDERSARRAY[orderBookKey] = {};
        ORDERSARRAY[orderBookKey][CCC.ORDER.SIDE.BID] = [];
        ORDERSARRAY[orderBookKey][CCC.ORDER.SIDE.ASK] = [];
    };
    orderBookInstance.hasOrderBookKey = function(orderBookKey) {
        if (KEYS.hasOwnProperty(orderBookKey)) {
            return true;
        }
        return false;
    };
    orderBookInstance.isLoading = function(orderBookKey) {
        return KEYS[orderBookKey]['LOADING'];
    };
    orderBookInstance.getTopOrderKeysByLimit = function(orderBookKey, side, max) {
        return KEYS[orderBookKey][side].slice(0, max);
    };
    orderBookInstance.getTotalSizeQuantity = function(orderBookKey, side) {
        if (KEYS[orderBookKey]['LOADING']) {
            return "Loading...";
        }
        var currentObArray = ORDERSARRAY[orderBookKey][side];
        var lastOrderKey = currentObArray.length - 1;
        return currentObArray[lastOrderKey]['DISPLAY']['TOTAL'];
    };
    orderBookInstance.getTotalSizeValue = function(orderBookKey, side) {
        if (KEYS[orderBookKey]['LOADING']) {
            return "Loading...";
        }
        var currentObArray = ORDERSARRAY[orderBookKey][side];
        var lastOrderKey = currentObArray.length - 1;
        return currentObArray[lastOrderKey]['DISPLAY']['QTOTAL'];
    };
    orderBookInstance.getTopOrders = function(orderBookKey, side) {
        return ORDERSARRAY[orderBookKey][side];
    };
    orderBookInstance.startAggregating = function() {
        if (AGGREGATING == false) {
            AGGREGATING = true;
            $interval(function() {
                for (var orderBookKey in KEYS) {
                    orderBookInstance.decorateAggregatedProperties(orderBookKey, CCC.ORDER.SIDE.BID);
                    orderBookInstance.decorateAggregatedProperties(orderBookKey, CCC.ORDER.SIDE.ASK);
                }
            }, 250, 0, false);
        }
    };
    orderBookInstance.finishedLoading = function(orderBookKey) {
        KEYS[orderBookKey]['LOADING'] = false;
        orderBookInstance.startAggregating();
    };
    orderBookInstance.getSequenceNumber = function(orderBookKey) {
        return KEYS[orderBookKey]['SEQUENCE'];
    };
    orderBookInstance.decorateAggregatedProperties = function(orderBookKey, side) {
        var currentOb = KEYS[orderBookKey][side];
        var obSideLength = currentOb.length;
        var qtotal = 0,
            total = 0;
        var timestampToCheckAgainst = new Date().getTime() - 600;
        ORDERSARRAY[orderBookKey][side] = [];
        for (var i = 0, len = obSideLength; i < len; i++) {
            var currentItem = DATA[orderBookKey][currentOb[i]];
            qtotal += currentItem['QuantityTotal'];
            total += currentItem['Q'];
            currentItem['TOTAL'] = total;
            currentItem['QTOTAL'] = qtotal;
            currentItem['DISPLAY']['TOTAL'] = utilStatic.convertValueToDisplay(currentItem['DISPLAY']['FSYM'], total, $filter('number'), 'short');
            currentItem['DISPLAY']['QTOTAL'] = utilStatic.convertValueToDisplay(currentItem['DISPLAY']['TSYM'], qtotal, $filter('number'), 'short');
            if (currentItem['HIGHLIGHT'] == true && timestampToCheckAgainst > currentItem['ARRIVEDONTS']) {
                currentItem['HIGHLIGHT'] = false;
            }
            ORDERSARRAY[orderBookKey][side].push(currentItem);
        }
    };
    orderBookInstance.decorateDisplayProperties = function(currentOBMessage) {
        var currentDisplay = {};
        for (var property in currentOBMessage) {
            if (orderDisplaySettings[property].Show) {
                switch (orderDisplaySettings[property].Filter) {
                    case 'Number':
                        if (orderDisplaySettings[property].Symbol == "NONE") {
                            currentDisplay[property] = utilStatic.convertValueToDisplay('', currentOBMessage[property], $filter('number'), '8decimals');
                        } else {
                            var symbolType = orderDisplaySettings[property].Symbol;
                            currentDisplay[property] = utilStatic.convertValueToDisplay(currentDisplay[symbolType], currentOBMessage[property], $filter('number'), '8decimals');
                        }
                        break;
                    case 'Text':
                        currentDisplay[property] = currentOBMessage[property];
                        break;
                    case 'CurrencySymbol':
                        currentDisplay[property] = displayCurrency.getSymbol(currentOBMessage[property]);
                        break;
                    case 'Market':
                        currentDisplay[property] = utilStatic.getNameForExchange(currentOBMessage[property]);
                        break;
                }
            }
        }
        currentOBMessage['QuantityTotal'] = currentOBMessage['P'] * currentOBMessage['Q'];
        if (parseInt(currentOBMessage['S'], 16) & CCC.ORDER.SIDE.BID) {
            currentDisplay['S'] = 'BID';
        } else if (parseInt(currentOBMessage['S'], 16) & CCC.ORDER.SIDE.ASK) {
            currentDisplay['S'] = 'ASK';
        }
        if (parseInt(currentOBMessage['F'], 16) & CCC.ORDER.FLAGS.CHANGE) {
            currentDisplay['F'] = 'CHANGE';
            currentDisplay['QT'] = utilStatic.convertValueToDisplay(currentDisplay['TSYM'], currentOBMessage['QuantityTotal'], $filter('number'), '8decimals');
        } else if (parseInt(currentOBMessage['F'], 16) & CCC.ORDER.FLAGS.REMOVE) {
            currentDisplay['F'] = 'REMOVE';
        } else if (parseInt(currentOBMessage['F'], 16) & CCC.ORDER.FLAGS.ADD) {
            currentDisplay['F'] = 'ADD';
            currentDisplay['QT'] = utilStatic.convertValueToDisplay(currentDisplay['TSYM'], currentOBMessage['QuantityTotal'], $filter('number'), '8decimals');
        }
        currentOBMessage['ARRIVEDONTS'] = new Date().getTime();
        currentOBMessage['HIGHLIGHT'] = true;
        currentOBMessage['DISPLAY'] = currentDisplay;
    }
    orderBookInstance.getAllOrderBookKeysWithQueue = function() {
        var keysWithQueue = [];
        for (var orderBookKey in KEYS) {
            if (KEYS[orderBookKey]['QUEUE'].length > 0) {
                keysWithQueue.push(orderBookKey);
            }
        }
        return keysWithQueue;
    };
    orderBookInstance.getQueueSequanceMissmatchLength = function(orderBookKey) {
        return KEYS[orderBookKey]['QUEUE'].length;
    };
    orderBookInstance.queueOrderSequenceMissmatch = function(orderBookKey, orderObject) {
        KEYS[orderBookKey]['QUEUE'].push(orderObject);
    };
    orderBookInstance.getQueueItemSequenceMissmatch = function(orderBookKey) {
        if (KEYS[orderBookKey]['QUEUE'].length > 0) {
            return KEYS[orderBookKey]['QUEUE'].pop();
        }
        return null;
    };
    orderBookInstance.unpack = function(orderBookPacked) {
        var splitPosition = orderBookPacked.indexOf(':');
        var orderBookKeyAndSeq = orderBookPacked.substring((CCC.STATIC.TYPE.FULLORDERBOOK.length + 1), splitPosition);
        var obkPosition = orderBookKeyAndSeq.indexOf('|');
        var orderBookKey = orderBookKeyAndSeq.substring(0, obkPosition);
        var obSequance = orderBookKeyAndSeq.substring(obkPosition + 1);
        var orderBookBothOrderTypes = orderBookPacked.substring(splitPosition + 1);
        var secSplitPosition = orderBookBothOrderTypes.indexOf(':');
        var bidOrdersArray = orderBookBothOrderTypes.substring(0, secSplitPosition).split(',');
        var askOrdersArray = orderBookBothOrderTypes.substring(secSplitPosition + 1).split(',');
        orderBookInstance.resetOrderBookKeepQueue(orderBookKey, obSequance);
        for (var indexOB = 0, lengthOB = bidOrdersArray.length; indexOB < lengthOB; indexOB++) {
            var orderObjectBid = CCC.ORDER.unpack(CCC.STATIC.TYPE.ORDERBOOK + '~' + orderBookKey + '~' + CCC.ORDER.SIDE.BID + '~' + CCC.ORDER.FLAGS.ADD + '~' + obSequance + '~' + bidOrdersArray[indexOB]);
            var objectKeyBid = CCC.ORDER.getObjectKey(orderObjectBid);
            KEYS[orderBookKey][orderObjectBid.S].push(objectKeyBid);
            orderBookInstance.decorateDisplayProperties(orderObjectBid);
            DATA[orderBookKey][objectKeyBid] = orderObjectBid;
        }
        orderBookInstance.decorateAggregatedProperties(orderBookKey, CCC.ORDER.SIDE.BID);
        for (var indexOA = 0, lengthOA = askOrdersArray.length; indexOA < lengthOA; indexOA++) {
            var orderObjectAsk = CCC.ORDER.unpack(CCC.STATIC.TYPE.ORDERBOOK + '~' + orderBookKey + '~' + CCC.ORDER.SIDE.ASK + '~' + CCC.ORDER.FLAGS.ADD + '~' + obSequance + '~' + askOrdersArray[indexOA]);
            var objectKeyAsk = CCC.ORDER.getObjectKey(orderObjectAsk);
            KEYS[orderBookKey][orderObjectAsk.S].push(objectKeyAsk);
            orderBookInstance.decorateDisplayProperties(orderObjectAsk);
            DATA[orderBookKey][objectKeyAsk] = orderObjectAsk;
        }
        orderBookInstance.decorateAggregatedProperties(orderBookKey, CCC.ORDER.SIDE.ASK);
        orderBookInstance.finishedLoading(orderBookKey);
    };
    orderBookInstance.getKeyFromPacked = function(orderBookPacked) {
        var splitPosition = orderBookPacked.indexOf(':');
        var orderBookKeyAndSeq = orderBookPacked.substring((CCC.STATIC.TYPE.FULLORDERBOOK.length + 1), splitPosition);
        var obkPosition = orderBookKeyAndSeq.indexOf('|');
        return orderBookKeyAndSeq.substring(0, obkPosition);
    };
    orderBookInstance.handleOrder = function(orderObject) {
        if (orderObject.T != CCC.STATIC.TYPE.ORDERBOOK) {
            return false;
        }
        var orderBookKey = CCC.ORDER.getOrderBookKey(orderObject);
        var objectKey = CCC.ORDER.getObjectKey(orderObject);
        var inserted = false,
            removed = false,
            changed = false;
        if (KEYS[orderBookKey].SEQUENCE > orderObject.SEQ) {
            orderObject.F = CCC.ORDER.FLAGS.NOACTION;
            return false;
        }
        KEYS[orderBookKey].SEQUENCE = orderObject.SEQ;
        if (orderObject.F == CCC.ORDER.FLAGS.NOACTION) {
            return false;
        }
        switch (orderObject.F) {
            case CCC.ORDER.FLAGS.ADD:
                var sideLength = KEYS[orderBookKey][orderObject.S].length;
                DATA[orderBookKey][objectKey] = orderObject;
                if (sideLength == 0) {
                    KEYS[orderBookKey][orderObject.S].push(objectKey);
                    inserted = true;
                } else {
                    var currentItemKey;
                    var insertPositionBid = 0,
                        insertPositionAsk = 0;
                    if (orderObject.S == CCC.ORDER.SIDE.BID) {
                        while (insertPositionBid < sideLength && !inserted) {
                            currentItemKey = KEYS[orderBookKey][orderObject.S][insertPositionBid];
                            if (orderObject.P > DATA[orderBookKey][currentItemKey].P) {
                                KEYS[orderBookKey][orderObject.S].splice(insertPositionBid, 0, objectKey);
                                inserted = true;
                            }
                            insertPositionBid++;
                        }
                    } else {
                        while (insertPositionAsk < sideLength && !inserted) {
                            currentItemKey = KEYS[orderBookKey][orderObject.S][insertPositionAsk];
                            if (orderObject.P < DATA[orderBookKey][currentItemKey].P) {
                                KEYS[orderBookKey][orderObject.S].splice(insertPositionAsk, 0, objectKey);
                                inserted = true;
                            }
                            insertPositionAsk++;
                        }
                    }
                    if (!inserted) {
                        KEYS[orderBookKey][orderObject.S].push(objectKey);
                    }
                }
                break;
            case CCC.ORDER.FLAGS.REMOVE:
                var sidePosition = KEYS[orderBookKey][orderObject.S].indexOf(objectKey);
                if (sidePosition > -1) {
                    KEYS[orderBookKey][orderObject.S].splice(sidePosition, 1);
                    delete DATA[orderBookKey][objectKey];
                    removed = true;
                }
                break;
            case CCC.ORDER.FLAGS.CHANGE:
                var orderExists = KEYS[orderBookKey][orderObject.S].indexOf(objectKey);
                if (orderExists > -1) {
                    DATA[orderBookKey][objectKey] = orderObject;
                    changed = true;
                }
                break;
        }
        var action = inserted || removed || changed;
        return action;
    };
    return orderBookInstance;
}]);;;;
angular.module('ccc-app').controller('StreamingOrderBookCtrl', ['$rootScope', '$scope', '$timeout', '$stateParams', '$filter', '$interval', 'subscriptionManager', 'streamerUtilities', 'pageInfo', 'dateParsing', 'chartUtil', function($rootScope, $scope, $timeout, $stateParams, $filter, $interval, subscriptionManager, streamerUtilities, pageInfo, dateParsing, chartUtil) {
    $scope.dateParsing = dateParsing;
    $scope.connection = streamerUtilities.initConnection();
    $scope.progressBar = streamerUtilities.initProgressBar();
    $scope.markets = [];
    $scope.marketDepthStats = {
        RAW: {
            bid: 0,
            ask: 0,
            worstBid: 0,
            worstAsk: 0,
            mid: 0,
            spread: 0
        },
        DISPLAY: {
            bid: 0,
            ask: 0,
            worstBid: 0,
            worstAsk: 0,
            mid: 0,
            spread: 0
        }
    };
    $scope.chartIsLoading = true;
    $scope.startIndex = 0;
    $scope.endIndex = 0;
    $scope.lastIndex = 0;
    $scope.currentObKey = "";
    $scope.toSymbol = subscriptionManager.getCurrentToSymbol();
    $scope.toSymbolDisplay = CCC.STATIC.CURRENCY.getSymbol($scope.toSymbol);
    $scope.fromSymbol = pageInfo.getSymbol() || pageInfo.getH1Text();
    $scope.fromSymbolDisplay = CCC.STATIC.CURRENCY.getSymbol($scope.fromSymbol);
    $scope.generateMarketsFromSubs = function(subs) {
        $scope.markets = [];
        $scope.exchangeAlreadyExists = {};
        for (var i = 0, length = subs.length; i < length; i++) {
            var currentSubDetails = CCC.ORDER.unpack(subs[i]);
            var subToPush = {
                'Market': subscriptionManager.getNameForExchange(currentSubDetails.M),
                'IsStreaming': true,
                'SubKey': subs[i]
            };
            var obKey = CCC.ORDER.getOrderBookKey(currentSubDetails);
            $scope.connection.orderbook.initOrderBookKey(obKey, -1);
            $scope.currentObKey = obKey;
            if (!$scope.exchangeAlreadyExists.hasOwnProperty(currentSubDetails.M)) {
                $scope.markets.push(subToPush);
                $scope.exchangeAlreadyExists[currentSubDetails.M] = true;
            }
        }
    };
    $scope.reconnectAll = function(symbol) {
        $scope.connection.subs = subscriptionManager.getComputedOrderBookSubsBySymbol(symbol);
        $scope.exchanges = $scope.generateMarketsFromSubs($scope.connection.subs);
        streamerUtilities.addGlobalPageSubs($scope.connection.subs);
    };
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getComputedOrderBookSubsObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        if ($scope.connection.connected) {
            $scope.reconnectAll($stateParams.Symbol.toUpperCase());
        } else {
            $scope.connection.subs = subscriptionManager.getComputedOrderBookSubsBySymbol($stateParams.Symbol.toUpperCase());
            $scope.exchanges = $scope.generateMarketsFromSubs($scope.connection.subs);
        }
    } else {
        $scope.connection.subs = subscriptionManager.getComputedOrderBookSubs();
        $scope.exchanges = $scope.generateMarketsFromSubs($scope.connection.subs);
        if ($scope.connection.connected) {
            streamerUtilities.addGlobalPageSubs($scope.connection.subs);
        }
    }
    $scope.disconnectAll = function(changingView) {
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        $scope.connection = streamerUtilities.initConnection();
        $scope.progressBar = streamerUtilities.initProgressBar();
        if (changingView) {
            $scope.changeCurrency();
            $scope.changeView();
            $scope.socketConnected();
            $scope.orderBookMessage();
            $scope.fullBookMessage();
        }
    };
    $scope.selectAllStreamingMarkets = function() {
        var someExchangesNotStreaming = false;
        var tempSubs = [];
        for (var i = 0, length = $scope.markets.length; i < length; i++) {
            if (!$scope.markets[i].IsStreaming) {
                $scope.markets[i].IsStreaming = true;
                someExchangesNotStreaming = true;
            }
            tempSubs.push($scope.markets[i].SubKey);
        };
        if (someExchangesNotStreaming) {
            $scope.connection.subs = tempSubs;
            streamerUtilities.addGlobalPageSubs($scope.connection.subs);
        }
    };
    $scope.deselectAllStreamingMarkets = function() {
        var someExchangesStreaming = false;
        for (var i = 0, length = $scope.markets.length; i < length; i++) {
            if ($scope.markets[i].IsStreaming) {
                $scope.markets[i].IsStreaming = false;
                someExchangesStreaming = true;
            }
        };
        if (someExchangesStreaming) {
            streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
            $scope.connection.orderBookData = {};
            $scope.connection.subs = [];
        }
    };
    $scope.changeMarketStreamingStatus = function(id) {
        $scope.markets[id].IsStreaming = !$scope.markets[id].IsStreaming;
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        var tempSubs = [];
        for (var i = 0, length = $scope.markets.length; i < length; i++) {
            if ($scope.markets[i].IsStreaming) {
                tempSubs.push($scope.markets[i].SubKey);
            }
        };
        if (!$scope.markets[id].IsStreaming) {
            $scope.connection.orderBookData = {};
        }
        $scope.connection.subs = tempSubs;
        streamerUtilities.addGlobalPageSubs($scope.connection.subs);
    };
    $scope.changeCurrency = $rootScope.$on('ChangeCurrency', function(event, symbol) {
        $scope.disconnectAll(false);
        $scope.reconnectAll(symbol);
        $scope.toSymbol = symbol;
        $scope.toSymbolDisplay = CCC.STATIC.CURRENCY.getSymbol($scope.toSymbol);
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.disconnectAll(true);
    });
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        $scope.connection.connected = true;
        $scope.progressBar.current++;
        $scope.progressBar.message = 'Loading data...';
        streamerUtilities.addGlobalPageSubs($scope.connection.subs);
    });
    $scope.parseMessage = function(messageInfo) {
        if ($scope.connection.subs.indexOf(messageInfo.SubKey) > -1) {
            if (messageInfo.SubKey != messageInfo.Raw) {
                var orderBookKey = messageInfo.OrderBookKey;
                if ($scope.connection.orderbook.isLoading(orderBookKey)) {
                    $scope.connection.orderbook.queueOrderSequenceMissmatch(orderBookKey, messageInfo.Obj);
                } else {
                    $scope.connection.orderbook.handleOrder(messageInfo.Obj);
                }
            }
        }
    };
    $scope.processQueueOfOrders = function(orderBookKey) {
        var lengthOfQueue = $scope.connection.orderbook.getQueueSequanceMissmatchLength(orderBookKey);
        if (lengthOfQueue > 0) {
            for (var i = 0; i < lengthOfQueue; i++) {
                var currentQueueItem = $scope.connection.orderbook.getQueueItemSequenceMissmatch(orderBookKey);
                if (currentQueueItem != null) {
                    $scope.connection.orderbook.handleOrder(currentQueueItem);
                }
            }
        }
    }
    $scope.orderBookMessage = $rootScope.$on('OrderBookMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
    $scope.fullBookMessage = $rootScope.$on('FullOrderBookMessage', function(event, messageInfo) {
        if ($scope.connection.subs.indexOf(messageInfo.SubKey) > -1) {
            $scope.connection.loadingData = false;
            $scope.connection.orderbook.unpack(messageInfo.Raw);
            $scope.processQueueOfOrders(messageInfo.OrderBookKey);
            $scope.generateChart();
            $scope.calculatePrice();
            $scope.startIntervalGenerateChart();
        }
    });
    $scope.getTotalBidSizeQuantity = function() {
        if ($scope.currentObKey == "") {
            return "";
        }
        return $scope.connection.orderbook.getTotalSizeQuantity($scope.currentObKey, CCC.ORDER.SIDE.BID);
    }
    $scope.getTotalBidSizeValue = function() {
        if ($scope.currentObKey == "") {
            return "";
        }
        return $scope.connection.orderbook.getTotalSizeValue($scope.currentObKey, CCC.ORDER.SIDE.BID);
    }
    $scope.getTotalAskSizeQuantity = function() {
        if ($scope.currentObKey == "") {
            return "";
        }
        return $scope.connection.orderbook.getTotalSizeQuantity($scope.currentObKey, CCC.ORDER.SIDE.ASK);
    }
    $scope.getTotalAskSizeValue = function() {
        if ($scope.currentObKey == "") {
            return "";
        }
        return $scope.connection.orderbook.getTotalSizeValue($scope.currentObKey, CCC.ORDER.SIDE.ASK);
    }
    $scope.getTopBidOrders = function() {
        if ($scope.currentObKey == "") {
            return "";
        }
        return $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.BID);
    };
    $scope.getTopAskOrders = function() {
        if ($scope.currentObKey == "") {
            return "";
        }
        return $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.ASK);
    };
    $scope.generateChartDataProvider = function() {
        var bid = $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.BID);
        var ask = $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.ASK);
        var tempBidData = [];
        var sumBid = 0;
        var sumTotalBid = 0;
        var maxLength = 500;
        var topBid = 0;
        var topAsk = 0;
        var worstBid = 0;
        var worstAsk = 0;
        var lengthBid = Math.min(maxLength, bid.length);
        if (lengthBid > 0) {
            topBid = bid[0].P;
            worstBid = bid[lengthBid - 1].P;
        }
        var lengthAsk = Math.min(maxLength, ask.length);
        if (lengthAsk > 0) {
            topAsk = ask[0].P;
            worstAsk = ask[lengthAsk - 1].P;
        }
        var mid = (topAsk - topBid) / 2 + topBid;
        var range = Math.min(mid - worstBid, worstAsk - mid);
        var stepFrequency = 50;
        var step = (topBid - range) / stepFrequency;
        var lastIndex = 0;
        var currentBucket = {
            price: 0,
            vol: 0,
            currentvol: 0,
            total: 0
        };
        for (var i = 0; i < stepFrequency; ++i) {
            currentBucket.price = topBid - i * step;
            currentBucket.currentvol = 0;
            var start = lastIndex;
            for (var j = start; j < bid.length; ++j) {
                var currentBid = bid[j];
                var priceLimit = currentBucket.price - step;
                if (currentBid.P > priceLimit) {
                    currentBucket.vol += currentBid.Q;
                    currentBucket.currentvol += currentBid.Q;
                    currentBucket.total += currentBid.Q * currentBid.P;
                } else {
                    lastIndex = j;
                    break;
                }
            }
            tempBidData.push({
                price: chartUtil.convertValueForChart(currentBucket.price),
                bid: chartUtil.convertValueForChart(currentBucket.vol),
                currentbid: chartUtil.convertValueForChart(currentBucket.currentvol),
                avg: chartUtil.convertValueForChart(currentBucket.total / currentBucket.vol)
            });
        }
        tempBidData.reverse();
        var dataProvider = [];
        for (var i = 0; i < tempBidData.length; ++i) {
            dataProvider.push(tempBidData[i]);
        }
        var step = (topAsk + range) / stepFrequency;
        var lastIndex = 0;
        var currentBucket = {
            price: 0,
            vol: 0,
            currentvol: 0,
            total: 0
        };
        for (var i = 0; i < stepFrequency; ++i) {
            currentBucket.price = topAsk + i * step;
            currentBucket.currentvol = 0;
            var start = lastIndex;
            for (var j = start; j < ask.length; ++j) {
                var currentAsk = ask[j];
                var priceLimit = currentBucket.price + step;
                if (currentAsk.P < priceLimit) {
                    currentBucket.vol += currentAsk.Q;
                    currentBucket.currentvol += currentAsk.Q;
                    currentBucket.total += currentAsk.Q * currentAsk.P;
                } else {
                    lastIndex = j;
                    break;
                }
            }
            dataProvider.push({
                price: chartUtil.convertValueForChart(currentBucket.price),
                ask: chartUtil.convertValueForChart(currentBucket.vol),
                currentask: chartUtil.convertValueForChart(currentBucket.currentvol),
                avg: chartUtil.convertValueForChart(currentBucket.total / currentBucket.vol)
            });
        }
        $scope.marketDepthStats = {
            RAW: {
                bid: 0,
                ask: 0,
                worstBid: 0,
                worstAsk: 0,
                mid: 0,
                spread: 0
            },
            DISPLAY: {
                bid: 0,
                ask: 0,
                worstBid: 0,
                worstAsk: 0,
                mid: 0,
                spread: 0
            }
        };
        $scope.marketDepthStats.RAW.bid = topBid;
        $scope.marketDepthStats.RAW.ask = topAsk;
        $scope.marketDepthStats.RAW.mid = (topAsk - topBid) / 2 + topBid;
        $scope.marketDepthStats.RAW.worstBid = worstBid;
        $scope.marketDepthStats.RAW.worstAsk = worstAsk;
        $scope.marketDepthStats.RAW.spread = topAsk - topBid;
        $scope.marketDepthStats.DISPLAY.bid = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, topBid);
        $scope.marketDepthStats.DISPLAY.ask = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, topAsk);
        $scope.marketDepthStats.DISPLAY.mid = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, (topAsk - topBid) / 2 + topBid);
        $scope.marketDepthStats.DISPLAY.worstBid = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, worstBid);
        $scope.marketDepthStats.DISPLAY.worstAsk = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, worstAsk);
        $scope.marketDepthStats.DISPLAY.spread = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, topAsk - topBid);
        $scope.lastIndex = dataProvider.length - 1;
        var currentZoomLevel = $scope.chartZoomLevels[$scope.currentZoomIndex];
        $scope.startIndex = Math.floor(currentZoomLevel.startFactor * $scope.lastIndex);
        $scope.endIndex = Math.floor(currentZoomLevel.endFactor * $scope.lastIndex);
        return dataProvider;
    };
    $scope.calculatorCurrencies = [$scope.toSymbol, $scope.fromSymbol];
    $scope.orderTypes = [{
        name: "BUY",
        orderbookSide: "ask"
    }, {
        name: "SELL",
        orderbookSide: "bid"
    }];
    $scope.priceCalculator = {
        order: {
            name: "BUY",
            orderbookSide: "ask"
        },
        amount: 10,
        currency: $scope.fromSymbol,
        exchange: "Poloniex",
        avgPrice: 0,
        midPrice: 0,
        impact: 0,
        impactPercent: 0,
        totalFrom: 0,
        totalTo: 0
    };
    $scope.calculatePrice = function() {
        var targetAmount = $scope.priceCalculator.amount;
        if (targetAmount <= 0) {
            $scope.priceCalculator.avgPrice = 0;
            $scope.priceCalculator.totalFrom = 0;
            $scope.priceCalculator.totalTo = 0;
            $scope.priceCalculator.midPrice = 0;
            $scope.priceCalculator.impact = 0;
            $scope.priceCalculator.impactPercent = 0;
            $scope.priceCalculator.avgPriceDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, $scope.priceCalculator.avgPrice);
            $scope.priceCalculator.totalFromDisplay = chartUtil.convertValueToDisplay($scope.fromSymbolDisplay, $scope.priceCalculator.totalFrom);
            $scope.priceCalculator.totalToDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, $scope.priceCalculator.totalTo);
            $scope.priceCalculator.midPriceDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, $scope.priceCalculator.midPrice);
            $scope.priceCalculator.impactDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, $scope.priceCalculator.impact);
            $scope.priceCalculator.impactPercentDisplay = chartUtil.convertValueToDisplay("", $scope.priceCalculator.impactPercent) + '%';
            return;
        }
        var orders = [];
        if ($scope.priceCalculator.order.orderbookSide === "ask") {
            orders = $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.ASK);
            var bid = $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.BID);
            if (orders.length < 1) {
                return;
            }
            $scope.priceCalculator.midPrice = (orders[0].P - bid[0].P) / 2 + bid[0].P;
        } else if ($scope.priceCalculator.order.orderbookSide === "bid") {
            orders = $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.BID);
            var ask = $scope.connection.orderbook.getTopOrders($scope.currentObKey, CCC.ORDER.SIDE.ASK);
            $scope.priceCalculator.midPrice = (ask[0].P - orders[0].P) / 2 + ask[0].P;
            if (orders.length < 1) {
                return;
            }
        } else {
            return;
        }
        var isToSymbol = ($scope.priceCalculator.currency === $scope.toSymbol) ? true : false;
        var sum = {
            toVolume: 0,
            fromVolume: 0
        };
        for (var i = 0; i < orders.length; ++i) {
            var currentOrder = orders[i];
            var volToCompare = isToSymbol ? (currentOrder.Q * currentOrder.P) : currentOrder.Q;
            var currentVol = isToSymbol ? sum.toVolume : sum.fromVolume;
            if ((currentVol + volToCompare) > targetAmount) {
                var diff = targetAmount - currentVol;
                sum.fromVolume += isToSymbol ? (diff / currentOrder.P) : diff;
                sum.toVolume += isToSymbol ? diff : diff * currentOrder.P;
                $scope.priceCalculator.impact = currentOrder.P - $scope.priceCalculator.midPrice;
                $scope.priceCalculator.impactPercent = (currentOrder.P - $scope.priceCalculator.midPrice) / $scope.priceCalculator.midPrice * 100;
                break;
            } else {
                sum.fromVolume += currentOrder.Q;
                sum.toVolume += currentOrder.Q * currentOrder.P;
            }
        }
        $scope.priceCalculator.avgPrice = sum.toVolume / sum.fromVolume;
        $scope.priceCalculator.totalFrom = sum.fromVolume;
        $scope.priceCalculator.totalTo = $scope.toSymbolDisplay, sum.toVolume;
        $scope.priceCalculator.avgPriceDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, sum.toVolume / sum.fromVolume);
        $scope.priceCalculator.totalFromDisplay = chartUtil.convertValueToDisplay($scope.fromSymbolDisplay, sum.fromVolume);
        $scope.priceCalculator.totalToDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, sum.toVolume);
        $scope.priceCalculator.midPriceDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, $scope.priceCalculator.midPrice);
        $scope.priceCalculator.impactDisplay = chartUtil.convertValueToDisplay($scope.toSymbolDisplay, $scope.priceCalculator.impact);
        $scope.priceCalculator.impactPercentDisplay = chartUtil.convertValueToDisplay("", $scope.priceCalculator.impactPercent) + '%';
    };
    $scope.generateChart = function() {
        var green = CCC.STATIC.UTIL.chartColors.Green.Hex;
        var blue = CCC.STATIC.UTIL.chartColors.DarkBlue.Hex;
        var red = CCC.STATIC.UTIL.chartColors.LighRed.Hex;
        $scope.chartMarketDepth = {};
        $scope.chartIsLoading = true;
        var dataProvider = $scope.generateChartDataProvider();
        endIndex = dataProvider.length - 1;
        $scope.chartMarketDepth = AmCharts.makeChart("market-depth-chart", {
            type: "serial",
            marginTop: 40,
            marginBottom: 50,
            pathToImages: "/images/",
            dataProvider: dataProvider,
            categoryField: "price",
            zoomOutText: "",
            balloon: {
                adjustBorderColor: false,
                horizontalPadding: 10,
                verticalPadding: 8,
                color: "#ffffff",
                borderThickness: 2,
                enabled: true
            },
            title: "Order book",
            percentHeight: 70,
            valueAxes: [{
                id: "y1",
                axisAlpha: 0,
                position: "left",
                gridAlpha: 0
            }, {
                id: "y2",
                axisAlpha: 0,
                position: "right",
                gridAlpha: 0
            }],
            graphs: [{
                id: "g1",
                valueAxis: "y1",
                balloonText: "Bid: " + $scope.toSymbolDisplay + "[[category]]<br>Volume (" + $scope.fromSymbol + "): [[currentbid]]<br>Total Volume (" + $scope.fromSymbol + "): [[value]]<br><b><span style='font-size:14px;'>Average Price: " + $scope.toSymbolDisplay + "[[avg]]</span></b>",
                lineColor: green,
                lineThickness: 2,
                valueField: "bid",
                fillAlphas: 0.1,
                type: "step"
            }, {
                id: "g2",
                valueAxis: "y1",
                balloonText: "Ask: " + $scope.toSymbolDisplay + "[[category]]<br>Volume (" + $scope.fromSymbol + "): [[currentask]]<br>Total Volume (" + $scope.fromSymbol + "): [[value]]<br><b><span style='font-size:14px;'>Average Price: " + $scope.toSymbolDisplay + "[[avg]]</span></b>",
                lineColor: red,
                lineThickness: 2,
                valueField: "ask",
                fillAlphas: 0.1,
                type: "step"
            }, {
                id: "g3",
                valueAxis: "y2",
                showBalloon: false,
                color: "#d1d3dc",
                lineColor: "#d1d3dc",
                columnWidth: 1,
                columnSpacing: 0,
                valueField: "currentbid",
                fillAlphas: 0.5,
                lineAlpha: 0.5,
                type: "column"
            }, {
                id: "g4",
                valueAxis: "y2",
                showBalloon: false,
                color: "#d1d3dc",
                lineColor: "#d1d3dc",
                columnWidth: 1,
                columnSpacing: 0,
                valueField: "currentask",
                fillAlphas: 0.5,
                lineAlpha: 0.5,
                type: "column"
            }],
            categoryAxis: {
                axisAlpha: 1,
                gridAlpha: 0,
                autoGridCount: false,
                gridCount: 5
            },
            export: {
                enabled: false
            },
            chartCursor: {
                balloonPointerOrientation: "top",
                cursorAlpha: 1,
                valueLineAlpha: 1,
                categoryBalloonEnabled: true,
                zoomable: false,
            },
            listeners: [{
                event: "rendered",
                method: function(e) {
                    $scope.chartIsLoading = false;
                }
            }, {
                event: "dataUpdated",
                method: function(e) {
                    if ($scope.chartMarketDepth.hasOwnProperty('dataProvider')) {
                        if ($scope.chartMarketDepth.dataProvider.length > 0) {
                            $scope.chartMarketDepth.zoomToIndexes($scope.startIndex, $scope.endIndex);
                        }
                    }
                }
            }]
        });
    };
    $scope.updateChart = function() {
        if (Object.keys($scope.chartMarketDepth).length == 0) {
            generateChart();
        } else {
            var dataProvider = $scope.generateChartDataProvider();
            var length = dataProvider.length;
            if (length < 1) {
                return;
            }
            $scope.chartMarketDepth.dataProvider = dataProvider;
            $scope.chartMarketDepth.validateData();
        }
        $scope.calculatePrice();
    };
    $scope.promise;
    $scope.startIntervalGenerateChart = function() {
        $scope.stopIntervalGenerateChart();
        $scope.promise = $interval($scope.updateChart, 5000);
    };
    $scope.stopIntervalGenerateChart = function() {
        $interval.cancel($scope.promise);
    };
    $scope.switchCurrency = function() {
        if ($scope.priceCalculator.currency === $scope.toSymbol) {
            $scope.priceCalculator.currency = $scope.fromSymbol;
        } else {
            $scope.priceCalculator.currency = $scope.toSymbol
        }
    };
    $scope.chooseOrderType = function(type) {
        if (type === "BUY") {
            $scope.priceCalculator.order = {
                name: "BUY",
                orderbookSide: "ask"
            };
        } else if (type === "SELL") {
            $scope.priceCalculator.order = {
                name: "SELL",
                orderbookSide: "bid"
            };
        } else {
            return;
        }
    };
    $scope.chartZoomLevels = [{
        startFactor: 0,
        endFactor: 1
    }, {
        startFactor: 0.25,
        endFactor: 0.75
    }, {
        startFactor: 0.35,
        endFactor: 0.65
    }, {
        startFactor: 0.45,
        endFactor: 0.55
    }];
    $scope.currentZoomIndex = 0;
    $scope.zoomIn = function() {
        $scope.currentZoomIndex = Math.min($scope.chartZoomLevels.length - 1, $scope.currentZoomIndex + 1);
        $scope.zoomToCurrentLevel();
    }
    $scope.zoomOut = function() {
        $scope.currentZoomIndex = Math.max(0, $scope.currentZoomIndex - 1);
        $scope.zoomToCurrentLevel();
    }
    $scope.zoomToCurrentLevel = function() {
        var currentZoomLevel = $scope.chartZoomLevels[$scope.currentZoomIndex];
        $scope.startIndex = Math.floor(currentZoomLevel.startFactor * $scope.lastIndex);
        $scope.endIndex = Math.floor(currentZoomLevel.endFactor * $scope.lastIndex);
        $scope.chartMarketDepth.zoomToIndexes($scope.startIndex, $scope.endIndex);
    }
}]);
angular.module('ccc-app').controller('StreamingCurrentSubsCtrl', ['$rootScope', '$scope', '$timeout', '$stateParams', '$filter', 'subscriptionManager', 'streamerUtilities', 'dateParsing', 'pageInfo', function($rootScope, $scope, $timeout, $stateParams, $filter, subscriptionManager, streamerUtilities, dateParsing, pageInfo) {
    $scope.dateParsing = dateParsing;
    $scope.hasValidData = false;
    $scope.showOldData = false;
    $scope.secondsForInvlidData = 7 * 24 * 60 * 60;
    $scope.pageInfo = pageInfo;
    $scope.toCurrency = "";
    $scope.currentLimit = $scope.limit || 0;
    $scope.leftToShow = 0;
    $scope.connection = streamerUtilities.initConnection();
    $scope.progressBar = streamerUtilities.initProgressBar();
    $scope.ordering = streamerUtilities.initOrdering();
    $scope.isStreaming = streamerUtilities.getStreamingStatus();
    $scope.showAllCurrencies = function() {
        $scope.currentLimit = 0;
        $scope.recalculateLimit();
    }
    $scope.recalculateLimit = function() {
        if ($scope.currentLimit > 0 && $scope.connection.subs.length > $scope.currentLimit) {
            $scope.leftToShow = $scope.connection.subs.length - $scope.currentLimit - 1;
        } else {
            $scope.leftToShow = 0;
        }
    }
    $scope.parseMessage = function(messageInfo) {
        var subKey = messageInfo.SubKey;
        if ($scope.connection.subs.indexOf(subKey) > -1) {
            if (subKey == messageInfo.Raw) {
                $scope.progressBar.current++;
                if ($scope.progressBar.current == $scope.progressBar.max) {
                    $scope.connection.loadingData = false;
                    if (!$scope.hasValidData) {
                        $scope.showOldData = true;
                    }
                }
            } else {
                var messageObject = messageInfo.Obj;
                var arrayKey = 0;
                if (!$scope.hasValidData && messageObject.LASTUPDATE > dateParsing.unixTimestamp($scope.secondsForInvlidData)) {
                    $scope.hasValidData = true;
                }
                if ($scope.connection.keyToPosition[subKey] != 0) {
                    arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                }
                $scope.connection.data[arrayKey] = streamerUtilities.decorateCurrent($scope.connection.data[arrayKey], messageInfo);
                $scope.connection.totalvolume24hour = $scope.connection.data.reduce(function(a, b) {
                    return {
                        DATA: {
                            VOLUME24HOUR: a.DATA.VOLUME24HOUR + b.DATA.VOLUME24HOUR
                        }
                    };
                }).DATA.VOLUME24HOUR;
                $scope.connection.totalvolume24hourdisplay = CCC.STATIC.UTIL.convertValueToDisplay($scope.connection.data[arrayKey].DISPLAY.FROMSYMBOL, $scope.connection.totalvolume24hour, $filter('number'));
                $scope.connection.totalvolume24hourto = $scope.connection.data.reduce(function(a, b) {
                    return {
                        DATA: {
                            VOLUME24HOURTO: a.DATA.VOLUME24HOURTO + b.DATA.VOLUME24HOURTO
                        }
                    };
                }).DATA.VOLUME24HOURTO;
                $scope.connection.totalvolume24hourtodisplay = CCC.STATIC.UTIL.convertValueToDisplay($scope.connection.data[arrayKey].DISPLAY.TOSYMBOL, $scope.connection.totalvolume24hourto, $filter('number'));
                if ($scope.connection.loadingData) {
                    $scope.connection.keyToPosition[subKey] = arrayKey;
                    $scope.connection.data[arrayKey]['VISUAL'] = {};
                    $scope.progressBar.current++;
                    $scope.progressBar.message = messageObject.MARKET + ':' + messageObject.FROMSYMBOL + '/' + messageObject.TOSYMBOL;
                    if ($scope.progressBar.current >= $scope.progressBar.max) {
                        $scope.connection.loadingData = false;
                        if (!$scope.hasValidData) {
                            $scope.showOldData = true;
                        }
                        if ($scope.connection.data.length > 1) {
                            $scope.sortKeys("VOLUME24HOURTO");
                        }
                    }
                } else {
                    $scope.connection.data[arrayKey].timeout = $timeout(function() {
                        $scope.handleTimeout(subKey);
                    }, 1500, false);
                    if ($scope.isSortRequired(arrayKey)) {
                        $scope.sortAndSaveOrder();
                    }
                }
            }
        }
    };
    $scope.reconnectAll = function(symbol) {
        $scope.connection.subs = subscriptionManager.getCurrentSubsByToSymbol(symbol);
        $scope.progressBar.max = $scope.connection.subs.length + 2;
        $scope.recalculateLimit();
        streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    };
    $scope.toggleOldData = function() {
        if ($scope.showOldData) {
            $scope.showOldData = false;
        } else {
            $scope.showOldData = true;
        }
    };
    $scope.stopStratStreaming = function() {
        if (streamerUtilities.getStreamingStatus()) {
            streamerUtilities.stopStreaming();
        } else {
            streamerUtilities.startStreaming();
        }
        $scope.isStreaming = streamerUtilities.getStreamingStatus();
    };
    $scope.disconnectAll = function(changingView) {
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        if (changingView) {
            $scope.changeCurrency();
            $scope.changeView();
            $scope.socketConnected();
            $scope.currentMessage();
        } else {
            $scope.connection = streamerUtilities.initConnection();
            $scope.progressBar = streamerUtilities.initProgressBar();
            $scope.ordering = streamerUtilities.initOrdering();
        }
    };
    $scope.changeCurrency = $rootScope.$on('ChangeCurrency', function(event, symbol) {
        $scope.currentLimit = $scope.limit || 0;
        $scope.disconnectAll(false);
        $scope.reconnectAll(symbol);
        $scope.toCurrency = symbol;
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.disconnectAll(true);
        $scope.currentLimit = $scope.limit || 0;
    });
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        $scope.connection.connected = true;
        if (!$scope.connection.monitorPreLoaded) {
            $scope.progressBar.current++;
            $scope.progressBar.message = 'Loading data...';
            $scope.recalculateLimit();
            streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                $scope.parseMessage(messageInfo);
            });
        }
    });
    $scope.currentMessage = $rootScope.$on('CurrentMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
    $scope.subAdd = function(sub) {
        if ($scope.connection.subs.indexOf(sub) > -1)
            return;
        $scope.connection.subs.unshift(sub);
        streamerUtilities.addGlobalPageSubs([sub], function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    };
    $scope.subRemove = function(sub) {
        var index = $scope.connection.subs.indexOf(sub);
        if (index > -1) {
            streamerUtilities.removeGlobalPageSubs([sub]);
            $scope.connection.subs.splice(index, 1);
            $scope.connection.data.splice($scope.connection.keyToPosition[sub], 1);
            delete $scope.connection.keyToPosition[sub];
        }
    };
    $scope.handleTimeout = function(subKey) {
        var arrayKeyToTimeout = $scope.connection.keyToPosition[subKey];
        if (arrayKeyToTimeout || arrayKeyToTimeout == 0) {
            var visual = $scope.connection.data[arrayKeyToTimeout]['VISUAL'];
            var dateNow = new Date();
            for (var property in visual) {
                if (visual[property] != false && dateNow >= visual[property]) {
                    visual[property] = false;
                }
            }
            $scope.connection.data[arrayKeyToTimeout]['VISUAL'] = visual;
        }
    };
    $scope.isSortRequired = function(arrayKey) {
        var arrayData = $scope.connection.data;
        var arrayDataLength = arrayData.length;
        var isAscendingLocal = $scope.ordering.isAscending;
        var sortingFieldLocal = $scope.ordering.sortingField;
        if (arrayKey != 0) {
            if (isAscendingLocal) {
                if (arrayData[arrayKey - 1].DATA[sortingFieldLocal] > arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            } else {
                if (arrayData[arrayKey - 1].DATA[sortingFieldLocal] < arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            }
        }
        if (arrayKey != arrayDataLength - 1) {
            if (isAscendingLocal) {
                if (arrayData[arrayKey + 1].DATA[sortingFieldLocal] < arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            } else {
                if (arrayData[arrayKey + 1].DATA[sortingFieldLocal] > arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            }
        }
        return false;
    };
    $scope.sortKeys = function(sortingField) {
        if ($scope.ordering.sortingField == sortingField) {
            if ($scope.ordering.isAscending) {
                $scope.ordering.isAscending = false;
            } else {
                $scope.ordering.isAscending = true;
            }
        } else {
            $scope.ordering.sortingField = sortingField;
        }
        $scope.sortAndSaveOrder();
    };
    $scope.sortAndSaveOrder = function() {
        var sortingFieldLocal = $scope.ordering.sortingField;
        var arrayData = $scope.connection.data;
        var arrayDataLength = arrayData.length;
        if (arrayDataLength < 2) {
            return false;
        }
        if ($scope.ordering.isAscending) {
            arrayData.sort(function(a, b) {
                if (a.DATA[sortingFieldLocal] > b.DATA[sortingFieldLocal]) {
                    return 1;
                }
                if (a.DATA[sortingFieldLocal] < b.DATA[sortingFieldLocal]) {
                    return -1;
                }
                if (a.DATA['LASTUPDATE'] > b.DATA['LASTUPDATE']) {
                    return 1;
                }
                if (a.DATA['LASTUPDATE'] < b.DATA['LASTUPDATE']) {
                    return -1;
                }
                return 0;
            });
        } else {
            arrayData.sort(function(a, b) {
                if (a.DATA[sortingFieldLocal] > b.DATA[sortingFieldLocal]) {
                    return -1;
                }
                if (a.DATA[sortingFieldLocal] < b.DATA[sortingFieldLocal]) {
                    return 1;
                }
                if (a.DATA['LASTUPDATE'] > b.DATA['LASTUPDATE']) {
                    return -1;
                }
                if (a.DATA['LASTUPDATE'] < b.DATA['LASTUPDATE']) {
                    return 1;
                }
                return 0;
            });
        }
        $scope.connection.keyToPosition = {};
        for (var i = 0; i < arrayData.length; i++) {
            $scope.connection.keyToPosition[arrayData[i].SUBKEY] = i;
        };
    };
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getCurrentSubsObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        $scope.toCurrency = $stateParams.Symbol.toUpperCase();
        if ($scope.connection.connected) {
            $scope.reconnectAll($stateParams.Symbol.toUpperCase());
        } else {
            $scope.connection.subs = subscriptionManager.getCurrentSubsByToSymbol($stateParams.Symbol.toUpperCase());
            $scope.progressBar.max = $scope.connection.subs.length + 2;
            if ($scope.connection.monitorPreLoaded) {
                $scope.progressBar.current++;
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
                $scope.recalculateLimit();
            }
        }
    } else {
        $scope.connection.subs = subscriptionManager.getTopCurrentSubs();
        $scope.toCurrency = subscriptionManager.getCurrentToSymbol();
        $scope.progressBar.max = $scope.connection.subs.length + 2;
        if ($scope.connection.connected || $scope.connection.monitorPreLoaded) {
            $scope.progressBar.current++;
            streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                $scope.parseMessage(messageInfo);
            });
            $scope.recalculateLimit();
        }
    }
}]);
angular.module('ccc-app').controller('StreamingAGGSubsCtrl', ['$rootScope', '$scope', '$timeout', '$stateParams', '$filter', 'pageInfo', 'subscriptionManager', 'streamerUtilities', function($rootScope, $scope, $timeout, $stateParams, $filter, pageInfo, subscriptionManager, streamerUtilities) {
    $scope.connection = streamerUtilities.initConnection();
    $scope.progressBar = streamerUtilities.initProgressBar();
    $scope.ordering = streamerUtilities.initOrdering();
    $scope.isStreaming = streamerUtilities.getStreamingStatus();
    $scope.currentAGGSubsObj = subscriptionManager.getCurrentAGGSubsObj();
    $scope.toSymbol = subscriptionManager.getCurrentToSymbol();
    $scope.fromSymbol = pageInfo.getSymbol();
    $scope.fullPageTitle = pageInfo.getH1Text();
    $scope.tempSubs = [];
    for (var i in $scope.currentAGGSubsObj) {
        $scope.tempSubs.push($scope.currentAGGSubsObj[i]);
    };
    $scope.parseMessage = function(messageInfo) {
        var subKey = messageInfo.SubKey;
        if ($scope.connection.subs.indexOf(subKey) > -1) {
            if (subKey == messageInfo.Raw) {
                $scope.progressBar.current++;
                if ($scope.progressBar.current == $scope.progressBar.max) {
                    $scope.connection.loadingData = false;
                }
            } else {
                var messageObject = messageInfo.Obj;
                var arrayKey = 0;
                if ($scope.connection.keyToPosition[subKey] != 0) {
                    arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                }
                $scope.connection.data[arrayKey] = streamerUtilities.decorateCurrent($scope.connection.data[arrayKey], messageInfo);
                $scope.connection.totalvolume24hour = $scope.connection.data.reduce(function(a, b) {
                    return {
                        DATA: {
                            VOLUME24HOUR: a.DATA.VOLUME24HOUR + b.DATA.VOLUME24HOUR
                        }
                    };
                }).DATA.VOLUME24HOUR;
                $scope.connection.totalvolume24hourdisplay = CCC.STATIC.UTIL.convertValueToDisplay($scope.connection.data[arrayKey].DISPLAY.FROMSYMBOL, $scope.connection.totalvolume24hour, $filter('number'));
                if ($scope.connection.loadingData) {
                    $scope.connection.keyToPosition[subKey] = arrayKey;
                    $scope.connection.data[arrayKey]['VISUAL'] = {};
                    $scope.progressBar.current++;
                    $scope.progressBar.message = messageObject.MARKET + ':' + messageObject.FROMSYMBOL + '/' + messageObject.TOSYMBOL;
                    if ($scope.progressBar.current >= $scope.progressBar.max) {
                        $scope.connection.loadingData = false;
                        if ($scope.connection.data.length > 1) {
                            $scope.sortKeys("VOLUME24HOUR");
                        }
                    }
                } else {
                    $scope.connection.data[arrayKey].timeout = $timeout(function() {
                        $scope.handleTimeout(subKey);
                    }, 1500, false);
                    if ($scope.isSortRequired(arrayKey)) {
                        $scope.sortAndSaveOrder();
                    }
                }
            }
        }
    };
    $scope.connectAll = function() {
        $scope.connection = streamerUtilities.initConnection();
        $scope.connection.subs = $scope.tempSubs;
        $scope.progressBar.max = $scope.connection.subs.length + 2;
        streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    };
    $scope.disconnectAll = function() {
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        $scope.socketConnected();
        $scope.currentAggMessage();
        $scope.changeCurrency();
        $scope.changeView();
    };
    $scope.changeCurrency = $rootScope.$on('ChangeCurrency', function(event, symbol) {
        if ($scope.toSymbol == symbol) {
            return;
        }
        $scope.toSymbol = symbol;
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.disconnectAll();
    });
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        if (!$scope.connection.aggPreLoaded) {
            $scope.progressBar.current++;
            $scope.connectAll();
        }
    });
    $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
    $scope.handleTimeout = function(subKey) {
        var arrayKeyToTimeout = $scope.connection.keyToPosition[subKey];
        if (arrayKeyToTimeout || arrayKeyToTimeout == 0) {
            var visual = $scope.connection.data[arrayKeyToTimeout]['VISUAL'];
            var dateNow = new Date();
            for (var property in visual) {
                if (visual[property] != false && dateNow >= visual[property]) {
                    visual[property] = false;
                }
            }
            $scope.connection.data[arrayKeyToTimeout]['VISUAL'] = visual;
        }
    };
    $scope.isSortRequired = function(arrayKey) {
        var arrayData = $scope.connection.data;
        var arrayDataLength = arrayData.length;
        var isAscendingLocal = $scope.ordering.isAscending;
        var sortingFieldLocal = $scope.ordering.sortingField;
        if (arrayKey != 0) {
            if (isAscendingLocal) {
                if (arrayData[arrayKey - 1].DATA[sortingFieldLocal] > arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            } else {
                if (arrayData[arrayKey - 1].DATA[sortingFieldLocal] < arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            }
        }
        if (arrayKey != arrayDataLength - 1) {
            if (isAscendingLocal) {
                if (arrayData[arrayKey + 1].DATA[sortingFieldLocal] < arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            } else {
                if (arrayData[arrayKey + 1].DATA[sortingFieldLocal] > arrayData[arrayKey].DATA[sortingFieldLocal]) {
                    return true;
                }
            }
        }
        return false;
    };
    $scope.sortKeys = function(sortingField) {
        if ($scope.ordering.sortingField == sortingField) {
            if ($scope.ordering.isAscending) {
                $scope.ordering.isAscending = false;
            } else {
                $scope.ordering.isAscending = true;
            }
        } else {
            $scope.ordering.sortingField = sortingField;
        }
        $scope.sortAndSaveOrder();
    };
    $scope.sortAndSaveOrder = function() {
        var sortingFieldLocal = $scope.ordering.sortingField;
        var arrayData = $scope.connection.data;
        var arrayDataLength = arrayData.length;
        if (arrayDataLength < 2) {
            return false;
        }
        if ($scope.ordering.isAscending) {
            arrayData.sort(function(a, b) {
                if (a.DATA[sortingFieldLocal] > b.DATA[sortingFieldLocal]) {
                    return 1;
                }
                if (a.DATA[sortingFieldLocal] < b.DATA[sortingFieldLocal]) {
                    return -1;
                }
                if (a.DATA['LASTUPDATE'] > b.DATA['LASTUPDATE']) {
                    return 1;
                }
                if (a.DATA['LASTUPDATE'] < b.DATA['LASTUPDATE']) {
                    return -1;
                }
                return 0;
            });
        } else {
            arrayData.sort(function(a, b) {
                if (a.DATA[sortingFieldLocal] > b.DATA[sortingFieldLocal]) {
                    return -1;
                }
                if (a.DATA[sortingFieldLocal] < b.DATA[sortingFieldLocal]) {
                    return 1;
                }
                if (a.DATA['LASTUPDATE'] > b.DATA['LASTUPDATE']) {
                    return -1;
                }
                if (a.DATA['LASTUPDATE'] < b.DATA['LASTUPDATE']) {
                    return 1;
                }
                return 0;
            });
        }
        $scope.connection.keyToPosition = {};
        for (var i = 0; i < arrayData.length; i++) {
            $scope.connection.keyToPosition[arrayData[i].SUBKEY] = i;
        };
    };
    if ($scope.connection.connected || $scope.connection.aggPreLoaded) {
        $scope.progressBar.current++;
        $scope.connectAll();
    }
}]);
angular.module('ccc-app').controller('CurrentAggPriceWidget', ['$rootScope', '$scope', '$timeout', '$stateParams', 'subscriptionManager', 'streamerUtilities', 'dateParsing', 'pageInfo', function($rootScope, $scope, $timeout, $stateParams, subscriptionManager, streamerUtilities, dateParsing, pageInfo) {
    $scope.dateParsing = dateParsing;
    $scope.fromSymbolDisplay = pageInfo.getH1Text();
    $scope.connection = streamerUtilities.initConnection();
    $scope.progressBar = streamerUtilities.initProgressBar();
    $scope.parseMessage = function(messageInfo) {
        var subKey = messageInfo.SubKey;
        if ($scope.connection.subs.indexOf(subKey) > -1) {
            if (subKey == messageInfo.Raw) {
                $scope.progressBar.current++;
                if ($scope.progressBar.current == $scope.progressBar.max) {
                    $scope.connection.loadingData = false;
                }
            } else {
                var messageObject = messageInfo.Obj;
                var arrayKey = 0;
                if ($scope.connection.keyToPosition[subKey] != 0) {
                    arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                }
                $scope.connection.data[arrayKey] = streamerUtilities.decorateCurrentWithMktCap($scope.connection.data[arrayKey], messageInfo, pageInfo.getCoinsMined());
                if ($scope.connection.loadingData) {
                    $scope.connection.keyToPosition[subKey] = arrayKey;
                    $scope.connection.data[arrayKey]['VISUAL'] = {};
                    $scope.progressBar.current++;
                    $scope.progressBar.message = messageObject.MARKET + ':' + messageObject.FROMSYMBOL + '/' + messageObject.TOSYMBOL;
                    if ($scope.progressBar.current >= $scope.progressBar.max) {
                        $scope.connection.loadingData = false;
                    }
                } else {
                    $scope.connection.data[arrayKey].timeout = $timeout(function() {
                        $scope.handleTimeout(subKey);
                    }, 1500, false);
                }
            }
        }
    }
    $scope.reconnectAll = function(symbol) {
        $scope.connection.subs = subscriptionManager.getCurrentAGGSubByToSymbol(symbol);
        $scope.progressBar.max = $scope.connection.subs.length + 2;
        streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    };
    $scope.disconnectAll = function(changingView) {
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        if (changingView) {
            $scope.changeCurrency();
            $scope.changeView();
            $scope.socketConnected();
            $scope.currentAggMessage();
        } else {
            $scope.connection = streamerUtilities.initConnection();
            $scope.progressBar = streamerUtilities.initProgressBar();
        }
    };
    $scope.changeCurrency = $rootScope.$on('ChangeCurrency', function(event, symbol) {
        $scope.disconnectAll(false);
        $scope.reconnectAll(symbol);
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.disconnectAll(true);
    });
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        $scope.connection.connected = true;
        if (!$scope.connection.aggPreLoaded) {
            $scope.progressBar.current++;
            $scope.progressBar.message = 'Loading data...';
            streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                $scope.parseMessage(messageInfo);
            });
        }
    });
    $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
    $scope.handleTimeout = function(subKey) {
        var arrayKeyToTimeout = $scope.connection.keyToPosition[subKey];
        if (arrayKeyToTimeout || arrayKeyToTimeout == 0) {
            var visual = $scope.connection.data[arrayKeyToTimeout]['VISUAL'];
            var dateNow = new Date();
            for (var property in visual) {
                if (visual[property] != false && dateNow >= visual[property]) {
                    visual[property] = false;
                }
            }
            $scope.connection.data[arrayKeyToTimeout]['VISUAL'] = visual;
        }
    };
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getCurrentAGGSubsObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        if ($scope.connection.connected) {
            $scope.reconnectAll($stateParams.Symbol.toUpperCase());
        } else {
            $scope.connection.subs = subscriptionManager.getCurrentAGGSubByToSymbol($stateParams.Symbol.toUpperCase());
            $scope.progressBar.max = $scope.connection.subs.length + 2;
            if ($scope.connection.aggPreLoaded) {
                $scope.progressBar.current++;
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            }
        }
    } else {
        $scope.connection.subs = subscriptionManager.getCurrentAGGSub();
        $scope.progressBar.max = $scope.connection.subs.length + 2;
        if ($scope.connection.connected || $scope.connection.aggPreLoaded) {
            $scope.progressBar.current++;
            streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                $scope.parseMessage(messageInfo);
            });
        }
    }
}]);
angular.module('ccc-app').controller('CoinProfileLookTop', ['$rootScope', '$scope', 'cModalService', 'pageInfo', 'subscriptionManager', '$state', '$stateParams', '$timeout', 'streamerUtilities', 'userManager', 'portfolioSummary', 'portfolioManager', 'portfolioModalService', 'toastNotifications', 'socialStats', 'dateParsing', function($rootScope, $scope, cModalService, pageInfo, subscriptionManager, $state, $stateParams, $timeout, streamerUtilities, userManager, portfolioSummary, portfolioManager, portfolioModalService, toastNotifications, socialStats, dateParsing) {
    $scope.pageInfo = pageInfo;
    $scope.totalCoinsForConversion = 1;
    $scope.dateParsing = dateParsing;
    $scope.userManager = userManager;
    $scope.portfolioSummary = portfolioSummary;
    $scope.changingFollowStatus = false;
    $scope.followingHover = false;
    $scope.fromSymbol = pageInfo.getSymbol() || pageInfo.getH1Text();
    $scope.showLoginScreen = function(timeoutMS) {
        if (!userManager.isLoggedIn()) {
            $timeout(function() {
                if (!userManager.isLoggedIn() && !userManager.isShowingLogin()) {
                    cModalService.showLoginModal('If you are enjoying our free ' + pageInfo.getH1Text() + ' streaming service please login or signup.');
                }
            }, timeoutMS);
        }
    };
    $scope.showLoginScreen(300000);
    $scope.initialVisibleCurrencyNumber = 5;
    $scope.currencyDisplay = [];
    $scope.currencySecondaryDisplay = [];
    $scope.currencyIsInSecondary = false;
    $scope.firstViewLoad = true;
    $scope.connection = streamerUtilities.initConnection();
    var currentAGGSubsObj = subscriptionManager.getCurrentAGGSubsObj();
    var currentSubsClasification = subscriptionManager.getCurrentSubsClassification();
    var tempKeyToPos = {};
    var tempSubs = [];
    for (var i = 0; i < currentSubsClasification.length; i++) {
        tempKeyToPos[currentAGGSubsObj[currentSubsClasification[i]]] = i;
        tempSubs[i] = currentAGGSubsObj[currentSubsClasification[i]];
        if (i < $scope.initialVisibleCurrencyNumber) {
            $scope.currencyDisplay.push({
                Symbol: currentSubsClasification[i],
                Sub: currentAGGSubsObj[currentSubsClasification[i]],
                DISPLAY: {
                    CHANGEPCT24HOUR: 0.00,
                    PRICE: "Loading..."
                },
                DATA: {
                    PRICE: 0
                }
            });
        } else {
            $scope.currencySecondaryDisplay.push({
                Symbol: currentSubsClasification[i],
                Sub: currentAGGSubsObj[currentSubsClasification[i]],
                DISPLAY: {
                    CHANGEPCT24HOUR: 0.00,
                    PRICE: "Loading..."
                },
                DATA: {
                    PRICE: 0
                }
            });
        }
    }
    if ($scope.currencyDisplay.length == 0) {
        $scope.currencyDisplay.push({
            Symbol: "BTC",
            Sub: [],
            DISPLAY: {
                CHANGEPCT24HOUR: "0.00",
                PRICE: "N/A"
            },
            DATA: {
                CHANGE24HOUR: 0,
                CHANGEPCT24HOUR: 0,
                PRICE: 0
            }
        });
    }
    $scope.selectedCurrency = $scope.currencyDisplay[0];
    $scope.connection.keyToPosition = tempKeyToPos;
    $scope.connection.subs = tempSubs;
    $scope.state = $state;
    $scope.secondLevelNav = pageInfo.getSecondLevelNav();
    $scope.totalSubs = 0;
    $scope.totalSecondarySubs = 0;
    $scope.generateClassForDropdown = function() {
        $scope.totalSubs = currentSubsClasification.length;
        $scope.totalSecondarySubs = $scope.currencySecondaryDisplay.length;
    };
    $scope.getTotalCurrentHoldingsValue = function() {
        return portfolioSummary.getTotalCurrentHoldingsValue($scope.selectedCurrency);
    };
    $scope.generateClassForDropdown();
    $rootScope.$on('$stateChangeSuccess', function(event) {
        if ($state.includes("post")) {
            if ($stateParams.hasOwnProperty("PostId") && $stateParams.PostId.substring(0, 2) == "p_") {
                pageInfo.setCurrentPostId($stateParams.PostId.replace("p_", ""));
            } else {
                $scope.changeView('forum');
                return;
            }
        }
        if ($stateParams.hasOwnProperty("Symbol")) {
            var currentPageSymbol = $stateParams.Symbol.toUpperCase();
            var foundSymbol = false;
            angular.forEach($scope.currencyDisplay, function(value, key) {
                if (value.Symbol == currentPageSymbol) {
                    foundSymbol = true;
                    $scope.selectedCurrency = value;
                }
            });
            if (!foundSymbol) {
                angular.forEach($scope.currencySecondaryDisplay, function(value, key) {
                    if (value.Symbol == currentPageSymbol) {
                        $scope.selectedCurrency = value;
                        $scope.currencyIsInSecondary = true;
                        foundSymbol = true;
                    }
                });
            }
            if ($scope.firstViewLoad) {
                $scope.firstViewLoad = false;
                if (!foundSymbol) {
                    $scope.changeCurrency(0, true);
                } else {
                    subscriptionManager.changeCurrency($scope.selectedCurrency.Symbol);
                }
            }
        } else {
            $scope.selectedCurrency = $scope.currencyDisplay[0];
        }
        var viewToTrack = $state.current.name.replace('.currency', '');
        var currentSection = $state.current.name.split('.')[0];
        if ($state.current.hasOwnProperty("seoTitle") && $state.current["seoTitle"] != "") {
            if ($state.current["seoTitle"] == "InitialTitle") {
                pageInfo.setInitialSEOTitle();
            } else {
                pageInfo.setBaseSEOTitle($state.current["seoTitle"]);
            }
        }
        if ($state.current.hasOwnProperty("seoDescription") && $state.current["seoDescription"] != "") {
            if ($state.current["seoDescription"] == "InitialDescription") {
                pageInfo.setInitialSEODescription();
            } else {
                pageInfo.setBaseSEODescription($state.current["seoDescription"]);
            }
        }
        pageInfo.setToSymbol($scope.selectedCurrency.Symbol);
        pageInfo.addToSymbolToSEOTitle();
        pageInfo.addToSymbolToSEODescription();
        pageInfo.setCurrentPageSection(currentSection);
        pageInfo.trackPage(pageInfo.getPageId(), "Coin_" + viewToTrack);
    });
    $scope.changeCurrency = function(id, isMain) {
        if (isMain) {
            $scope.selectedCurrency = $scope.currencyDisplay[id];
            $scope.currencyIsInSecondary = false;
        } else {
            $scope.currencyIsInSecondary = true;
            $scope.selectedCurrency = $scope.currencySecondaryDisplay[id];
        }
        var newState = $state.current.name;
        subscriptionManager.changeCurrency($scope.selectedCurrency.Symbol);
        if (newState != "") {
            var objectToSend = {
                Symbol: $scope.selectedCurrency.Symbol
            };
            if (!$state.includes("*.currency") && !$state.includes("*.*.currency")) {
                newState += ".currency";
            }
            $state.go(newState, objectToSend);
        }
    };
    $scope.isActive = function(viewName) {
        if (viewName == "forum" && $state.includes("post")) {
            return true;
        }
        return $state.includes(viewName);
    };
    $scope.getActiveName = function() {
        if ($state.includes("post")) {
            return "Forum";
        }
        for (var i = 0; i < $scope.secondLevelNav.length; i++) {
            if ($state.includes($scope.secondLevelNav[i].ViewName))
                return $scope.secondLevelNav[i].DisplayName;
        }
    };
    $rootScope.$on('ChangeToForumView', function(event) {
        $scope.changeView('forum');
    });
    $rootScope.$on('ChangeToChartsView', function(event) {
        $scope.changeView('charts');
    });
    $scope.changeView = function(viewName) {
        if ($state.includes(viewName))
            return;
        var viewChangeParams = {};
        viewChangeParams.ViewName = viewName;
        if ($scope.selectedCurrency) {
            viewChangeParams.Symbol = $scope.selectedCurrency.Symbol;
        }
        subscriptionManager.changeView(viewChangeParams);
        var newState = viewName + ".currency";
        if ($scope.selectedCurrency) {
            $state.go(newState, {
                Symbol: viewChangeParams.Symbol
            });
        } else {
            $state.go(viewName);
        }
    };
    $scope.addCoinToPortfolio = function() {
        if (!userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to add " + pageInfo.getH1Text() + ' to your portfolio.');
            return;
        }
        var objToSend = {};
        var coinInfo = {};
        coinInfo.Id = pageInfo.getPageId();
        coinInfo.Symbol = pageInfo.getSymbol();
        coinInfo.ImageUrl = pageInfo.getLogo();
        coinInfo.Name = pageInfo.getH1Text();
        coinInfo.BaseUrl = pageInfo.getBaseUrl();
        objToSend.NeedsPortfolioSelection = true;
        objToSend.PortfolioOptions = portfolioSummary.getDisplayData();
        objToSend.PortfolioId = -1;
        if (portfolioSummary.hasData()) {
            objToSend.PortfolioId = objToSend.PortfolioOptions[0].Id;
        }
        objToSend.Coin = coinInfo;
        objToSend.BuyCurrency = $scope.selectedCurrency.DATA.TOSYMBOL || "BTC";
        objToSend.BuyPrice = $scope.selectedCurrency.DATA.PRICE || 0;
        objToSend.BuyPriceType = "per_unit";
        objToSend.ShowAdvanced = false;
        objToSend.WalletName = "";
        objToSend.ExchangeName = "";
        objToSend.BoughtOn = new Date();
        objToSend.BoughtOn.setHours(0, 0, 0, 0);
        objToSend.SoldOn = objToSend.BoughtOn;
        objToSend.Sold = false;
        objToSend.Action = 'Add';
        objToSend.ShowBasicInfo = true;
        portfolioModalService.showCoinDialog(objToSend);
    };
    $scope.changeFollowingStatus = function() {
        if ($scope.changingFollowStatus) {
            return;
        }
        $scope.changingFollowStatus = true;
        var followingType = userManager.FOLLOWING.COIN;
        userManager.changeFollowingStatus(pageInfo.getPageId(), followingType).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 100) {
                    toastNotifications.addNotification('success', 'Following ' + pageInfo.getH1Text() + '!');
                    userManager.setFollowing(true);
                    socialStats.addFollower(userManager.getCryptopianAsFollower());
                }
                if (data.Type == 200) {
                    toastNotifications.addNotification('success', 'Unfollowed ' + pageInfo.getH1Text() + '!');
                    userManager.setFollowing(false);
                    socialStats.removeFollower(userManager.getCryptopianAsFollower());
                }
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal("Please login or signup and you'll be able to follow " + pageInfo.getH1Text() + '.');
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
            }
            $scope.changingFollowStatus = false;
        });
    };
    $scope.parseMessage = function(messageInfo) {
        var subKey = messageInfo.SubKey;
        if ($scope.connection.subs.indexOf(subKey) > -1) {
            $scope.connection.loadingData = false;
            if (subKey == messageInfo.Raw) {
                return;
            }
            if (!messageInfo.Obj.hasOwnProperty("CHANGE24HOUR")) {
                return;
            }
            var arrayKey = 0;
            arrayKey = $scope.connection.keyToPosition[subKey];
            if (arrayKey < $scope.initialVisibleCurrencyNumber) {
                $scope.currencyDisplay[arrayKey] = streamerUtilities.decorateCurrentWithMktCap($scope.currencyDisplay[arrayKey], messageInfo, pageInfo.getCoinsMined());
                $scope.currencyDisplay[arrayKey].timeout = $timeout(function() {
                    $scope.handleTimeout(subKey);
                }, 1500, false);
            } else {
                $scope.currencySecondaryDisplay[arrayKey - $scope.initialVisibleCurrencyNumber] = streamerUtilities.decorateCurrentWithMktCap($scope.currencySecondaryDisplay[arrayKey - $scope.initialVisibleCurrencyNumber], messageInfo, pageInfo.getCoinsMined());
                $scope.currencySecondaryDisplay[arrayKey - $scope.initialVisibleCurrencyNumber].timeout = $timeout(function() {
                    $scope.handleTimeout(subKey);
                }, 1500, false);
            }
            $scope.connection.loadingData = false;
        }
    }
    $scope.handleTimeout = function(subKey) {
        var arrayKeyToTimeout = $scope.connection.keyToPosition[subKey];
        if (arrayKeyToTimeout || arrayKeyToTimeout == 0) {
            var visual;
            if (arrayKeyToTimeout < $scope.initialVisibleCurrencyNumber) {
                visual = $scope.currencyDisplay[arrayKeyToTimeout]['VISUAL'];
            } else {
                visual = $scope.currencySecondaryDisplay[arrayKeyToTimeout - $scope.initialVisibleCurrencyNumber]['VISUAL'];
            }
            var dateNow = new Date();
            for (var property in visual) {
                if (visual[property] != false && dateNow >= visual[property]) {
                    visual[property] = false;
                }
            }
            if (arrayKeyToTimeout < $scope.initialVisibleCurrencyNumber) {
                $scope.currencyDisplay[arrayKeyToTimeout]['VISUAL'] = visual;
            } else {
                $scope.currencySecondaryDisplay[arrayKeyToTimeout - $scope.initialVisibleCurrencyNumber]['VISUAL'] = visual;
            }
        }
    };
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        $scope.connection.connected = true;
        streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    });
    $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
    streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
        $scope.parseMessage(messageInfo);
    });
}]);
angular.module('ccc-app').controller('StreamingTradesCtrl', ['$rootScope', '$scope', '$timeout', '$stateParams', '$filter', 'subscriptionManager', 'streamerUtilities', 'pageInfo', 'dateParsing', function($rootScope, $scope, $timeout, $stateParams, $filter, subscriptionManager, streamerUtilities, pageInfo, dateParsing) {
    $scope.dateParsing = dateParsing;
    $scope.connection = streamerUtilities.initConnection();
    $scope.progressBar = streamerUtilities.initProgressBar();
    $scope.markets = [];
    $scope.toSymbol = subscriptionManager.getCurrentToSymbol();
    $scope.toSymbolDisplay = CCC.STATIC.CURRENCY.getSymbol($scope.toSymbol);
    $scope.fromSymbol = pageInfo.getSymbol() || pageInfo.getH1Text();
    $scope.tradeSummary = {
        'SellsV': 0,
        'SellsVT': 0,
        'SellsNr': 0,
        'DisplaySellsVT': '',
        'BuyV': 0,
        'BuyVT': 0,
        'BuyNr': 0,
        'DisplayBuyVT': '',
        'UnknownV': 0,
        'UnknownVT': 0,
        'UnknownNr': 0,
        'DisplayUnknownVT': '',
        'TotalV': 0,
        'TotalVT': 0,
        'DisplayTotalVT': '',
        'PctSell': 0,
        'PctUnknown': 0,
        'PctBuy': 0
    };
    $scope.generateMarketsFromSubs = function(subs) {
        $scope.markets = [];
        $scope.exchangeAlreadyExists = {};
        for (var i = 0, length = subs.length; i < length; i++) {
            var currentSubDetails = CCC.TRADE.unpack(subs[i]);
            var subToPush = {
                'Market': subscriptionManager.getNameForExchange(currentSubDetails.M),
                'IsStreaming': true,
                'SubKey': subs[i]
            };
            if (!$scope.exchangeAlreadyExists.hasOwnProperty(currentSubDetails.M)) {
                $scope.markets.push(subToPush);
                $scope.exchangeAlreadyExists[currentSubDetails.M] = true;
            }
        }
    };
    $scope.reconnectAll = function(symbol) {
        $scope.connection.subs = subscriptionManager.getComputedTradeSubsBySymbol(symbol);
        $scope.exchanges = $scope.generateMarketsFromSubs($scope.connection.subs);
        streamerUtilities.addGlobalPageSubs($scope.connection.subs);
    };
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getComputedTradeSubsObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        if ($scope.connection.connected) {
            $scope.reconnectAll($stateParams.Symbol.toUpperCase());
        } else {
            $scope.connection.subs = subscriptionManager.getComputedTradeSubsBySymbol($stateParams.Symbol.toUpperCase());
            $scope.exchanges = $scope.generateMarketsFromSubs($scope.connection.subs);
        }
    } else {
        $scope.connection.subs = subscriptionManager.getComputedTradeSubs();
        $scope.exchanges = $scope.generateMarketsFromSubs($scope.connection.subs);
        if ($scope.connection.connected) {
            streamerUtilities.addGlobalPageSubs($scope.connection.subs);
        }
    }
    $scope.disconnectAll = function(changingView) {
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        $scope.connection = streamerUtilities.initConnection();
        $scope.progressBar = streamerUtilities.initProgressBar();
        if (changingView) {
            $scope.changeCurrency();
            $scope.changeView();
            $scope.socketConnected();
            $scope.tradeMessage();
        }
    };
    $scope.selectAllStreamingMarkets = function() {
        var someExchangesNotStreaming = false;
        var tempSubs = [];
        for (var i = 0, length = $scope.markets.length; i < length; i++) {
            if (!$scope.markets[i].IsStreaming) {
                $scope.markets[i].IsStreaming = true;
                someExchangesNotStreaming = true;
            }
            tempSubs.push($scope.markets[i].SubKey);
        };
        if (someExchangesNotStreaming) {
            $scope.connection.subs = tempSubs;
            streamerUtilities.addGlobalPageSubs($scope.connection.subs);
        }
    };
    $scope.deselectAllStreamingMarkets = function() {
        var someExchangesStreaming = false;
        for (var i = 0, length = $scope.markets.length; i < length; i++) {
            if ($scope.markets[i].IsStreaming) {
                $scope.markets[i].IsStreaming = false;
                someExchangesStreaming = true;
            }
        };
        if (someExchangesStreaming) {
            streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
            $scope.connection.data = []
            $scope.connection.subs = [];
        }
    };
    $scope.changeMarketStreamingStatus = function(id) {
        $scope.markets[id].IsStreaming = !$scope.markets[id].IsStreaming;
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        var tempSubs = [];
        for (var i = 0, length = $scope.markets.length; i < length; i++) {
            if ($scope.markets[i].IsStreaming) {
                tempSubs.push($scope.markets[i].SubKey);
            }
        };
        if (!$scope.markets[id].IsStreaming) {
            $scope.connection.data = [];
        }
        $scope.connection.subs = tempSubs;
        streamerUtilities.addGlobalPageSubs($scope.connection.subs);
    };
    $scope.changeCurrency = $rootScope.$on('ChangeCurrency', function(event, symbol) {
        $scope.disconnectAll(false);
        $scope.reconnectAll(symbol);
        $scope.toSymbol = symbol;
        $scope.toSymbolDisplay = CCC.STATIC.CURRENCY.getSymbol($scope.toSymbol);
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.disconnectAll(true);
    });
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        $scope.connection.connected = true;
        $scope.progressBar.current++;
        $scope.progressBar.message = 'Loading data...';
        streamerUtilities.addGlobalPageSubs($scope.connection.subs);
    });
    $scope.parseMessage = function(messageInfo) {
        if ($scope.connection.subs.indexOf(messageInfo.SubKey) > -1) {
            $scope.connection.loadingData = false;
            if (messageInfo.SubKey != messageInfo.Raw) {
                var currentTrade = messageInfo.Obj;
                var allTrades = $scope.connection.data;
                var allTradesLength = allTrades.length;
                if (allTradesLength > 19) {
                    if (allTrades[allTradesLength - 1].TS > currentTrade.TS) {
                        return;
                    }
                }
                currentTrade.timeout = $timeout(function() {
                    currentTrade['highlight'] = false;
                }, 1500, false);
                allTrades.unshift(currentTrade);
                if (allTradesLength > 19) {
                    var prevTrade = allTrades.pop();
                    prevTrade = null;
                }
                allTrades.sort(function(a, b) {
                    if (a.TS > b.TS) {
                        return -1;
                    }
                    if (a.TS < b.TS) {
                        return 1;
                    }
                    if (a.ARRIVEDON > b.ARRIVEDON) {
                        return -1;
                    }
                    if (a.ARRIVEDON < b.ARRIVEDON) {
                        return 1;
                    }
                    return 0;
                });
                var tempTradeSummary = {
                    'SellsV': 0,
                    'SellsVT': 0,
                    'SellsNr': 0,
                    'DisplaySellsVT': '',
                    'BuyV': 0,
                    'BuyVT': 0,
                    'BuyNr': 0,
                    'DisplayBuyVT': '',
                    'UnknownV': 0,
                    'UnknownVT': 0,
                    'UnknownNr': 0,
                    'DisplayUnknownVT': '',
                    'TotalV': 0,
                    'TotalVT': 0,
                    'DisplayTotalVT': '',
                    'PctSell': 0,
                    'PctUnknown': 0,
                    'PctBuy': 0
                };
                for (var i = 0; i < allTrades.length; i++) {
                    var quantity = parseFloat(allTrades[i].Q);
                    var totalPrice = parseFloat(allTrades[i].TOTAL);
                    switch (allTrades[i].DISPLAY.F) {
                        case 'Buy':
                            tempTradeSummary.BuyV = tempTradeSummary.BuyV + quantity;
                            tempTradeSummary.BuyVT = tempTradeSummary.BuyVT + totalPrice;
                            tempTradeSummary.BuyNr++;
                            break;
                        case 'Sell':
                            tempTradeSummary.SellsV = tempTradeSummary.SellsV + quantity;
                            tempTradeSummary.SellsVT = tempTradeSummary.SellsVT + totalPrice;
                            tempTradeSummary.SellsNr++;
                            break;
                        case 'Unknown':
                            tempTradeSummary.UnknownV = tempTradeSummary.UnknownV + quantity;
                            tempTradeSummary.UnknownVT = tempTradeSummary.UnknownVT + totalPrice;
                            tempTradeSummary.UnknownNr++;
                            break;
                    };
                    tempTradeSummary.TotalV = tempTradeSummary.TotalV + quantity;
                    tempTradeSummary.TotalVT = tempTradeSummary.TotalVT + totalPrice;
                }
                $scope.tradeSummary = tempTradeSummary;
                $scope.tradeSummary.PctSell = Math.floor($scope.tradeSummary.SellsVT / $scope.tradeSummary.TotalVT * 100);
                $scope.tradeSummary.PctUnknown = Math.floor($scope.tradeSummary.UnknownVT / $scope.tradeSummary.TotalVT * 100);
                $scope.tradeSummary.PctBuy = 100 - $scope.tradeSummary.PctSell - $scope.tradeSummary.PctUnknown;
                $scope.tradeSummary.DisplaySellsVT = CCC.STATIC.UTIL.convertValueToDisplay($scope.toSymbolDisplay, $scope.tradeSummary.SellsVT, $filter('number'));
                $scope.tradeSummary.DisplayBuyVT = CCC.STATIC.UTIL.convertValueToDisplay($scope.toSymbolDisplay, $scope.tradeSummary.BuyVT, $filter('number'));
                $scope.tradeSummary.DisplayUnknownVT = CCC.STATIC.UTIL.convertValueToDisplay($scope.toSymbolDisplay, $scope.tradeSummary.UnknownVT, $filter('number'));
                $scope.tradeSummary.DisplayTotalVT = CCC.STATIC.UTIL.convertValueToDisplay($scope.toSymbolDisplay, $scope.tradeSummary.TotalVT, $filter('number'));
            }
        }
    };
    $scope.tradeMessage = $rootScope.$on('TradeMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
}]);;;;
angular.module('ccc-app').directive('basicMonitor', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/basic-monitor.html',
        controller: 'StreamingCurrentSubsCtrl',
        scope: {
            pagetype: "@",
            limit: "@"
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('orderBook', ['$interval', '$timeout', function($interval, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'streamers/order-book.html',
        controller: 'StreamingOrderBookCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    }
}]);
angular.module('ccc-app').directive('currentPriceWidget', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/current-price-widget.html',
        controller: 'CurrentAggPriceWidget',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('chartWithTradeData', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/chart-with-trade-data.html',
        controller: ['$rootScope', '$scope', '$timeout', '$stateParams', '$filter', 'subscriptionManager', 'streamerUtilities', 'dateParsing', 'chartUtil', function($rootScope, $scope, $timeout, $stateParams, $filter, subscriptionManager, streamerUtilities, dateParsing, chartUtil) {
            $scope.DateParsing = dateParsing;
            $scope.trendup = true;
            $scope.connection = streamerUtilities.initConnection();
            $scope.progressBar = streamerUtilities.initProgressBar();
            $scope.parseMessage = function(messageInfo) {
                var subKey = messageInfo.SubKey;
                if ($scope.connection.subs.indexOf(subKey) > -1) {
                    if (subKey == messageInfo.Raw) {
                        $scope.progressBar.current++;
                        if ($scope.progressBar.current == $scope.progressBar.max) {
                            $scope.connection.loadingData = false;
                        }
                    } else {
                        var messageObject = messageInfo.Obj;
                        var arrayKey = 0;
                        if ($scope.connection.keyToPosition[subKey] != 0) {
                            arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                        }
                        $scope.connection.data[arrayKey] = streamerUtilities.decorateCurrent($scope.connection.data[arrayKey], messageInfo);
                        if ($scope.connection.data[arrayKey].DATA.CHANGE24HOUR >= 0) {
                            $scope.trendup = true;
                        } else {
                            $scope.trendup = false;
                        }
                        if ($scope.connection.loadingData) {
                            $scope.connection.keyToPosition[subKey] = arrayKey;
                            $scope.connection.data[arrayKey]['VISUAL'] = {};
                            $scope.progressBar.current++;
                            $scope.progressBar.message = messageObject.MARKET + ':' + messageObject.FROMSYMBOL + '/' + messageObject.TOSYMBOL;
                            if ($scope.progressBar.current == $scope.progressBar.max) {
                                $scope.connection.loadingData = false;
                            }
                        } else {
                            $scope.connection.data[arrayKey].timeout = $timeout(function() {
                                $scope.handleTimeout(subKey);
                            }, 1500, false);
                        }
                    }
                }
            }
            $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
                $scope.connection.connected = true;
                $scope.progressBar.current++;
                $scope.progressBar.message = 'Loading data...';
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            });
            $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
                $scope.parseMessage(messageInfo);
            });
            $scope.handleTimeout = function(subKey) {
                var arrayKeyToTimeout = $scope.connection.keyToPosition[subKey];
                if (arrayKeyToTimeout || arrayKeyToTimeout == 0) {
                    var visual = $scope.connection.data[arrayKeyToTimeout]['VISUAL'];
                    var dateNow = new Date();
                    for (var property in visual) {
                        if (visual[property] != false && dateNow >= visual[property]) {
                            visual[property] = false;
                        }
                    }
                    $scope.connection.data[arrayKeyToTimeout]['VISUAL'] = visual;
                }
            };
            $scope.buildChart = function() {
                $scope.chart = AmCharts.makeChart($scope.chartId, {
                    type: "serial",
                    theme: "none",
                    dataProvider: [],
                    panEventsEnabled: false,
                    marginTop: 0,
                    marginRight: 0,
                    marginLeft: 0,
                    marginBottom: 0,
                    autoMargins: false,
                    showBalloon: false,
                    addClassNames: true,
                    pathToImages: "/images/",
                    categoryField: "time",
                    valueAxes: [{
                        gridAlpha: 0,
                        axisAlpha: 0,
                        startOnAxis: true,
                    }],
                    categoryAxis: {
                        minPeriod: "hh",
                        maxSeries: 360,
                        gridAlpha: 0,
                        axisAlpha: 0,
                        startOnAxis: true
                    },
                    chartScrollbarSettings: {},
                    graphs: [{
                        id: "g1",
                        lineColor: '#1d8b3a',
                        fillAlphas: 0.4,
                        valueField: "close",
                        balloonText: "<div style='margin:0px; font-size:13px;font-weight:bold;'>[[formattedPrice]]</div><div style='margin:0px; font-size:11px;'>[[formattedTime]]</div>"
                    }],
                    chartScrollbarSettings: {
                        graph: "g1",
                        enabled: true
                    },
                    chartCursor: {
                        valueBalloonsEnabled: true,
                        categoryBalloonEnabled: true,
                        zoomable: false
                    },
                    panelsSettings: {
                        usePrefixes: false
                    }
                });
                $scope.getHistoData();
            };
            $scope.getHistoData = function() {
                $scope.dataIsLoading = true;
                if (chartUtil.hasData('hour', $scope.exchange, $scope.fromsymbol, $scope.tosymbol, $scope.maxpoints)) {
                    $scope.dataIsLoading = false;
                    var data = chartUtil.getHistoFromMemory('hour', $scope.exchange, $scope.fromsymbol, $scope.tosymbol, $scope.maxpoints);
                    var currencySymbol = CCC.STATIC.CURRENCY.getSymbol($scope.tosymbol);
                    var chartData = chartUtil.polyfillChartData(data, 3600, 0);
                    chartData = chartData.data;
                    chartData.map(function(obj) {
                        obj['formattedTime'] = $filter('date')(obj['time'], 'MMM d, HH:mm');
                        obj['formattedPrice'] = CCC.STATIC.UTIL.convertValueToDisplay(currencySymbol, obj['close'], $filter('number'));
                        return obj;
                    });
                    $scope.chart.dataProvider = chartData;
                    if ($scope.chart.dataProvider[0]['open'] > $scope.chart.dataProvider[$scope.chart.dataProvider.length - 1]['close']) {
                        $scope.trendup = false;
                    }
                    $scope.dataLoaded = true;
                    try {
                        $scope.chart.validateData();
                    } catch (err) {}
                } else {
                    chartUtil.getHistoFromMinApi('hour', $scope.exchange, $scope.fromsymbol, $scope.tosymbol, $scope.maxpoints, 1).success(function(data) {
                        $scope.dataIsLoading = false;
                        var currencySymbol = CCC.STATIC.CURRENCY.getSymbol($scope.tosymbol);
                        var chartData = chartUtil.polyfillChartData(data, 3600, 0);
                        chartData = chartData.data;
                        chartData.map(function(obj) {
                            obj['formattedTime'] = $filter('date')(obj['time'], 'MMM d, HH:mm');
                            obj['formattedPrice'] = CCC.STATIC.UTIL.convertValueToDisplay(currencySymbol, obj['close'], $filter('number'));
                            return obj;
                        });
                        $scope.chart.dataProvider = chartData;
                        chartUtil.saveData('hour', $scope.exchange, $scope.fromsymbol, $scope.tosymbol, $scope.maxpoints, data)
                        $scope.dataLoaded = true;
                        try {
                            $scope.chart.validateData();
                        } catch (err) {}
                    });
                }
            };
            $scope.chartId = $scope.charttype + '-' + $scope.exchange + '-' + $scope.fromsymbol + '-' + $scope.tosymbol;
            $scope.connection.subs = [$scope.subtype + '~' + $scope.exchange + '~' + $scope.fromsymbol + '~' + $scope.tosymbol];
            $scope.progressBar.max = $scope.connection.subs.length + 2;
            if ($scope.connection.connected) {
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            }
            $scope.buildChart();
        }],
        scope: {
            charttype: '@',
            subtype: '@',
            exchange: '@',
            fromsymbol: '@',
            tosymbol: '@',
            maxpoints: '@',
            link: '@',
            linktext: '@'
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('streamingMktCap', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/mkt-cap.html',
        controller: ['$rootScope', '$scope', '$timeout', '$state', 'pageInfo', 'subscriptionManager', 'streamerUtilities', function($rootScope, $scope, $timeout, $state, pageInfo, subscriptionManager, streamerUtilities) {
            $scope.connection = streamerUtilities.initConnection();
            $scope.totalCoinsMined = pageInfo.getCoinsMined();
            $scope.connection.subs = subscriptionManager.getCurrentAGGSub();
            $scope.showMarketCap = false;
            $rootScope.$on('$stateChangeSuccess', function(event) {
                $scope.showMarketCap = !$state.includes('overview');
            });
            $scope.parseMessage = function(messageInfo) {
                var subKey = messageInfo.SubKey;
                if ($scope.connection.subs.indexOf(subKey) > -1) {
                    if (subKey == messageInfo.Raw) {
                        $scope.connection.loadingData = false;
                    } else {
                        if ($scope.connection.loadingData) {
                            $scope.connection.loadingData = false;
                        }
                        if (!messageInfo.Obj['PRICE']) {
                            return;
                        }
                        var arrayKey = 0;
                        if ($scope.connection.keyToPosition[subKey] != 0) {
                            arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                        }
                        if (!$scope.connection.data[arrayKey]) {
                            $scope.connection.data[arrayKey] = {};
                        }
                        $scope.connection.keyToPosition[subKey] = arrayKey;
                        $scope.connection.data[arrayKey] = streamerUtilities.decorateMktCap(messageInfo, $scope.totalCoinsMined);
                    }
                }
            };
            $scope.reconnectAll = function(symbol) {
                $scope.connection.subs = subscriptionManager.getCurrentAGGSubByToSymbol(symbol);
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            };
            $scope.disconnectAll = function(changingView) {
                streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
                $scope.connection = streamerUtilities.initConnection();
            };
            $scope.changeCurrency = $rootScope.$on('ChangeCurrency', function(event, symbol) {
                $scope.disconnectAll(false);
                $scope.reconnectAll(symbol);
            });
            $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
                $scope.connection.connected = true;
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            });
            $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
                $scope.parseMessage(messageInfo);
            });
        }],
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('coinProfileLookV2', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/coin-profile-look-v2.html',
        controller: 'CoinProfileLookTop',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('coinProfileLookTop', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/coin-profile-look-top.html',
        controller: 'CoinProfileLookTop',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('exchangeProfileLookTop', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/exchange-profile-look-top.html',
        controller: ['$rootScope', '$scope', '$state', '$stateParams', '$timeout', 'cModalService', 'subscriptionManager', 'pageInfo', 'userManager', 'portfolioSummary', 'portfolioManager', 'portfolioModalService', 'toastNotifications', 'socialStats', function($rootScope, $scope, $state, $stateParams, $timeout, cModalService, subscriptionManager, pageInfo, userManager, portfolioSummary, portfolioManager, portfolioModalService, toastNotifications, socialStats) {
            $scope.userManager = userManager;
            $scope.changingFollowStatus = false;
            $scope.followingHover = false;
            $scope.showLoginScreen = function(timeoutMS) {
                if (!userManager.isLoggedIn()) {
                    $timeout(function() {
                        if (!userManager.isLoggedIn() && !userManager.isShowingLogin()) {
                            cModalService.showLoginModal('If you are enjoying our free ' + pageInfo.getH1Text() + ' streaming service please login or signup.');
                        }
                    }, timeoutMS);
                }
            };
            $scope.showLoginScreen(300000);
            $scope.initialVisibleCurrencyNumber = 7;
            $scope.currencyDisplay = [];
            $scope.currencySecondaryDisplay = [];
            $scope.currencyIsInSecondary = false;
            $scope.selectedCurrency = {
                'Symbol': ''
            };
            $scope.firstViewLoad = true;
            var currentSubsClasification = subscriptionManager.getCurrentSubsClassification();
            var tempKeyToPos = {};
            var tempSubs = [];
            for (var i = 0; i < currentSubsClasification.length; i++) {
                if (i < $scope.initialVisibleCurrencyNumber) {
                    $scope.currencyDisplay.push({
                        Symbol: currentSubsClasification[i],
                        TotalCoins: subscriptionManager.getCurrentSubsByToSymbol(currentSubsClasification[i]).length
                    });
                } else {
                    $scope.currencySecondaryDisplay.push({
                        Symbol: currentSubsClasification[i],
                        TotalCoins: subscriptionManager.getCurrentSubsByToSymbol(currentSubsClasification[i]).length
                    });
                }
            }
            $scope.state = $state;
            $scope.pageInfo = pageInfo;
            $scope.secondLevelNav = pageInfo.getSecondLevelNav();
            $scope.totalSubs = 0;
            $scope.totalSecondarySubs = 0;
            $scope.generateClassForDropdown = function() {
                $scope.totalSubs = currentSubsClasification.length;
                $scope.totalSecondarySubs = $scope.currencySecondaryDisplay.length;
            };
            $scope.generateClassForDropdown();
            $scope.$root.$on('$stateChangeSuccess', function(event) {
                if ($state.includes("post")) {
                    if ($stateParams.hasOwnProperty("PostId") && $stateParams.PostId.substring(0, 2) == "p_") {
                        pageInfo.setCurrentPostId($stateParams.PostId.replace("p_", ""));
                    } else {
                        $scope.changeView('forum');
                        return;
                    }
                }
                if ($state.includes("ireview")) {
                    if ($stateParams.hasOwnProperty("ReviewId") && $stateParams.ReviewId.substring(0, 2) == "r_") {
                        pageInfo.setCurrentReviewId($stateParams.ReviewId.replace("r_", ""));
                    } else {
                        $scope.changeView('reviews');
                        return;
                    }
                }
                if ($stateParams.hasOwnProperty("Symbol")) {
                    var currentPageSymbol = $stateParams.Symbol.toUpperCase();
                    var foundSymbol = false;
                    angular.forEach($scope.currencyDisplay, function(value, key) {
                        if (value.Symbol == currentPageSymbol) {
                            foundSymbol = true;
                            $scope.selectedCurrency = value;
                        }
                    });
                    if (!foundSymbol) {
                        angular.forEach($scope.currencySecondaryDisplay, function(value, key) {
                            if (value.Symbol == currentPageSymbol) {
                                $scope.selectedCurrency = value;
                                $scope.currencyIsInSecondary = true;
                                foundSymbol = true;
                            }
                        });
                    }
                    if ($scope.firstViewLoad) {
                        if (!foundSymbol) {
                            $scope.changeCurrency(0, true);
                            $scope.firstViewLoad = false;
                        } else {
                            subscriptionManager.changeCurrency($scope.selectedCurrency.Symbol);
                            $scope.firstViewLoad = false;
                        }
                    }
                } else {
                    if ($scope.currencyDisplay.length > 0) {
                        $scope.selectedCurrency = $scope.currencyDisplay[0];
                    }
                }
                var viewToTrack = $state.current.name.replace('.currency', '');
                pageInfo.trackPage(pageInfo.getPageId(), "Exchange_" + viewToTrack);
            });
            $scope.changeCurrency = function(id, isMain) {
                if (isMain) {
                    if ($scope.currencyDisplay.length > 0) {
                        $scope.selectedCurrency = $scope.currencyDisplay[id];
                    }
                    $scope.currencyIsInSecondary = false;
                } else {
                    $scope.currencyIsInSecondary = true;
                    if ($scope.currencySecondaryDisplay.length > 0) {
                        $scope.selectedCurrency = $scope.currencySecondaryDisplay[id];
                    }
                }
                var newState = $state.current.name;
                subscriptionManager.changeCurrency($scope.selectedCurrency.Symbol);
                if (newState != "") {
                    if (newState == "post") {
                        newState = "post.postid";
                    }
                    if (!$state.includes("*.currency") && !$state.includes("*.*.currency")) {
                        newState += ".currency";
                    }
                    $state.go(newState, {
                        Symbol: $scope.selectedCurrency.Symbol
                    });
                }
            };
            $scope.isActive = function(viewName) {
                if (viewName == "forum" && $state.includes("post")) {
                    return true;
                }
                if (viewName == "reviews" && $state.includes("ireview")) {
                    return true;
                }
                return $state.includes(viewName);
            };
            $scope.getActiveName = function() {
                if ($state.includes("post")) {
                    return "Forum";
                }
                if ($state.includes("ireview")) {
                    return "Reviews";
                }
                for (var i = 0; i < $scope.secondLevelNav.length; i++) {
                    if ($state.includes($scope.secondLevelNav[i].ViewName))
                        return $scope.secondLevelNav[i].DisplayName;
                }
            };
            $scope.changeView = function(viewName) {
                if ($state.includes(viewName))
                    return;
                var viewChangeParams = {};
                viewChangeParams.ViewName = viewName;
                viewChangeParams.Symbol = $scope.selectedCurrency.Symbol;
                subscriptionManager.changeView(viewChangeParams);
                var newState = viewName + ".currency";
                if ($scope.selectedCurrency) {
                    $state.go(newState, {
                        Symbol: viewChangeParams.Symbol
                    });
                } else {
                    $state.go(viewName);
                }
            };
            $scope.changeFollowingStatus = function() {
                if ($scope.changingFollowStatus) {
                    return;
                }
                $scope.changingFollowStatus = true;
                var followingType = userManager.FOLLOWING.EXCHANGE;
                userManager.changeFollowingStatus(pageInfo.getPageId(), followingType).success(function(data) {
                    if (data["Response"] == "Success") {
                        if (data.Type == 100) {
                            toastNotifications.addNotification('success', 'Following ' + pageInfo.getH1Text() + '!');
                            userManager.setFollowing(true);
                            socialStats.addFollower(userManager.getCryptopianAsFollower());
                        }
                        if (data.Type == 200) {
                            toastNotifications.addNotification('success', 'Unfollowed ' + pageInfo.getH1Text() + '!');
                            userManager.setFollowing(false);
                            socialStats.removeFollower(userManager.getCryptopianAsFollower());
                        }
                    } else {
                        if (data.Type == 1) {
                            cModalService.showLoginModal("Please login or signup and you'll be able to follow " + pageInfo.getH1Text() + '.');
                        }
                        if (data.Type == 5) {
                            cModalService.showActivationReminderModal();
                        };
                    }
                    $scope.changingFollowStatus = false;
                });
            };
            $rootScope.$on('ChangeToForumView', function(event) {
                $scope.changeView('forum');
            });
            $rootScope.$on('ChangeToReviewsView', function(event) {
                $scope.changeView('reviews');
            });
        }],
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('featuredCoins', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/featured-coins.html',
        controller: ['$rootScope', '$scope', '$state', '$stateParams', '$timeout', 'subscriptionManager', 'pageInfo', 'streamerUtilities', function($rootScope, $scope, $state, $stateParams, $timeout, subscriptionManager, pageInfo, streamerUtilities) {
            $scope.connection = streamerUtilities.initConnection();
            $scope.progressBar = streamerUtilities.initProgressBar();
            for (var i = 0; i < $scope.subs.length; i++) {
                $scope.connection.keyToPosition[$scope.subs[i]] = i;
            }
            $scope.connection.subs = $scope.subs;
            $scope.progressBar.max = $scope.connection.subs.length + 2;
            $scope.parseMessage = function(messageInfo) {
                var subKey = messageInfo.SubKey;
                if ($scope.connection.subs.indexOf(subKey) > -1) {
                    if (subKey == messageInfo.Raw) {
                        $scope.progressBar.current++;
                        if ($scope.progressBar.current == $scope.progressBar.max) {
                            $scope.connection.loadingData = false;
                        }
                    } else {
                        var messageObject = messageInfo.Obj;
                        var arrayKey = 0;
                        if ($scope.connection.keyToPosition[subKey] != 0) {
                            arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                        }
                        $scope.connection.data[arrayKey] = streamerUtilities.decorateCurrent($scope.connection.data[arrayKey], messageInfo);
                        if ($scope.connection.data[arrayKey].DATA.CHANGE24HOUR >= 0) {
                            $scope.trendup = true;
                        } else {
                            $scope.trendup = false;
                        }
                        if ($scope.connection.loadingData) {
                            $scope.connection.keyToPosition[subKey] = arrayKey;
                            $scope.connection.data[arrayKey]['VISUAL'] = {};
                            $scope.progressBar.current++;
                            $scope.progressBar.message = messageObject.MARKET + ':' + messageObject.FROMSYMBOL + '/' + messageObject.TOSYMBOL;
                            if ($scope.progressBar.current == $scope.progressBar.max) {
                                $scope.connection.loadingData = false;
                            }
                        } else {
                            $scope.connection.data[arrayKey].timeout = $timeout(function() {
                                $scope.handleTimeout(subKey);
                            }, 1500, false);
                        }
                    }
                }
            }
            $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
                $scope.connection.connected = true;
                $scope.progressBar.current++;
                $scope.progressBar.message = 'Loading data...';
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            });
            $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
                $scope.parseMessage(messageInfo);
            });
            $scope.handleTimeout = function(subKey) {
                var arrayKeyToTimeout = $scope.connection.keyToPosition[subKey];
                if (arrayKeyToTimeout || arrayKeyToTimeout == 0) {
                    var visual = $scope.connection.data[arrayKeyToTimeout]['VISUAL'];
                    var dateNow = new Date();
                    for (var property in visual) {
                        if (visual[property] != false && dateNow >= visual[property]) {
                            visual[property] = false;
                        }
                    }
                    $scope.connection.data[arrayKeyToTimeout]['VISUAL'] = visual;
                }
            };
            if ($scope.connection.connected) {
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            }
        }],
        scope: {
            subs: "=",
            names: "="
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('toplist', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/toplist.html',
        controller: ['$rootScope', '$scope', '$state', '$stateParams', '$timeout', 'subscriptionManager', 'pageInfo', 'streamerUtilities', function($rootScope, $scope, $state, $stateParams, $timeout, subscriptionManager, pageInfo, streamerUtilities) {
            $scope.connection = streamerUtilities.initConnection();
            $scope.progressBar = streamerUtilities.initProgressBar();
            for (var i = 0; i < $scope.items.length; i++) {
                $scope.connection.keyToPosition[$scope.items[i].Element] = i;
            }
            $scope.connection.subs = $scope.items.map(function(obj) {
                return obj.Element;
            });
            $scope.progressBar.max = $scope.connection.subs.length + 2;
            $scope.parseMessage = function(messageInfo) {
                var subKey = messageInfo.SubKey;
                if ($scope.connection.subs.indexOf(subKey) > -1) {
                    if (subKey == messageInfo.Raw) {
                        $scope.progressBar.current++;
                        if ($scope.progressBar.current == $scope.progressBar.max) {
                            $scope.connection.loadingData = false;
                        }
                    } else {
                        var messageObject = messageInfo.Obj;
                        var arrayKey = 0;
                        if ($scope.connection.keyToPosition[subKey] != 0) {
                            arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                        }
                        $scope.connection.data[arrayKey] = streamerUtilities.decorateCurrent($scope.connection.data[arrayKey], messageInfo);
                        if ($scope.connection.data[arrayKey].DATA.CHANGE24HOUR >= 0) {
                            $scope.trendup = true;
                        } else {
                            $scope.trendup = false;
                        }
                        if ($scope.connection.loadingData) {
                            $scope.connection.keyToPosition[subKey] = arrayKey;
                            $scope.connection.data[arrayKey]['VISUAL'] = {};
                            $scope.progressBar.current++;
                            $scope.progressBar.message = messageObject.MARKET + ':' + messageObject.FROMSYMBOL + '/' + messageObject.TOSYMBOL;
                            if ($scope.progressBar.current == $scope.progressBar.max) {
                                $scope.connection.loadingData = false;
                            }
                        } else {
                            $scope.connection.data[arrayKey].timeout = $timeout(function() {
                                $scope.handleTimeout(subKey);
                            }, 1500, false);
                        }
                    }
                }
            }
            $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
                $scope.connection.connected = true;
                $scope.progressBar.current++;
                $scope.progressBar.message = 'Loading data...';
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            });
            $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
                $scope.parseMessage(messageInfo);
            });
            $scope.handleTimeout = function(subKey) {
                var arrayKeyToTimeout = $scope.connection.keyToPosition[subKey];
                if (arrayKeyToTimeout || arrayKeyToTimeout == 0) {
                    var visual = $scope.connection.data[arrayKeyToTimeout]['VISUAL'];
                    var dateNow = new Date();
                    for (var property in visual) {
                        if (visual[property] != false && dateNow >= visual[property]) {
                            visual[property] = false;
                        }
                    }
                    $scope.connection.data[arrayKeyToTimeout]['VISUAL'] = visual;
                }
            };
            if ($scope.connection.connected) {
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            }
        }],
        scope: {
            items: "=",
            tname: "@"
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('symbolExchangeShareTable', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/symbol-exchange-share-table.html',
        controller: 'StreamingCurrentSubsCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('symbolTosymbolShareTable', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/symbol-tosymbol-share-table.html',
        controller: 'StreamingAGGSubsCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('tradesLarge', function() {
    return {
        restrict: 'E',
        templateUrl: 'streamers/trades-large.html',
        controller: 'StreamingTradesCtrl',
        scope: {
            pagetype: "@"
        },
        link: function(scope, element, attrs) {}
    };
});;;;
angular.module('ccc-app').factory('socialStats', ['$http', function socialStatsFactory($http) {
    var socialStatsData = {};
    var dataLoaded = false;
    return {
        setSocialStatsData: function(apiResponse) {
            socialStatsData = apiResponse["Data"];
            dataLoaded = true;
        },
        getSocialStatsData: function() {
            return socialStatsData;
        },
        getSocialStatsTab: function(tabName) {
            if (socialStatsData.hasOwnProperty(tabName)) {
                return socialStatsData[tabName] || {};
            }
            return {};
        },
        getObjectProperty: function(tabName, objectName) {
            if (socialStatsData.hasOwnProperty(tabName)) {
                if (socialStatsData[tabName].hasOwnProperty(objectName)) {
                    return socialStatsData[tabName][objectName] || {};
                }
                return {};
            }
            return {};
        },
        getArrayProperty: function(tabName, arrayName) {
            if (socialStatsData.hasOwnProperty(tabName)) {
                if (socialStatsData[tabName].hasOwnProperty(arrayName)) {
                    return socialStatsData[tabName][arrayName] || [];
                }
                return [];
            }
            return [];
        },
        getFollowers: function() {
            if (socialStatsData['CryptoCompare']['CryptopianFollowers'].length > 10) {
                return socialStatsData['CryptoCompare']['CryptopianFollowers'].slice(0, 10);
            }
            return socialStatsData['CryptoCompare']['CryptopianFollowers'];
        },
        getValueProperty: function(tabName, valueName) {
            if (socialStatsData.hasOwnProperty(tabName)) {
                if (socialStatsData[tabName].hasOwnProperty(valueName)) {
                    return socialStatsData[tabName][valueName] || 0;
                }
                return 0;
            }
            return 0;
        },
        addFollower: function(newFollower) {
            if (dataLoaded) {
                socialStatsData['CryptoCompare']['CryptopianFollowers'].unshift(newFollower);
                var totalFollowers = socialStatsData['CryptoCompare']['Followers'] || 0;
                socialStatsData['CryptoCompare']['Followers'] = totalFollowers + 1;
            }
        },
        removeFollower: function(oldFollower) {
            if (dataLoaded) {
                socialStatsData['CryptoCompare']['CryptopianFollowers'] = socialStatsData['CryptoCompare']['CryptopianFollowers'].filter(function(item) {
                    if (item.Id == oldFollower.Id) {
                        return false;
                    }
                    return true;
                });
                socialStatsData['CryptoCompare']['Followers'] = socialStatsData['CryptoCompare']['Followers'] - 1;
            }
        }
    };
}]);;;;
angular.module('ccc-app').directive('followersInfoBox', ['$compile', 'socialStats', function($compile, socialStats) {
    return {
        restrict: 'E',
        templateUrl: 'general/followers-info-box.html',
        controller: ['$rootScope', '$scope', '$filter', 'socialStats', function($rootScope, $scope, $filter, socialStats) {
            var utilStatic = CCC.STATIC.UTIL;
            $scope.socialStats = socialStats;
            $scope.type = $scope.typeName;
            $scope.getFollowersFormattedNumber = function() {
                return utilStatic.convertValueToDisplay('', socialStats.getValueProperty('CryptoCompare', 'Followers'), $filter('number'), 'short', true);
            };
        }],
        scope: {
            typeName: '@'
        },
        link: function(scope, element, attrs) {}
    };
}]);;;;
angular.module('ccc-app').directive('similarItems', [function() {
    return {
        restrict: 'E',
        templateUrl: 'general/similar-items.html',
        controller: ['$rootScope', '$scope', 'cModalService', 'socialStats', 'userManager', 'toastNotifications', function($rootScope, $scope, cModalService, socialStats, userManager, toastNotifications) {
            $scope.itemList = socialStats.getArrayProperty("CryptoCompare", "SimilarItems");
            $scope.type = $scope.typeName + "s";
            $scope.allSimilarIds = "";
            $scope.itemList.map(function(item) {
                item.isFollowing = false;
                item.changingFollowStatus = false;
                item.Tooltip = "Follow " + item.FullName;
                $scope.allSimilarIds += item.Id + ",";
                return item;
            });
            $scope.allSimilarIds = $scope.allSimilarIds.substring(0, $scope.allSimilarIds.length - 1);
            $scope.loadFollowingStatus = function(newValue) {
                if (newValue == true) {
                    userManager.checkFollowingStatus($scope.allSimilarIds).success(function(data) {
                        if (data.Type == 100) {
                            $scope.itemList.map(function(item) {
                                if (data.Followed.indexOf(item.Id) > -1) {
                                    item.isFollowing = true;
                                    item.Tooltip = "Already following " + item.FullName;
                                } else {
                                    item.isFollowing = false;
                                    item.Tooltip = "Follow " + item.FullName;
                                }
                                return item;
                            });
                        } else {
                            $scope.itemList.map(function(item) {
                                item.isFollowing = false;
                                item.Tooltip = "Follow " + item.FullName;
                                return item;
                            });
                        }
                        $scope.showLoadingStatus = false;
                    });
                } else {
                    $scope.itemList.map(function(item) {
                        item.isFollowing = false;
                        item.Tooltip = "Follow " + item.FullName;
                        return item;
                    });
                    $scope.showLoadingStatus = false;
                }
            };
            if (userManager.isLoggedIn()) {
                $scope.showLoadingStatus = true;
                $scope.itemList.map(function(item) {
                    item.Tooltip = "Checking follow status for " + item.FullName;
                    return item;
                });
                $scope.loadFollowingStatus(true);
            };
            $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
                $scope.showLoadingStatus = true;
                $scope.loadFollowingStatus(newValue);
            });
            $scope.changeFollowingStatus = function(similarItem) {
                if (similarItem.changingFollowStatus) {
                    return;
                }
                if ($scope.showLoadingStatus) {
                    return;
                }
                similarItem.changingFollowStatus = true;
                similarItem.Tooltip = "Changing follow status for " + similarItem.FullName
                userManager.changeFollowingStatus(similarItem.Id, similarItem.FollowingType).success(function(data) {
                    if (data["Response"] == "Success") {
                        if (data.Type == 100) {
                            toastNotifications.addNotification('success', 'Following ' + similarItem.FullName + '!');
                            similarItem.isFollowing = true;
                            similarItem.Tooltip = "Already following " + similarItem.FullName;
                        }
                        if (data.Type == 200) {
                            toastNotifications.addNotification('success', 'Unfollowed ' + similarItem.FullName + '!');
                            similarItem.isFollowing = false;
                            similarItem.Tooltip = "Follow " + similarItem.FullName;
                        }
                    } else {
                        similarItem.Tooltip = "Follow " + similarItem.FullName;
                        if (data.Type == 1) {
                            cModalService.showLoginModal();
                        }
                        if (data.Type == 5) {
                            cModalService.showActivationReminderModal();
                        };
                    }
                    similarItem.changingFollowStatus = false;
                });
            };
        }],
        scope: {
            typeName: '@'
        },
        link: function(scope, element, attrs) {}
    };
}]);;;;
angular.module('ccc-app').factory('forumBackend', ['$http', '$uibModal', function forumBackendFactory($http, $uibModal) {
    return {
        showEditHistoryModal: function(data) {
            var modalInstance = $uibModal.open({
                templateUrl: 'forum/post-edit-history-modal.html',
                controller: 'showEditHistoryCtrl',
                resolve: {
                    data: function() {
                        return data;
                    }
                }
            });
        },
        agree: function(postId) {
            return $http.get("/api/forum/post/update/", {
                params: {
                    at: 0,
                    pId: postId
                }
            });
        },
        getAgreeCryptopians: function(pId, lId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['pId'] = pId;
            paramsForCall['params']['at'] = 0;
            if (lId) {
                paramsForCall['params']['lId'] = lId;
            }
            return $http.get("/api/forum/get/reactioncryptopians/", paramsForCall);
        },
        disagree: function(postId) {
            return $http.get("/api/forum/post/update/", {
                params: {
                    at: 1,
                    pId: postId
                }
            });
        },
        getDisagreeCryptopians: function(pId, lId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['pId'] = pId;
            paramsForCall['params']['at'] = 1;
            if (lId) {
                paramsForCall['params']['lId'] = lId;
            }
            return $http.get("/api/forum/get/reactioncryptopians/", paramsForCall);
        },
        report: function(postId) {
            return $http.get("/api/forum/post/update/", {
                params: {
                    at: 2,
                    pId: postId
                }
            });
        },
        makeStickyPost: function(postId) {
            return $http.get("/api/forum/post/sticky/", {
                params: {
                    id: postId
                }
            });
        },
        deletePost: function(postId) {
            return $http.get("/api/forum/post/delete/", {
                params: {
                    id: postId
                }
            });
        },
        reverseDeletePost: function(postId) {
            return $http.get("/api/forum/post/reversedelete/", {
                params: {
                    id: postId
                }
            });
        },
        getReplies: function(threadId, postId, lastId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['tId'] = threadId;
            paramsForCall['params']['pId'] = postId;
            if (lastId) {
                paramsForCall['params']['lId'] = lastId;
            }
            return $http.get("/api/forum/get/replies/", paramsForCall);
        },
        getPosts: function(tId, tPosts, lId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['tId'] = tId;
            if (lId) {
                paramsForCall['params']['lId'] = lId;
            }
            if (tPosts) {
                paramsForCall['params']['tPosts'] = tPosts;
            }
            return $http.get("/api/forum/get/posts/", paramsForCall);
        },
        getPostsByCryptopian: function(cId, showDeleted, lId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['cId'] = cId;
            if (showDeleted) {
                paramsForCall['params']['showDeleted'] = +showDeleted;
            }
            if (lId) {
                paramsForCall['params']['lId'] = lId;
            }
            return $http.get("/api/forum/get/postsbycryptopian/", paramsForCall);
        },
        getReportedPosts: function(lId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            if (lId) {
                paramsForCall['params']['lId'] = lId;
            }
            return $http.get("/api/forum/get/reportedposts/", paramsForCall);
        },
        getDeletedPosts: function(lId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            if (lId) {
                paramsForCall['params']['lId'] = lId;
            }
            return $http.get("/api/forum/get/deletedposts/", paramsForCall);
        },
        getLatestPosts: function(lId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            if (lId) {
                paramsForCall['params']['lId'] = lId;
            }
            return $http.get("/api/forum/get/latestposts/", paramsForCall);
        },
        getTrendingPosts: function() {
            return $http.get("/api/forum/get/trending/");
        },
        getSinglePost: function(tId, pId) {
            var paramsForCall = {};
            paramsForCall['params'] = {};
            paramsForCall['params']['tId'] = tId;
            paramsForCall['params']['pId'] = pId;
            return $http.get("/api/forum/get/singlepost/", paramsForCall);
        },
        getInvolved: function(arrayOfIds) {
            var paramsForCall = {};
            paramsForCall['Ids'] = arrayOfIds;
            return $http.post("/api/forum/get/involved/", paramsForCall);
        },
        newComment: function(tId, pb, rt) {
            var paramsForCall = {};
            paramsForCall['tId'] = tId;
            paramsForCall['pb'] = pb;
            if (rt) {
                paramsForCall['rt'] = rt;
            }
            return $http.post("/api/forum/post/create/", paramsForCall);
        },
        notificationOnOffClick: function(postId) {
            return $http.get("/api/cryptopian/onoffemailnotification/", {
                params: {
                    iType: 'Post',
                    iId: postId
                }
            });
        },
        editComment: function(pId, pb) {
            var paramsForCall = {};
            paramsForCall['pId'] = pId;
            paramsForCall['pb'] = pb;
            return $http.post("/api/forum/post/edit/", paramsForCall);
        },
        getPastEdits: function(pId) {
            return $http.get("/api/forum/get/edits/", {
                params: {
                    pId: pId
                }
            });
        },
        applyInvolved: function(post, involvedArray) {
            if (involvedArray.hasOwnProperty(post.Id)) {
                var involvedInLocalLength = involvedArray[post.Id].length;
                for (var i = 0; i < involvedInLocalLength; i++) {
                    switch (involvedArray[post.Id][i]) {
                        case 0:
                            post.Actions.Agree.Involved = true;
                            break;
                        case 1:
                            post.Actions.Disagree.Involved = true;
                            break;
                        case 2:
                            post.Actions.Report.Involved = true;
                            break;
                        case 3:
                            post.Notification = true;
                            break;
                    }
                }
            }
        },
        applyUnInvolved: function(post) {
            post.Actions.Agree.Involved = false;
            post.Actions.Disagree.Involved = false;
            post.Actions.Report.Involved = false;
            post.Notification = false;
        }
    }
}]);
angular.module('ccc-app').factory('forumPreLoadedData', [function forumPreLoadedDataFactory(forumBackend) {
    var postArray = [];
    var moreAvailable = false;
    var isPreloaded = false;
    return {
        isPreloaded: function() {
            return isPreloaded;
        },
        setInitData: function(initialPostData) {
            isPreloaded = true;
            postArray = initialPostData.PostArray;
            moreAvailable = initialPostData.MoreAvailable;
        },
        getPostsArray: function() {
            return postArray;
        },
        getMoreAvailable: function() {
            return moreAvailable;
        }
    };
}]);;;;
angular.module('ccc-app').controller('forumContainerCtrl', ['$rootScope', '$scope', 'forumBackend', 'forumPreLoadedData', 'cccLocalStorage', 'totals', 'pageInfo', 'gModalService', 'cModalService', 'userManager', 'toastNotifications', function($rootScope, $scope, forumBackend, forumPreLoadedData, cccLocalStorage, totals, pageInfo, gModalService, cModalService, userManager, toastNotifications) {
    totals.new('newPosts', 0);
    if (!totals.exists('totalPosts')) {
        totals.new('totalPosts', 0);
    }
    $scope.threadId = pageInfo.getPageId();
    $scope.postData = [];
    $scope.moreAvailable = false;
    $scope.loadingInitialData = false;
    if (forumPreLoadedData.isPreloaded()) {
        $scope.moreAvailable = forumPreLoadedData.getMoreAvailable();
        $scope.postData = forumPreLoadedData.getPostsArray();
    } else {
        $scope.loadingInitialData = true;
        forumBackend.getPosts($scope.threadId, $scope.tposts).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                $scope.postData = data.PostArray;
                $scope.loadingInitialData = false;
            }
        });
    }
    $scope.pageInfo = pageInfo;
    $scope.isLoadingMore = false;
    $scope.canPost = true;
    $scope.postTextKey = 'post_text_' + $scope.threadId;
    $scope.postText = cccLocalStorage.getText($scope.postTextKey);
    $scope.draftSaved = new Date();
    $scope.showPostLine = false;
    $scope.userManager = userManager;
    $scope.saveToLocalStorage = function() {
        if ($scope.postText == undefined || $scope.postText.length == 0) {
            cccLocalStorage.removeItem($scope.postTextKey);
        } else {
            if ($scope.postText !== cccLocalStorage.getText($scope.postTextKey)) {
                if (cccLocalStorage.setItem($scope.postTextKey, $scope.postText)) {
                    $scope.draftSaved = new Date();
                }
            }
        }
    };
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewName) {
        $scope.changeView();
        $scope.loginChange();
    });
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        if (newValue == true) {
            var arrayOfCurrentItems = [];
            angular.forEach($scope.postData, function(post, key) {
                arrayOfCurrentItems.push(post.Id);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    arrayOfCurrentItems.push(postReply.Id);
                });
            });
            forumBackend.getInvolved(arrayOfCurrentItems).success(function(data) {
                var involvedInLocal = data.InvolvedIn;
                angular.forEach($scope.postData, function(post, key) {
                    forumBackend.applyInvolved(post, involvedInLocal);
                    angular.forEach(post.Replies, function(postReply, replyKey) {
                        forumBackend.applyInvolved(postReply, involvedInLocal);
                    });
                });
            });
        } else {
            angular.forEach($scope.postData, function(post, key) {
                forumBackend.applyUnInvolved(post);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    forumBackend.applyUnInvolved(postReply);
                });
            });
        }
    });
    $scope.newPost = function() {
        if (!$scope.postText || $scope.postText.trim() == "") {
            var message = {
                'Title': 'This post appears to be blank...',
                'Body': 'It seems that you are trying to add an empty post. Please write something and try to post again.',
                'Type': 'warning'
            };
            gModalService.showMessageModal(message);
            return;
        }
        $scope.canPost = false;
        forumBackend.newComment($scope.threadId.toString(), $scope.postText).then(function successCallback(response) {
            var data = response.data;
            if (data["Response"] == "Success") {
                $scope.postText = "";
                cccLocalStorage.removeItem($scope.postTextKey);
                $scope.postData.unshift(data["PostData"]);
                totals.inc('totalPosts', 1);
                totals.inc('newPosts', 1);
                toastNotifications.addNotification('success', 'Your forum post has been successfully added!');
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal("Please login or signup and you'll be able to post new messages.");
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
            }
            $scope.canPost = true;
        }, function errorCallback(response) {
            var data = response.data;
            $scope.canPost = true;
            toastNotifications.addNotification('error', data["Message"]);
        });
    };
    $scope.loadMoreOnScroll = function() {
        if (!$scope.moreAvailable) {
            return;
        }
        if ($scope.isLoadingMore) {
            return;
        }
        if ($scope.loadmore == false) {
            return;
        }
        $scope.isLoadingMore = true;
        forumBackend.getPosts($scope.threadId, $scope.tposts, $scope.postData[$scope.postData.length - 1].Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                var postsData = data.PostArray;
                var dataLength = postsData.length;
                for (var i = 0; i < dataLength; i++) {
                    $scope.postData.push(postsData[i]);
                }
            }
            $scope.isLoadingMore = false;
        });
    };
    $scope.goToForum = function() {
        $rootScope.$emit('ChangeToForumView');
    }
}]);
angular.module('ccc-app').controller('forumContainerNoNewCtrl', ['$rootScope', '$scope', 'forumBackend', 'forumPreLoadedData', 'gModalService', 'cModalService', 'userManager', function($rootScope, $scope, forumBackend, forumPreLoadedData, gModalService, cModalService, userManager) {
    $scope.postData = [];
    $scope.loadingInitialData = false;
    if (forumPreLoadedData.isPreloaded()) {
        $scope.postData = forumPreLoadedData.getPostsArray();
    } else {
        $scope.loadingInitialData = true;
        forumBackend.getPosts($scope.threadId).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.postData = data.PostArray;
                $scope.loadingInitialData = false;
            }
        });
    }
    $scope.userManager = userManager;
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        if (newValue == true) {
            var arrayOfCurrentItems = [];
            angular.forEach($scope.postData, function(post, key) {
                arrayOfCurrentItems.push(post.Id);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    arrayOfCurrentItems.push(postReply.Id);
                });
            });
            forumBackend.getInvolved(arrayOfCurrentItems).success(function(data) {
                var involvedInLocal = data.InvolvedIn;
                angular.forEach($scope.postData, function(post, key) {
                    forumBackend.applyInvolved(post, involvedInLocal);
                    angular.forEach(post.Replies, function(postReply, replyKey) {
                        forumBackend.applyInvolved(postReply, involvedInLocal);
                    });
                });
            });
        } else {
            angular.forEach($scope.postData, function(post, key) {
                forumBackend.applyUnInvolved(post);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    forumBackend.applyUnInvolved(postReply);
                });
            });
        }
    });
}]);
angular.module('ccc-app').controller('forumContainerSinglePostCtrl', ['$rootScope', '$scope', '$filter', 'pageInfo', 'forumBackend', 'forumPreLoadedData', 'gModalService', 'cModalService', 'userManager', function($rootScope, $scope, $filter, pageInfo, forumBackend, forumPreLoadedData, gModalService, cModalService, userManager) {
    $scope.postData = {};
    $scope.loadingInitialData = true;
    $scope.userManager = userManager;
    $scope.postDataUnavailable = false;
    $scope.forumId = pageInfo.getForumId();
    $scope.currentPostId = pageInfo.getCurrentPostId();
    if (parseInt($scope.forumId, 10) > 0 && parseInt($scope.currentPostId, 10)) {
        forumBackend.getSinglePost($scope.forumId, $scope.currentPostId).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.postData = data.PostData;
                pageInfo.setSEOTitle($filter('limitTo')(pageInfo.getH1Text() + ' - ' + $scope.postData.Body, 80));
                if ($scope.postData.Replies.length > 0) {
                    var longestReplyBody = "";
                    for (var i = 0, length = $scope.postData.Replies.length; i < length; i++) {
                        if (longestReplyBody.length < $scope.postData.Replies[i].Body.length) {
                            longestReplyBody = $scope.postData.Replies[i].Body;
                        }
                    }
                    pageInfo.setSEODescription($filter('limitTo')(longestReplyBody, 200));
                } else {
                    pageInfo.setSEODescription('We have no replies to this ' + pageInfo.getH1Text() + ' discussion thread yet. Get involved, share you opinion and help the ' + pageInfo.getH1Text() + ' community.');
                }
            } else {
                $scope.postDataUnavailable = true;
            }
            $scope.loadingInitialData = false;
        }).error(function(data) {
            $scope.loadingInitialData = false;
            $scope.postDataUnavailable = true;
        });
    } else {
        $scope.loadingInitialData = false;
        $scope.postDataUnavailable = true;
    }
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewName) {
        $scope.changeView();
        $scope.loginChange();
    });
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        if (Object.keys($scope.postData).length == 0) {
            return;
        }
        if (newValue == true) {
            var arrayOfCurrentItems = [];
            arrayOfCurrentItems.push($scope.postData.Id);
            if ($scope.postData.hasOwnProperty('Replies')) {
                angular.forEach($scope.postData.Replies, function(postReply, replyKey) {
                    arrayOfCurrentItems.push(postReply.Id);
                });
            }
            forumBackend.getInvolved(arrayOfCurrentItems).success(function(data) {
                var involvedInLocal = data.InvolvedIn;
                forumBackend.applyInvolved($scope.postData, involvedInLocal);
                if ($scope.postData.hasOwnProperty('Replies')) {
                    angular.forEach($scope.postData.Replies, function(postReply, replyKey) {
                        forumBackend.applyInvolved(postReply, involvedInLocal);
                    });
                }
            });
        } else {
            forumBackend.applyUnInvolved($scope.postData);
            if ($scope.postData.hasOwnProperty('Replies')) {
                angular.forEach($scope.postData.Replies, function(postReply, replyKey) {
                    forumBackend.applyUnInvolved(postReply);
                });
            }
        }
    });
    $scope.goToForum = function() {
        $rootScope.$emit('ChangeToForumView');
    }
}]);
angular.module('ccc-app').controller('forumContainerByCryptopianCtrl', ['$rootScope', '$scope', 'forumBackend', 'forumPreLoadedData', 'totals', 'pageInfo', 'gModalService', 'cModalService', 'userManager', 'toastNotifications', function($rootScope, $scope, forumBackend, forumPreLoadedData, totals, pageInfo, gModalService, cModalService, userManager, toastNotifications) {
    totals.new('newPosts', 0);
    if (!totals.exists('totalPosts')) {
        totals.new('totalPosts', 0);
    }
    $scope.postData = [];
    $scope.moreAvailable = false;
    $scope.loadingInitialData = false;
    $scope.cryptopianId = pageInfo.getPageId();
    if (forumPreLoadedData.isPreloaded()) {
        $scope.moreAvailable = forumPreLoadedData.getMoreAvailable();
        $scope.postData = forumPreLoadedData.getPostsArray();
    } else {
        $scope.loadingInitialData = true;
        forumBackend.getPostsByCryptopian($scope.cryptopianId, $scope.showDeletedPosts).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                $scope.postData = data.PostArray;
                $scope.loadingInitialData = false;
            }
        });
    }
    $scope.pageInfo = pageInfo;
    $scope.isLoadingMore = false;
    $scope.userManager = userManager;
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewName) {
        $scope.changeView();
        $scope.loginChange();
    });
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        if (newValue == true) {
            var arrayOfCurrentItems = [];
            angular.forEach($scope.postData, function(post, key) {
                arrayOfCurrentItems.push(post.Id);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    arrayOfCurrentItems.push(postReply.Id);
                });
            });
            forumBackend.getInvolved(arrayOfCurrentItems).success(function(data) {
                var involvedInLocal = data.InvolvedIn;
                angular.forEach($scope.postData, function(post, key) {
                    forumBackend.applyInvolved(post, involvedInLocal);
                    angular.forEach(post.Replies, function(postReply, replyKey) {
                        forumBackend.applyInvolved(postReply, involvedInLocal);
                    });
                });
            });
        } else {
            angular.forEach($scope.postData, function(post, key) {
                forumBackend.applyUnInvolved(post);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    forumBackend.applyUnInvolved(postReply);
                });
            });
        }
    });
    $scope.loadMoreOnScroll = function() {
        if (!$scope.moreAvailable) {
            return;
        }
        if ($scope.isLoadingMore) {
            return;
        }
        $scope.isLoadingMore = true;
        forumBackend.getPostsByCryptopian($scope.cryptopianId, $scope.showDeletedPosts, $scope.postData[$scope.postData.length - 1].Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                var postsData = data.PostArray;
                var dataLength = postsData.length;
                for (var i = 0; i < dataLength; i++) {
                    $scope.postData.push(postsData[i]);
                }
            }
            $scope.isLoadingMore = false;
        });
    };
}]);
angular.module('ccc-app').controller('forumContainerLatestPostsCtrl', ['$rootScope', '$scope', 'forumBackend', 'forumPreLoadedData', 'totals', 'pageInfo', 'gModalService', 'cModalService', 'userManager', 'toastNotifications', function($rootScope, $scope, forumBackend, forumPreLoadedData, totals, pageInfo, gModalService, cModalService, userManager, toastNotifications) {
    totals.new('newPosts', 0);
    if (!totals.exists('totalPosts')) {
        totals.new('totalPosts', 0);
    }
    $scope.postData = [];
    $scope.moreAvailable = false;
    $scope.loadingInitialData = false;
    if (forumPreLoadedData.isPreloaded()) {
        $scope.moreAvailable = forumPreLoadedData.getMoreAvailable();
        $scope.postData = forumPreLoadedData.getPostsArray();
    } else {
        $scope.loadingInitialData = true;
        forumBackend.getLatestPosts().success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                $scope.postData = data.PostArray;
                $scope.loadingInitialData = false;
            }
        });
    }
    $scope.pageInfo = pageInfo;
    $scope.isLoadingMore = false;
    $scope.userManager = userManager;
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewName) {
        $scope.changeView();
        $scope.loginChange();
    });
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        if (newValue == true) {
            var arrayOfCurrentItems = [];
            angular.forEach($scope.postData, function(post, key) {
                arrayOfCurrentItems.push(post.Id);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    arrayOfCurrentItems.push(postReply.Id);
                });
            });
            forumBackend.getInvolved(arrayOfCurrentItems).success(function(data) {
                var involvedInLocal = data.InvolvedIn;
                angular.forEach($scope.postData, function(post, key) {
                    forumBackend.applyInvolved(post, involvedInLocal);
                    angular.forEach(post.Replies, function(postReply, replyKey) {
                        forumBackend.applyInvolved(postReply, involvedInLocal);
                    });
                });
            });
        } else {
            angular.forEach($scope.postData, function(post, key) {
                forumBackend.applyUnInvolved(post);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    forumBackend.applyUnInvolved(postReply);
                });
            });
        }
    });
    $scope.loadMoreOnScroll = function() {
        if (!$scope.moreAvailable) {
            return;
        }
        if ($scope.isLoadingMore) {
            return;
        }
        $scope.isLoadingMore = true;
        forumBackend.getLatestPosts($scope.postData[$scope.postData.length - 1].Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                var postsData = data.PostArray;
                var dataLength = postsData.length;
                for (var i = 0; i < dataLength; i++) {
                    $scope.postData.push(postsData[i]);
                }
            }
            $scope.isLoadingMore = false;
        });
    };
}]);
angular.module('ccc-app').controller('forumContainerReportedPostsCtrl', ['$rootScope', '$scope', 'forumBackend', 'forumPreLoadedData', 'totals', 'pageInfo', 'gModalService', 'cModalService', 'userManager', 'toastNotifications', function($rootScope, $scope, forumBackend, forumPreLoadedData, totals, pageInfo, gModalService, cModalService, userManager, toastNotifications) {
    totals.new('newPosts', 0);
    if (!totals.exists('totalPosts')) {
        totals.new('totalPosts', 0);
    }
    $scope.postData = [];
    $scope.moreAvailable = false;
    $scope.loadingInitialData = false;
    if (forumPreLoadedData.isPreloaded()) {
        $scope.moreAvailable = forumPreLoadedData.getMoreAvailable();
        $scope.postData = forumPreLoadedData.getPostsArray();
    } else {
        $scope.loadingInitialData = true;
        forumBackend.getReportedPosts().success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                $scope.postData = data.PostArray;
                $scope.loadingInitialData = false;
            }
        });
    }
    $scope.pageInfo = pageInfo;
    $scope.isLoadingMore = false;
    $scope.userManager = userManager;
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewName) {
        $scope.changeView();
        $scope.loginChange();
    });
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        if (newValue == true) {
            var arrayOfCurrentItems = [];
            angular.forEach($scope.postData, function(post, key) {
                arrayOfCurrentItems.push(post.Id);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    arrayOfCurrentItems.push(postReply.Id);
                });
            });
            forumBackend.getInvolved(arrayOfCurrentItems).success(function(data) {
                var involvedInLocal = data.InvolvedIn;
                angular.forEach($scope.postData, function(post, key) {
                    forumBackend.applyInvolved(post, involvedInLocal);
                    angular.forEach(post.Replies, function(postReply, replyKey) {
                        forumBackend.applyInvolved(postReply, involvedInLocal);
                    });
                });
            });
        } else {
            angular.forEach($scope.postData, function(post, key) {
                forumBackend.applyUnInvolved(post);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    forumBackend.applyUnInvolved(postReply);
                });
            });
        }
    });
    $scope.loadMoreOnScroll = function() {
        if (!$scope.moreAvailable) {
            return;
        }
        if ($scope.isLoadingMore) {
            return;
        }
        $scope.isLoadingMore = true;
        forumBackend.getReportedPosts($scope.postData[$scope.postData.length - 1].Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                var postsData = data.PostArray;
                var dataLength = postsData.length;
                for (var i = 0; i < dataLength; i++) {
                    $scope.postData.push(postsData[i]);
                }
            }
            $scope.isLoadingMore = false;
        });
    };
}]);
angular.module('ccc-app').controller('forumContainerDeletedPostsCtrl', ['$rootScope', '$scope', 'forumBackend', 'forumPreLoadedData', 'totals', 'pageInfo', 'gModalService', 'cModalService', 'userManager', 'toastNotifications', function($rootScope, $scope, forumBackend, forumPreLoadedData, totals, pageInfo, gModalService, cModalService, userManager, toastNotifications) {
    totals.new('newPosts', 0);
    if (!totals.exists('totalPosts')) {
        totals.new('totalPosts', 0);
    }
    $scope.postData = [];
    $scope.moreAvailable = false;
    $scope.loadingInitialData = false;
    if (forumPreLoadedData.isPreloaded()) {
        $scope.moreAvailable = forumPreLoadedData.getMoreAvailable();
        $scope.postData = forumPreLoadedData.getPostsArray();
    } else {
        $scope.loadingInitialData = true;
        forumBackend.getDeletedPosts().success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                $scope.postData = data.PostArray;
                $scope.loadingInitialData = false;
            }
        });
    }
    $scope.pageInfo = pageInfo;
    $scope.isLoadingMore = false;
    $scope.userManager = userManager;
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewName) {
        $scope.changeView();
        $scope.loginChange();
    });
    $scope.loginChange = $rootScope.$on("LoginValueChange", function(event, newValue) {
        if (newValue == true) {
            var arrayOfCurrentItems = [];
            angular.forEach($scope.postData, function(post, key) {
                arrayOfCurrentItems.push(post.Id);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    arrayOfCurrentItems.push(postReply.Id);
                });
            });
            forumBackend.getInvolved(arrayOfCurrentItems).success(function(data) {
                var involvedInLocal = data.InvolvedIn;
                angular.forEach($scope.postData, function(post, key) {
                    forumBackend.applyInvolved(post, involvedInLocal);
                    angular.forEach(post.Replies, function(postReply, replyKey) {
                        forumBackend.applyInvolved(postReply, involvedInLocal);
                    });
                });
            });
        } else {
            angular.forEach($scope.postData, function(post, key) {
                forumBackend.applyUnInvolved(post);
                angular.forEach(post.Replies, function(postReply, replyKey) {
                    forumBackend.applyUnInvolved(postReply);
                });
            });
        }
    });
    $scope.loadMoreOnScroll = function() {
        if (!$scope.moreAvailable) {
            return;
        }
        if ($scope.isLoadingMore) {
            return;
        }
        $scope.isLoadingMore = true;
        forumBackend.getDeletedPosts($scope.postData[$scope.postData.length - 1].Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.moreAvailable = data.MoreAvailable;
                var postsData = data.PostArray;
                var dataLength = postsData.length;
                for (var i = 0; i < dataLength; i++) {
                    $scope.postData.push(postsData[i]);
                }
            }
            $scope.isLoadingMore = false;
        });
    };
}]);
angular.module('ccc-app').controller('forumPostCtrl', ['$scope', '$filter', 'forumBackend', 'cccLocalStorage', 'pageInfo', 'dateParsing', 'gModalService', 'cModalService', 'userManager', 'toastNotifications', function($scope, $filter, forumBackend, cccLocalStorage, pageInfo, dateParsing, gModalService, cModalService, userManager, toastNotifications) {
    $scope.DateParsing = dateParsing;
    $scope.canComment = true;
    $scope.isDeleting = false;
    $scope.isDeleted = false;
    if ($scope.post.hasOwnProperty("IsDeleted") && $scope.post.IsDeleted == 1) {
        $scope.isDeleted = true;
    };
    $scope.isMakingSticky = false;
    $scope.showCommentLine = false;
    $scope.userManager = userManager;
    $scope.linkToPost = document.URL;
    $scope.forumUrl = $scope.linkToPost;
    $scope.postCommentTextKey = 'post_comment_text_' + $scope.post.Id;
    $scope.post.commentText = cccLocalStorage.getText($scope.postCommentTextKey);
    $scope.draftSaved = new Date();
    $scope.post.inEditMode = false;
    $scope.post.isSavingEdit = false;
    $scope.saveCommentToLocalStorage = function() {
        if ($scope.post.commentText == undefined || $scope.post.commentText.length == 0) {
            cccLocalStorage.removeItem($scope.postCommentTextKey);
        } else {
            if ($scope.post.commentText !== cccLocalStorage.getText($scope.postCommentTextKey)) {
                if (cccLocalStorage.setItem($scope.postCommentTextKey, $scope.post.commentText)) {
                    $scope.draftSaved = new Date();
                }
            }
        }
    };
    $scope.postAgreeClick = function() {
        forumBackend.agree($scope.post.Id).success(function(data) {
            if (data.Response == "Success") {
                if (data.Type == 200) {
                    $scope.post.Actions.Agree.Total -= 1;
                    $scope.post.Actions.Agree.Involved = false;
                } else {
                    if ($scope.post.Actions.Disagree.Involved == true) {
                        $scope.post.Actions.Disagree.Total -= 1;
                        $scope.post.Actions.Disagree.Involved = false;
                    }
                    $scope.post.Actions.Agree.Total += 1;
                    $scope.post.Actions.Agree.Involved = true;
                    if ($scope.post.Notification == false && data["Notification"] == true) {
                        $scope.post.Notification = true;
                    }
                }
            } else if (data.Type == 1) {
                cModalService.showLoginModal("Please login or signup and you'll be able to agree with " + $scope.post.Cryptopian.Name + "'s post.");
            } else if (data.Type == 5) {
                cModalService.showActivationReminderModal();
            };
        });
    };
    $scope.showAgreeCryptopians = function() {
        if ($scope.post.Actions.Agree.Total > 0) {
            forumBackend.getAgreeCryptopians($scope.post.Id).success(function(data) {
                data.LoadMoreService = forumBackend;
                gModalService.showCryptopianList(data);
            });
        }
    };
    $scope.postDisagreeClick = function() {
        forumBackend.disagree($scope.post.Id).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 200) {
                    $scope.post.Actions.Disagree.Total -= 1;
                    $scope.post.Actions.Disagree.Involved = false;
                } else {
                    if ($scope.post.Actions.Agree.Involved == true) {
                        $scope.post.Actions.Agree.Total -= 1;
                        $scope.post.Actions.Agree.Involved = false;
                    }
                    $scope.post.Actions.Disagree.Total += 1;
                    $scope.post.Actions.Disagree.Involved = true;
                    if ($scope.post.Notification == false && data["Notification"] == true) {
                        $scope.post.Notification = true;
                    }
                }
            } else if (data.Type == 1) {
                cModalService.showLoginModal("Please login or signup and you'll be able to disagree with " + $scope.post.Cryptopian.Name + "'s post.");
            } else if (data.Type == 5) {
                cModalService.showActivationReminderModal();
            };
        });
    };
    $scope.showDisagreeCryptopians = function() {
        if ($scope.post.Actions.Disagree.Total > 0) {
            forumBackend.getDisagreeCryptopians($scope.post.Id).success(function(data) {
                data.LoadMoreService = forumBackend;
                gModalService.showCryptopianList(data);
            });
        }
    };
    $scope.postReportClick = function() {
        forumBackend.report($scope.post.Id).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 200) {
                    $scope.post.Actions.Report.Total -= 1;
                    $scope.post.Actions.Report.Involved = false;
                    toastNotifications.addNotification('success', 'This post has been succesfully un-reported!');
                } else {
                    $scope.post.Actions.Report.Total += 1;
                    $scope.post.Actions.Report.Involved = true;
                    toastNotifications.addNotification('warning', 'This post has been succesfully reported!');
                }
            } else if (data.Type == 1) {
                cModalService.showLoginModal("Please login or signup and you'll be able to report " + $scope.post.Cryptopian.Name + "'s post.");
            } else if (data.Type == 5) {
                cModalService.showActivationReminderModal();
            };
        });
    };
    $scope.makeStickyPostClick = function() {
        if ($scope.isMakingSticky) {
            return;
        }
        $scope.isMakingSticky = true;
        forumBackend.makeStickyPost($scope.post.Id).success(function(data) {
            if (data.Type == 100) {
                $scope.post.Sticky = data.Sticky;
                if ($scope.post.Sticky) {
                    toastNotifications.addNotification('success', 'This post has been succesfully made sticky!');
                } else {
                    toastNotifications.addNotification('success', 'This post is no longer sticky!');
                }
            } else {
                toastNotifications.addNotification('error', 'Action denied: ' + data["Message"]);
            }
            $scope.isMakingSticky = false;
        }).error(function() {
            $scope.isMakingSticky = false;
            toastNotifications.addNotification('error', 'We could not make this post sticky because there was an internal error!');
        });
    }
    $scope.deletePostClick = function() {
        if ($scope.isDeleting) {
            return;
        }
        $scope.isDeleting = true;
        forumBackend.deletePost($scope.post.Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.isDeleted = true;
                toastNotifications.addNotification('success', 'This post has been succesfully deleted');
            } else {
                toastNotifications.addNotification('error', 'We could not delete this post because: ' + data["Message"]);
            }
            $scope.isDeleting = false;
        }).error(function() {
            $scope.isDeleting = false;
            toastNotifications.addNotification('error', 'We could not delete this post because there was an internal error!');
        });
    };
    $scope.reverseDeletePostClick = function() {
        if ($scope.isDeleting) {
            return;
        }
        $scope.isDeleting = true;
        forumBackend.reverseDeletePost($scope.post.Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.isDeleted = false;
                toastNotifications.addNotification('success', 'This post has been succesfully un-deleted');
            } else {
                toastNotifications.addNotification('error', 'We could not un-delete this post because: ' + data["Message"]);
            }
            $scope.isDeleting = false;
        }).error(function() {
            $scope.isDeleting = false;
            toastNotifications.addNotification('error', 'We could not un-delete this post because there was an internal error!');
        });
    };
    $scope.postCommentClick = function() {
        if (!$scope.post.Actions.Comment.Involved) {
            if ($scope.post.Actions.Comment.Total > 0) {
                if (!$scope.post.hasOwnProperty("Replies")) {
                    forumBackend.getReplies($scope.post.ThreadId, $scope.post.Id).success(function(data) {
                        if (data["Response"] == "Success") {
                            $scope.post.Replies = data["ReplyArray"].reverse();
                            $scope.post.Actions.Comment.Involved = true;
                            if ($scope.post.Actions.Comment.Total > $scope.post.Replies.length) {
                                var leftToLoad = $scope.post.Actions.Comment.Total - $scope.post.Replies.length;
                                if (leftToLoad >= 50) {
                                    $scope.post.Actions.Comment.NextLoad = 50;
                                } else {
                                    $scope.post.Actions.Comment.NextLoad = leftToLoad;
                                }
                            } else {
                                $scope.post.Actions.Comment.NextLoad = 0;
                            }
                        }
                    });
                } else {
                    $scope.post.Actions.Comment.Involved = true;
                }
            } else {
                $scope.post.Replies = [];
                $scope.post.Actions.Comment.Involved = true;
                $scope.post.Actions.Comment.NextLoad = 0;
            }
        } else {
            $scope.post.Actions.Comment.Involved = false;
        }
    };
    $scope.commentLoadMoreClick = function() {
        if ($scope.post.Actions.Comment.Total > $scope.post.Replies.length) {
            forumBackend.getReplies($scope.post.ThreadId, $scope.post.Id, $scope.post.Replies[0].Id).success(function(data) {
                if (data["Response"] == "Success") {
                    var dataLength = data["ReplyArray"].length;
                    for (var i = 0; i < dataLength; i++) {
                        $scope.post.Replies.unshift(data["ReplyArray"][i]);
                    }
                    if ($scope.post.Actions.Comment.Total > $scope.post.Replies.length) {
                        var leftToLoad = $scope.post.Actions.Comment.Total - $scope.post.Replies.length;
                        if (leftToLoad >= 50) {
                            $scope.post.Actions.Comment.NextLoad = 50;
                        } else {
                            $scope.post.Actions.Comment.NextLoad = leftToLoad;
                        }
                    } else {
                        $scope.post.Actions.Comment.NextLoad = 0;
                    }
                }
            });
        }
    };
    $scope.addComment = function() {
        if (!$scope.post.commentText || $scope.post.commentText.trim() == "") {
            var message = {
                'Title': 'This comment appears to be blank...',
                'Body': 'It seems that you are trying to add an empty comment. Please write something and try to add the comment again.',
                'Type': 'warning'
            };
            gModalService.showMessageModal(message);
            return;
        }
        $scope.post.canComment = false;
        forumBackend.newComment($scope.post.ThreadId.toString(), $scope.post.commentText, $scope.post.Id.toString()).then(function successCallback(response) {
            var data = response.data;
            if (data["Response"] == "Success") {
                $scope.post.commentText = "";
                cccLocalStorage.removeItem($scope.postCommentTextKey);
                $scope.post.Replies.push(data["PostData"]);
                var extraMessage = '';
                if ($scope.post.Notification == false && data["PostData"]["Notification"] == true) {
                    $scope.post.Notification = true;
                    extraMessage = 'You will also receive email notifications for future comments.';
                }
                $scope.post.Actions.Comment.Total += 1;
                toastNotifications.addNotification('success', 'Your comment has been successfully added! ' + extraMessage);
            } else {
                if (data.Type == 1) {
                    cModalService.showLoginModal("Please login or signup and you'll be able to comment on " + $scope.post.Cryptopian.Name + "'s post.");
                }
                if (data.Type == 5) {
                    cModalService.showActivationReminderModal();
                };
            }
            $scope.post.canComment = true;
        }, function errorCallback(response) {
            var data = response.data;
            $scope.post.canComment = true;
            toastNotifications.addNotification('error', data["Message"]);
        });
    };
    $scope.postNotificationOnOffClick = function() {
        forumBackend.notificationOnOffClick($scope.post.Id).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 200) {
                    $scope.post.Notification = false;
                    toastNotifications.addNotification('success', 'You will NOT receive email notifications when someone comments on this post!');
                } else {
                    $scope.post.Notification = true;
                    toastNotifications.addNotification('success', 'You will now start receiving email notifications when someone comments on this post!');
                }
            } else if (data.Type == 1) {
                cModalService.showLoginModal("Please login or signup and you'll be able to start receiving email notifications with the comments on " + $scope.post.Cryptopian.Name + "'s post.");
            } else if (data.Type == 5) {
                cModalService.showActivationReminderModal();
            };
        });
    };
    $scope.enterEditMode = function() {
        if ($scope.post.inEditMode) {
            return
        };
        $scope.post.inEditMode = true;
        $scope.post.BodyEdit = angular.element('<textarea />').html($scope.post.Body.replace(/<br\/>/gi, "\n")).text();
    };
    $scope.cancelEditMode = function() {
        if (!$scope.post.inEditMode || $scope.post.isSavingEdit) {
            return
        };
        var forumPost = $scope.post;
        if (forumPost.BodyEdit == angular.element('<textarea />').html(forumPost.Body.replace(/<br\/>/gi, "\n")).text()) {
            forumPost.inEditMode = false;
            forumPost.BodyEdit = "";
            return;
        }
        var warning = {
            'Title': 'Confirm edit cancel',
            'Body': 'Are you sure you want to cancel your edits?',
            'Type': 'warning',
            'ShowOk': true,
            'OkAction': function() {
                forumPost.inEditMode = false;
                forumPost.BodyEdit = "";
            }
        };
        gModalService.showMessageModal(warning);
    };
    $scope.showPreviousEdits = function() {
        if (!$scope.post.Edited) {
            return;
        }
        forumBackend.getPastEdits($scope.post.Id.toString()).then(function(response) {
            if (response.status == 200) {
                var data = response.data;
                if (data["Response"] == "Success") {
                    forumBackend.showEditHistoryModal({
                        'originalItem': $scope.post,
                        'edits': data.EditHistory
                    });
                };
            }
        }, function(errorResponse) {});
    };
    $scope.savePostEdit = function() {
        if ($scope.post.BodyEdit == angular.element('<textarea />').html($scope.post.Body.replace(/<br\/>/gi, "\n")).text()) {
            $scope.post.inEditMode = false;
            $scope.post.BodyEdit = "";
            return;
        }
        $scope.post.isSavingEdit = true;
        forumBackend.editComment($scope.post.Id.toString(), $scope.post.BodyEdit).then(function(response) {
            if (response.status == 200) {
                var data = response.data;
                if (data["Response"] == "Success") {
                    $scope.post.BodyEdit = "";
                    $scope.post.Body = data["PostData"]["Body"];
                    var extraMessage = '';
                    $scope.post.Edited = true;
                    $scope.post.inEditMode = false;
                    toastNotifications.addNotification('success', 'Your post has been successfully edited! ');
                } else {
                    if (data.Type == 1) {
                        cModalService.showLoginModal("Please login or signup and you'll be able to edit your posts and comments.");
                    }
                    if (data.Type == 3) {
                        toastNotifications.addNotification('warning', 'You can only edit your posts and comments.');
                    }
                    if (data.Type == 4) {
                        toastNotifications.addNotification('warning', 'You can only edit your post up to 10 times. Contact support if you need help.');
                    };
                    if (data.Type == 5) {
                        cModalService.showActivationReminderModal();
                    };
                }
            } else {
                toastNotifications.addNotification('error', 'Your edit could not be saved. Please try again later.');
            }
            $scope.post.isSavingEdit = false;
        }, function(errorResponse) {
            $scope.post.isSavingEdit = false;
            toastNotifications.addNotification('error', 'Your edit could not be saved. Please try again later.');
        });
    };
    $scope.buildUrl = function() {
        var baseUrl = pageInfo.getBaseUrl();
        var documentType = pageInfo.getDocumentType();
        if (documentType == "Webpagehome" || documentType == "Webpageforumh" || documentType == "Webpagecryptopianprofile") {
            var baseHost = "";
            if (!location.origin) {
                baseHost = location.protocol + "//" + location.host;
            } else {
                baseHost = location.origin;
            }
            $scope.linkToPost = baseHost + $scope.post.Parent.Url.replace('/forum', '/') + 'post/p_' + $scope.post.Id;
            $scope.forumUrl = baseHost + $scope.post.Parent.Url.replace('/forum', '/') + 'forum';
        } else if ((documentType == "Webpagecoinp" || documentType == "Webpageexchangep") && baseUrl != "") {
            var baseHost = "";
            if (!location.origin) {
                baseHost = location.protocol + "//" + location.host;
            } else {
                baseHost = location.origin;
            }
            $scope.linkToPost = baseHost + baseUrl + 'post/p_' + $scope.post.Id;
            $scope.forumUrl = baseHost + baseUrl + 'forum';
        }
    };
    $scope.buildUrl();
    $scope.shareTwitter = function() {
        var url = "https://twitter.com/intent/tweet?text=";
        var hashTags = "%23CryptoCompare%20" + encodeURIComponent($scope.linkToPost);
        url += encodeURIComponent($filter('limitTo')($scope.post.Body, 90)) + "%20" + hashTags;
        var width = 600;
        var height = 400;
        var left = (screen.width / 2) - (width / 2);
        var top = (screen.height / 2) - (height / 2);
        var jsPopupDetails = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, height=' + height + ',width=' + width + ',top=' + top + ', left=' + left;
        newwindow = window.open(url, 'name', jsPopupDetails);
        if (window.focus) {
            newwindow.focus()
        }
        return false;
    };
    $scope.shareFacebook = function() {
        var url = "https://www.facebook.com/sharer/sharer.php?u=";
        url += encodeURIComponent($scope.linkToPost);
        var width = 600;
        var height = 400;
        var left = (screen.width / 2) - (width / 2);
        var top = (screen.height / 2) - (height / 2);
        var jsPopupDetails = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, height=' + height + ',width=' + width + ',top=' + top + ', left=' + left;
        newwindow = window.open(url, 'name', jsPopupDetails);
        if (window.focus) {
            newwindow.focus()
        }
        return false;
    };
    $scope.shareGooglePlus = function() {
        var url = "https://plus.google.com/share?url=";
        url += encodeURIComponent($scope.linkToPost);
        var width = 500;
        var height = 400;
        var left = (screen.width / 2) - (width / 2);
        var top = (screen.height / 2) - (height / 2);
        var jsPopupDetails = 'toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, height=' + height + ',width=' + width + ',top=' + top + ', left=' + left;
        newwindow = window.open(url, 'name', jsPopupDetails);
        if (window.focus) {
            newwindow.focus()
        }
        return false;
    };
}]);
angular.module('ccc-app').controller('forumPostReplyCtrl', ['$scope', 'forumBackend', 'dateParsing', 'gModalService', 'cModalService', 'userManager', 'toastNotifications', function($scope, forumBackend, dateParsing, gModalService, cModalService, userManager, toastNotifications) {
    $scope.isDeleting = false;
    $scope.isDeleted = false;
    $scope.userManager = userManager;
    $scope.DateParsing = dateParsing;
    $scope.reply.inEditMode = false;
    $scope.reply.isSavingEdit = false;
    $scope.commentAgreeClick = function() {
        forumBackend.agree($scope.reply.Id).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 200) {
                    $scope.reply.Actions.Agree.Total -= 1;
                    $scope.reply.Actions.Agree.Involved = false;
                } else {
                    if ($scope.reply.Actions.Disagree.Involved == true) {
                        $scope.reply.Actions.Disagree.Total -= 1;
                        $scope.reply.Actions.Disagree.Involved = false;
                    }
                    $scope.reply.Actions.Agree.Total += 1;
                    $scope.reply.Actions.Agree.Involved = true;
                }
            } else if (data.Type == 1) {
                cModalService.showLoginModal("Please login or signup and you'll be able to agree with " + $scope.reply.Cryptopian.Name + "'s comment.");
            } else if (data.Type == 5) {
                cModalService.showActivationReminderModal();
            };
        });
    };
    $scope.showAgreeCryptopians = function() {
        if ($scope.reply.Actions.Agree.Total > 0) {
            forumBackend.getAgreeCryptopians($scope.reply.Id).success(function(data) {
                data.LoadMoreService = forumBackend;
                gModalService.showCryptopianList(data);
            });
        }
    };
    $scope.commentDisagreeClick = function() {
        forumBackend.disagree($scope.reply.Id).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 200) {
                    $scope.reply.Actions.Disagree.Total -= 1;
                    $scope.reply.Actions.Disagree.Involved = false;
                } else {
                    if ($scope.reply.Actions.Agree.Involved == true) {
                        $scope.reply.Actions.Agree.Total -= 1;
                        $scope.reply.Actions.Agree.Involved = false;
                    }
                    $scope.reply.Actions.Disagree.Total += 1;
                    $scope.reply.Actions.Disagree.Involved = true;
                }
            } else if (data.Type == 1) {
                cModalService.showLoginModal("Please login or signup and you'll be able to disagree with " + $scope.reply.Cryptopian.Name + "'s comment.");
            } else if (data.Type == 5) {
                cModalService.showActivationReminderModal();
            };
        });
    };
    $scope.showDisagreeCryptopians = function() {
        if ($scope.reply.Actions.Disagree.Total > 0) {
            forumBackend.getDisagreeCryptopians($scope.reply.Id).success(function(data) {
                data.LoadMoreService = forumBackend;
                gModalService.showCryptopianList(data);
            });
        }
    };
    $scope.commentReportClick = function() {
        forumBackend.report($scope.reply.Id).success(function(data) {
            if (data["Response"] == "Success") {
                if (data.Type == 200) {
                    $scope.reply.Actions.Report.Total -= 1;
                    $scope.reply.Actions.Report.Involved = false;
                    toastNotifications.addNotification('success', 'This post has been succesfully un-reported!');
                } else {
                    $scope.reply.Actions.Report.Total += 1;
                    $scope.reply.Actions.Report.Involved = true;
                    toastNotifications.addNotification('warning', 'This post has been succesfully reported!');
                }
            } else if (data.Type == 1) {
                cModalService.showLoginModal();
            } else if (data.Type == 5) {
                cModalService.showActivationReminderModal();
            };
        });
    }
    $scope.deleteReplyClick = function() {
        if ($scope.isDeleting) {
            return;
        }
        $scope.isDeleting = true;
        forumBackend.deletePost($scope.reply.Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.isDeleted = true;
                toastNotifications.addNotification('success', 'This comment has been succesfully deleted');
            } else {
                toastNotifications.addNotification('error', 'We could not delete this comment because: ' + data["Message"]);
            }
            $scope.isDeleting = false;
        }).error(function() {
            $scope.isDeleting = false;
            toastNotifications.addNotification('error', 'We could not delete this comment because there was an internal error!');
        });
    };
    $scope.reverseDeleteReplyClick = function() {
        if ($scope.isDeleting) {
            return;
        }
        $scope.isDeleting = true;
        forumBackend.reverseDeletePost($scope.reply.Id).success(function(data) {
            if (data["Response"] == "Success") {
                $scope.isDeleted = false;
                toastNotifications.addNotification('success', 'This comment has been succesfully un-deleted');
            } else {
                toastNotifications.addNotification('error', 'We could not un-delete this comment because: ' + data["Message"]);
            }
            $scope.isDeleting = false;
        }).error(function() {
            $scope.isDeleting = false;
            toastNotifications.addNotification('error', 'We could not un-delete this comment because there was an internal error!');
        });
    };
    $scope.enterEditMode = function() {
        if ($scope.reply.inEditMode) {
            return
        };
        $scope.reply.inEditMode = true;
        $scope.reply.BodyEdit = angular.element('<textarea />').html($scope.reply.Body.replace(/<br\/>/gi, "\n")).text();
    };
    $scope.cancelEditMode = function() {
        if (!$scope.reply.inEditMode || $scope.reply.isSavingEdit) {
            return
        };
        var forumReply = $scope.reply;
        if (forumReply.BodyEdit == angular.element('<textarea />').html(forumReply.Body.replace(/<br\/>/gi, "\n")).text()) {
            forumReply.inEditMode = false;
            forumReply.BodyEdit = "";
            return;
        }
        var warning = {
            'Title': 'Confirm edit cancel',
            'Body': 'Are you sure you want to cancel your edits?',
            'Type': 'warning',
            'ShowOk': true,
            'OkAction': function() {
                forumReply.inEditMode = false;
                forumReply.BodyEdit = "";
            }
        };
        gModalService.showMessageModal(warning);
    };
    $scope.showPreviousEdits = function() {
        if (!$scope.reply.Edited) {
            return;
        }
        forumBackend.getPastEdits($scope.reply.Id.toString()).then(function(response) {
            if (response.status == 200) {
                var data = response.data;
                if (data["Response"] == "Success") {
                    forumBackend.showEditHistoryModal({
                        'originalItem': $scope.reply,
                        'edits': data.EditHistory
                    });
                };
            }
        }, function(errorResponse) {});
    };
    $scope.savePostEdit = function() {
        if ($scope.reply.BodyEdit == angular.element('<textarea />').html($scope.reply.Body.replace(/<br\/>/gi, "\n")).text()) {
            $scope.reply.inEditMode = false;
            $scope.reply.BodyEdit = "";
            return;
        }
        $scope.reply.isSavingEdit = true;
        forumBackend.editComment($scope.reply.Id.toString(), $scope.reply.BodyEdit).then(function(response) {
            if (response.status == 200) {
                var data = response.data;
                if (data["Response"] == "Success") {
                    $scope.reply.BodyEdit = "";
                    $scope.reply.Body = data["PostData"]["Body"];
                    $scope.reply.Edited = true;
                    $scope.reply.inEditMode = false;
                    toastNotifications.addNotification('success', 'Your comment has been successfully edited! ');
                } else {
                    if (data.Type == 1) {
                        cModalService.showLoginModal("Please login or signup and you'll be able to edit your posts and comments.");
                    }
                    if (data.Type == 3) {
                        toastNotifications.addNotification('warning', 'You can only edit your posts and comments.');
                    }
                    if (data.Type == 4) {
                        toastNotifications.addNotification('warning', 'You can only edit your comment up to 10 times. Contact support if you need help.');
                    };
                    if (data.Type == 5) {
                        cModalService.showActivationReminderModal();
                    };
                }
            } else {
                toastNotifications.addNotification('error', 'Your edit could not be saved. Please try again later.');
            }
            $scope.reply.isSavingEdit = false;
        }, function(errorResponse) {
            $scope.reply.isSavingEdit = false;
            toastNotifications.addNotification('error', 'Your edit could not be saved. Please try again later.');
        });
    };
}]);
angular.module('ccc-app').controller('showEditHistoryCtrl', ['$scope', '$modalInstance', 'dateParsing', 'data', function($scope, $modalInstance, dateParsing, data) {
    $scope.DateParsing = dateParsing;
    $scope.originalItem = data.originalItem;
    $scope.edits = data.edits;
    $scope.cancel = function() {
        $modalInstance.dismiss('Cancel');
    };
}]);;;;
angular.module('ccc-app').directive('forumContainer', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/container.html',
        controller: 'forumContainerCtrl',
        scope: {
            tposts: '=',
            loadmore: '='
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumContainerNoNew', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/container-no-new.html',
        controller: 'forumContainerNoNewCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumContainerSinglePost', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/container-single-post.html',
        controller: 'forumContainerSinglePostCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumContainerLatestPosts', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/container-latest-posts.html',
        controller: 'forumContainerLatestPostsCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumContainerReportedPosts', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/container-reported-posts.html',
        controller: 'forumContainerReportedPostsCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumContainerDeletedPosts', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/container-deleted-posts.html',
        controller: 'forumContainerDeletedPostsCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumContainerByCryptopian', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/container-by-cryptopian.html',
        controller: 'forumContainerByCryptopianCtrl',
        scope: {
            showDeletedPosts: "="
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumPost', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/post.html',
        controller: 'forumPostCtrl',
        scope: {
            post: "="
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumPostReply', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/post-reply.html',
        controller: 'forumPostReplyCtrl',
        scope: {
            reply: "=",
            hideAuthorInfo: "=hideauthorinfo"
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumPostNoReply', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/post-no-reply.html',
        controller: 'forumPostCtrl',
        scope: {
            post: "="
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('forumPostActivityStream', function() {
    return {
        restrict: 'E',
        templateUrl: 'forum/post-activity-stream.html',
        controller: 'forumPostCtrl',
        scope: {
            post: "="
        },
        link: function(scope, element, attrs) {}
    };
});;;;
angular.module('ccc-app').controller('SubDependentRoutesCtrl', ['$scope', '$state', 'subscriptionManager', 'pageInfo', function($scope, $state, subscriptionManager, pageInfo) {
    $scope.isICOStage = pageInfo.isICOStage();
    $scope.globalPageTitle = pageInfo.getH1Text();
    $scope.thereIsData = subscriptionManager.hasSubs();
}]);
angular.module('ccc-app').config(function($stateProvider, $urlRouterProvider, $locationProvider) {
    $urlRouterProvider.otherwise('/overview');
    $locationProvider.html5Mode(true);
    $stateProvider.state('overview', {
        url: '/overview',
        templateUrl: '/angular/coin/overview',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'InitialTitle',
        seoDescription: 'InitialDescription'
    }).state('overview.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/overview',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'InitialTitle',
        seoDescription: 'InitialDescription'
    }).state('analysis', {
        url: '/analysis',
        templateUrl: '/angular/coin/analysis',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Money flow, trading volume by exchange and total volume over time.',
        seoDescription: 'Compare and analyze the {{currencyPair}} volume split over multiple exchanges and trading pairs. Spot trading patterns and improve your {{currencyPair}} trading skills.'
    }).state('analysis.currency', {
        url: '/:Symbol?type&period',
        templateUrl: '/angular/coin/analysis',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Money flow, trading volume by exchange and total volume over time.',
        seoDescription: 'Compare and analyze the {{currencyPair}} volume split over multiple exchanges and trading pairs. Spot trading patterns and improve your {{currencyPair}} trading skills.'
    }).state('markets', {
        url: '/markets',
        templateUrl: '/angular/coin/markets',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Live streaming exchange prices, percentage change, volumes, open, high, low and latest trades',
        seoDescription: 'Live streaming {{currencyPair}} trading data from all the major exchanges. Watch the latest {{currencyPair}} price changes in real time and be the first to react to market volatility.'
    }).state('markets.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/markets',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Live streaming exchange prices, percentage change, volumes, open, high, low and latest trades',
        seoDescription: 'Live streaming {{currencyPair}} trading data from all the major exchanges. Watch the latest {{currencyPair}} price changes in real time and be the first to react to market volatility.'
    }).state('charts', {
        url: '/charts',
        templateUrl: '/angular/coin/charts',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Historical chart, social data chart and multiple chart indicators',
        seoDescription: 'The CryptoCompare {{currencyPair}} historical trading charts make it easy to spot trading patterns. Use our price, volume, social and volatility indicators to make better informed {{currencyPair}} trades.'
    }).state('charts.currency', {
        url: '/:Symbol?t&p&fTs&tTs&ci1&ci2&ci3&bc&si',
        templateUrl: '/angular/coin/charts',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Historical OHLC chart, social data chart and multiple chart indicators',
        seoDescription: 'The CryptoCompare {{currencyPair}} historical trading charts make it easy to spot trading patterns. Use our price, volume, social and volatility indicators to make better informed {{currencyPair}} trades.'
    }).state('mining', {
        url: '/mining',
        templateUrl: '/angular/coin/mining',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Mining equipment, latest mining rigs and mining contracts',
        seoDescription: 'Compare the {{currencyPair}} mining equipment and mining contracts. Buy and sell {{currencyPair}} mining equipment and mining contracts.'
    }).state('mining.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/mining',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Mining equipment, latest mining rigs and mining contracts',
        seoDescription: 'Compare the {{currencyPair}} mining equipment and mining contracts. Buy and sell {{currencyPair}} mining equipment and mining contracts.'
    }).state('trades', {
        url: '/trades',
        templateUrl: '/angular/coin/trades',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest streaming trades from multiple exchanges, live trade data',
        seoDescription: 'Streaming {{currencyPair}} trades from all the available exchanges. Watch {{currencyPair}} trades as they happen and see if your latest trade has been recorded correctly.'
    }).state('trades.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/trades',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest streaming trades from multiple exchanges, live trade data',
        seoDescription: 'Streaming {{currencyPair}} trades from all the available exchanges. Watch {{currencyPair}} trades as they happen and see if your latest trade has been recorded correctly.'
    }).state('orderbook', {
        url: '/orderbook',
        templateUrl: '/angular/coin/orderbook',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest streaming orders from multiple exchanges, live orderbook data',
        seoDescription: 'Streaming {{currencyPair}} orderbook from all the available exchanges. Watch {{currencyPair}} orders as they happen and see if there is any arbitrage opportunity.'
    }).state('orderbook.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/orderbook',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest streaming orders from multiple exchanges, live orderbook data',
        seoDescription: 'Streaming {{currencyPair}} orderbook from all the available exchanges. Watch {{currencyPair}} orders as they happen and see if there is any arbitrage opportunity.'
    }).state('forum', {
        url: '/forum',
        templateUrl: '/angular/coin/forum',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest forum, price, development and general discussion',
        seoDescription: 'Join the {{currencyPair}} discussion forum and get the latest news and price movement analysis. Chat with like-minded {{currencyPair}} enthusiasts and share your trading strategies.'
    }).state('forum.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/forum',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest forum, price, development and general discussion',
        seoDescription: 'Join the {{currencyPair}} discussion forum and get the latest news and price movement analysis. Chat with like-minded {{currencyPair}} enthusiasts and share your trading strategies.'
    }).state('post', {
        url: '/post',
        templateUrl: '/angular/coin/post',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest forum discussion, price updates and news',
        seoDescription: 'Track this individual {{currencyPair}} discussion thread. Comment and get involved in this {{currencyPair}} topic.'
    }).state('post.postid', {
        url: '/:PostId',
        templateUrl: '/angular/coin/post',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest forum discussion, price updates and news',
        seoDescription: 'Track this individual {{currencyPair}} discussion thread. Comment and get involved in this {{currencyPair}} topic.'
    }).state('post.postid.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/post',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Latest forum discussion, price updates and news',
        seoDescription: 'Track this individual {{currencyPair}} discussion thread. Comment and get involved in this {{currencyPair}} topic.'
    }).state('influence', {
        url: '/influence',
        templateUrl: '/angular/coin/influence',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Social and development stats from CryptoCompare, Reddit, Twitter, Facebook and code repository (GitHub, BitBucket) accounts.',
        seoDescription: 'Analyze and compare {{currencyPair}} social influence across a wide range of social channels. Track the development and social activity of {{currencyPair}} and make informed trading decisions.'
    }).state('influence.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/influence',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Social and development stats from CryptoCompare, Reddit, Twitter, Facebook and code repository (GitHub, BitBucket) accounts.',
        seoDescription: 'Analyze and compare {{currencyPair}} social influence across a wide range of social channels. Track the development and social activity of {{currencyPair}} and make informed trading decisions.'
    }).state('timeline', {
        url: '/timeline',
        templateUrl: '/angular/coin/timeline',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Timeline data of important events. Highest and lowest (monthly, yearly and all time) price , volume, weekly volume and monthly volume.',
        seoDescription: 'Analyze and compare {{currencyPair}} events from price and volume events to user generated events. Track the important activity on {{currencyPair}} and make informed trading decisions.'
    }).state('timeline.currency', {
        url: '/:Symbol',
        templateUrl: '/angular/coin/timeline',
        controller: 'SubDependentRoutesCtrl',
        seoTitle: 'Timeline data of important events. Highest and lowest (monthly, yearly and all time) price , volume, weekly volume and monthly volume.',
        seoDescription: 'Analyze and compare {{currencyPair}} events from price and volume events to user generated events. Track the important activity on {{currencyPair}} and make informed trading decisions.'
    })
});;;;
(function() {
    var d;
    window.AmCharts ? d = window.AmCharts : (d = {}, window.AmCharts = d, d.themes = {}, d.maps = {}, d.inheriting = {}, d.charts = [], d.onReadyArray = [], d.useUTC = !1, d.updateRate = 30, d.uid = 0, d.lang = {}, d.translations = {}, d.mapTranslations = {}, d.windows = {}, d.initHandlers = []);
    d.Class = function(a) {
        var b = function() {
            arguments[0] !== d.inheriting && (this.events = {}, this.construct.apply(this, arguments))
        };
        a.inherits ? (b.prototype = new a.inherits(d.inheriting), b.base = a.inherits.prototype, delete a.inherits) : (b.prototype.createEvents = function() {
            for (var a = 0, b = arguments.length; a < b; a++) this.events[arguments[a]] = []
        }, b.prototype.listenTo = function(a, b, c) {
            this.removeListener(a, b, c);
            a.events[b].push({
                handler: c,
                scope: this
            })
        }, b.prototype.addListener = function(a, b, c) {
            this.removeListener(this, a, b);
            this.events[a].push({
                handler: b,
                scope: c
            })
        }, b.prototype.removeListener = function(a, b, c) {
            if (a && a.events)
                for (a = a.events[b], b = a.length - 1; 0 <= b; b--) a[b].handler === c && a.splice(b, 1)
        }, b.prototype.fire = function(a, b) {
            for (var c = this.events[a], d = 0, k = c.length; d < k; d++) {
                var l = c[d];
                l.handler.call(l.scope, b)
            }
        });
        for (var c in a) b.prototype[c] = a[c];
        return b
    };
    d.addChart = function(a) {
        d.updateInt || (d.updateInt = setInterval(function() {
            d.update()
        }, Math.round(1E3 / d.updateRate)));
        d.charts.push(a)
    };
    d.removeChart = function(a) {
        for (var b = d.charts, c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1);
        0 === b.length && d.updateInt && (clearInterval(d.updateInt), d.updateInt = NaN)
    };
    d.isModern = !0;
    d.getIEVersion = function() {
        var a = 0,
            b, c;
        "Microsoft Internet Explorer" == navigator.appName && (b = navigator.userAgent, c = /MSIE ([0-9]{1,}[.0-9]{0,})/, null !== c.exec(b) && (a = parseFloat(RegExp.$1)));
        return a
    };
    d.applyLang = function(a, b) {
        var c = d.translations;
        b.dayNames = d.extend({}, d.dayNames);
        b.shortDayNames = d.extend({}, d.shortDayNames);
        b.monthNames = d.extend({}, d.monthNames);
        b.shortMonthNames = d.extend({}, d.shortMonthNames);
        c && (c = c[a]) && (d.lang = c, c.monthNames && (b.dayNames = d.extend({}, c.dayNames), b.shortDayNames = d.extend({}, c.shortDayNames), b.monthNames = d.extend({}, c.monthNames), b.shortMonthNames = d.extend({}, c.shortMonthNames)))
    };
    d.IEversion = d.getIEVersion();
    9 > d.IEversion && 0 < d.IEversion && (d.isModern = !1, d.isIE = !0);
    d.dx = 0;
    d.dy = 0;
    if (document.addEventListener || window.opera) d.isNN = !0, d.isIE = !1, d.dx = .5, d.dy = .5;
    document.attachEvent && (d.isNN = !1, d.isIE = !0, d.isModern || (d.dx = 0, d.dy = 0));
    window.chrome && (d.chrome = !0);
    d.handleMouseUp = function(a) {
        for (var b = d.charts, c = 0; c < b.length; c++) {
            var e = b[c];
            e && e.handleReleaseOutside && e.handleReleaseOutside(a)
        }
    };
    d.handleMouseMove = function(a) {
        for (var b = d.charts, c = 0; c < b.length; c++) {
            var e = b[c];
            e && e.handleMouseMove && e.handleMouseMove(a)
        }
    };
    d.handleWheel = function(a) {
        for (var b = d.charts, c = 0; c < b.length; c++) {
            var e = b[c];
            if (e && e.mouseIsOver) {
                e.mouseWheelScrollEnabled || e.mouseWheelZoomEnabled ? e.handleWheel && e.handleWheel(a) : a.stopPropagation && a.stopPropagation();
                break
            }
        }
    };
    d.resetMouseOver = function() {
        for (var a = d.charts, b = 0; b < a.length; b++) {
            var c = a[b];
            c && (c.mouseIsOver = !1)
        }
    };
    d.ready = function(a) {
        d.onReadyArray.push(a)
    };
    d.handleLoad = function() {
        d.isReady = !0;
        for (var a = d.onReadyArray, b = 0; b < a.length; b++) {
            var c = a[b];
            isNaN(d.processDelay) ? c() : setTimeout(c, d.processDelay * b)
        }
    };
    d.addInitHandler = function(a, b) {
        d.initHandlers.push({
            method: a,
            types: b
        })
    };
    d.callInitHandler = function(a) {
        var b = d.initHandlers;
        if (d.initHandlers)
            for (var c = 0; c < b.length; c++) {
                var e = b[c];
                e.types ? d.isInArray(e.types, a.type) && e.method(a) : e.method(a)
            }
    };
    d.getUniqueId = function() {
        d.uid++;
        return "AmChartsEl-" + d.uid
    };
    d.isNN && (document.addEventListener("mousemove", d.handleMouseMove, !0), document.addEventListener("mouseup", d.handleMouseUp, !0), window.addEventListener("load", d.handleLoad, !0), window.addEventListener("DOMMouseScroll", d.handleWheel, !0), document.addEventListener("mousewheel", d.handleWheel, !0));
    d.isIE && (document.attachEvent("onmousemove", d.handleMouseMove), document.attachEvent("onmouseup", d.handleMouseUp), window.attachEvent("onload", d.handleLoad));
    d.clear = function() {
        var a = d.charts;
        if (a)
            for (var b = a.length - 1; 0 <= b; b--) a[b].clear();
        d.updateInt && clearInterval(d.updateInt);
        d.charts = [];
        d.isNN && (document.removeEventListener("mousemove", d.handleMouseMove, !0), document.removeEventListener("mouseup", d.handleMouseUp, !0), window.removeEventListener("load", d.handleLoad, !0), window.removeEventListener("DOMMouseScroll", d.handleWheel, !0), document.removeEventListener("mousewheel", d.handleWheel, !0));
        d.isIE && (document.detachEvent("onmousemove", d.handleMouseMove), document.detachEvent("onmouseup", d.handleMouseUp), window.detachEvent("onload", d.handleLoad))
    };
    d.makeChart = function(a, b, c) {
        var e = b.type,
            h = b.theme;
        d.isString(h) && (h = d.themes[h], b.theme = h);
        var f;
        switch (e) {
            case "serial":
                f = new d.AmSerialChart(h);
                break;
            case "xy":
                f = new d.AmXYChart(h);
                break;
            case "pie":
                f = new d.AmPieChart(h);
                break;
            case "radar":
                f = new d.AmRadarChart(h);
                break;
            case "gauge":
                f = new d.AmAngularGauge(h);
                break;
            case "funnel":
                f = new d.AmFunnelChart(h);
                break;
            case "map":
                f = new d.AmMap(h);
                break;
            case "stock":
                f = new d.AmStockChart(h);
                break;
            case "gantt":
                f = new d.AmGanttChart(h)
        }
        d.extend(f, b);
        if (b.listeners)
            for (var g in b.listeners) e = b.listeners[g], f.addListener(e.event, e.method);
        d.isReady ? isNaN(c) ? f.write(a) : setTimeout(function() {
            d.realWrite(f, a)
        }, c) : d.ready(function() {
            isNaN(c) ? f.write(a) : setTimeout(function() {
                d.realWrite(f, a)
            }, c)
        });
        return f
    };
    d.realWrite = function(a, b) {
        a.write(b)
    };
    d.updateCount = 0;
    d.validateAt = Math.round(d.updateRate / 5);
    d.update = function() {
        var a = d.charts;
        d.updateCount++;
        var b = !1;
        d.updateCount == d.validateAt && (b = !0, d.updateCount = 0);
        if (a)
            for (var c = 0; c < a.length; c++) a[c].update && a[c].update(), b && a[c].autoResize && a[c].validateSize && a[c].validateSize()
    };
    d.bezierX = 3;
    d.bezierY = 6
})();
(function() {
    var d = window.AmCharts;
    d.toBoolean = function(a, b) {
        if (void 0 === a) return b;
        switch (String(a).toLowerCase()) {
            case "true":
            case "yes":
            case "1":
                return !0;
            case "false":
            case "no":
            case "0":
            case null:
                return !1;
            default:
                return Boolean(a)
        }
    };
    d.removeFromArray = function(a, b) {
        var c;
        if (void 0 !== b && void 0 !== a)
            for (c = a.length - 1; 0 <= c; c--) a[c] == b && a.splice(c, 1)
    };
    d.getPath = function() {
        var a = document.getElementsByTagName("script");
        if (a)
            for (var b = 0; b < a.length; b++) {
                var c = a[b].src;
                if (-1 !== c.search(/\/(amcharts|ammap)\.js/)) return c.replace(/\/(amcharts|ammap)\.js.*/, "/")
            }
    };
    d.normalizeUrl = function(a) {
        return "" !== a && -1 === a.search(/\/$/) ? a + "/" : a
    };
    d.isAbsolute = function(a) {
        return 0 === a.search(/^http[s]?:|^\//)
    };
    d.isInArray = function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (a[c] == b) return !0;
        return !1
    };
    d.getDecimals = function(a) {
        var b = 0;
        isNaN(a) || (a = String(a), -1 != a.indexOf("e-") ? b = Number(a.split("-")[1]) : -1 != a.indexOf(".") && (b = a.split(".")[1].length));
        return b
    };
    d.wordwrap = function(a, b, c, e) {
        var h, f, g, k;
        a += "";
        if (1 > b) return a;
        h = -1;
        for (a = (k = a.split(/\r\n|\n|\r/)).length; ++h < a; k[h] += g) {
            g = k[h];
            for (k[h] = ""; g.length > b; k[h] += d.trim(g.slice(0, f)) + ((g = g.slice(f)).length ? c : "")) f = 2 == e || (f = g.slice(0, b + 1).match(/\S*(\s)?$/))[1] ? b : f.input.length - f[0].length || 1 == e && b || f.input.length + (f = g.slice(b).match(/^\S*/))[0].length;
            g = d.trim(g)
        }
        return k.join(e)
    };
    d.trim = function(a) {
        return a.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
    };
    d.wrappedText = function(a, b, c, e, h, f, g, k) {
        var l = d.text(a, b, c, e, h, f, g);
        if (l) {
            var m = l.getBBox();
            if (m.width > k) {
                var n = "\n";
                d.isModern || (n = "<br>");
                k = Math.floor(k / (m.width / b.length));
                2 < k && (k -= 2);
                b = d.wordwrap(b, k, n, !0);
                l.remove();
                l = d.text(a, b, c, e, h, f, g)
            }
        }
        return l
    };
    d.getStyle = function(a, b) {
        var c = "";
        document.defaultView && document.defaultView.getComputedStyle ? c = document.defaultView.getComputedStyle(a, "").getPropertyValue(b) : a.currentStyle && (b = b.replace(/\-(\w)/g, function(a, b) {
            return b.toUpperCase()
        }), c = a.currentStyle[b]);
        return c
    };
    d.removePx = function(a) {
        if (void 0 !== a) return Number(a.substring(0, a.length - 2))
    };
    d.getURL = function(a, b) {
        if (a)
            if ("_self" != b && b)
                if ("_top" == b && window.top) window.top.location.href = a;
                else if ("_parent" == b && window.parent) window.parent.location.href = a;
        else if ("_blank" == b) window.open(a);
        else {
            var c = document.getElementsByName(b)[0];
            c ? c.src = a : (c = d.windows[b]) ? c.opener && !c.opener.closed ? c.location.href = a : d.windows[b] = window.open(a) : d.windows[b] = window.open(a)
        } else window.location.href = a
    };
    d.ifArray = function(a) {
        return a && "object" == typeof a && 0 < a.length ? !0 : !1
    };
    d.callMethod = function(a, b) {
        var c;
        for (c = 0; c < b.length; c++) {
            var e = b[c];
            if (e) {
                if (e[a]) e[a]();
                var h = e.length;
                if (0 < h) {
                    var d;
                    for (d = 0; d < h; d++) {
                        var g = e[d];
                        if (g && g[a]) g[a]()
                    }
                }
            }
        }
    };
    d.toNumber = function(a) {
        return "number" == typeof a ? a : Number(String(a).replace(/[^0-9\-.]+/g, ""))
    };
    d.toColor = function(a) {
        if ("" !== a && void 0 !== a)
            if (-1 != a.indexOf(",")) {
                a = a.split(",");
                var b;
                for (b = 0; b < a.length; b++) {
                    var c = a[b].substring(a[b].length - 6, a[b].length);
                    a[b] = "#" + c
                }
            } else a = a.substring(a.length - 6, a.length), a = "#" + a;
        return a
    };
    d.toCoordinate = function(a, b, c) {
        var e;
        void 0 !== a && (a = String(a), c && c < b && (b = c), e = Number(a), -1 != a.indexOf("!") && (e = b - Number(a.substr(1))), -1 != a.indexOf("%") && (e = b * Number(a.substr(0, a.length - 1)) / 100));
        return e
    };
    d.fitToBounds = function(a, b, c) {
        a < b && (a = b);
        a > c && (a = c);
        return a
    };
    d.isDefined = function(a) {
        return void 0 === a ? !1 : !0
    };
    d.stripNumbers = function(a) {
        return a.replace(/[0-9]+/g, "")
    };
    d.roundTo = function(a, b) {
        if (0 > b) return a;
        var c = Math.pow(10, b);
        return Math.round(a * c) / c
    };
    d.toFixed = function(a, b) {
        var c = String(Math.round(a * Math.pow(10, b)));
        if (0 < b) {
            var e = c.length;
            if (e < b) {
                var h;
                for (h = 0; h < b - e; h++) c = "0" + c
            }
            e = c.substring(0, c.length - b);
            "" === e && (e = 0);
            return e + "." + c.substring(c.length - b, c.length)
        }
        return String(c)
    };
    d.formatDuration = function(a, b, c, e, h, f) {
        var g = d.intervals,
            k = f.decimalSeparator;
        if (a >= g[b].contains) {
            var l = a - Math.floor(a / g[b].contains) * g[b].contains;
            "ss" == b ? (l = d.formatNumber(l, f), 1 == l.split(k)[0].length && (l = "0" + l)) : l = d.roundTo(l, f.precision);
            ("mm" == b || "hh" == b) && 10 > l && (l = "0" + l);
            c = l + "" + e[b] + "" + c;
            a = Math.floor(a / g[b].contains);
            b = g[b].nextInterval;
            return d.formatDuration(a, b, c, e, h, f)
        }
        "ss" == b && (a = d.formatNumber(a, f), 1 == a.split(k)[0].length && (a = "0" +
            a));
        ("mm" == b || "hh" == b) && 10 > a && (a = "0" + a);
        c = a + "" + e[b] + "" + c;
        if (g[h].count > g[b].count)
            for (a = g[b].count; a < g[h].count; a++) b = g[b].nextInterval, "ss" == b || "mm" == b || "hh" == b ? c = "00" + e[b] + "" + c : "DD" == b && (c = "0" + e[b] + "" + c);
        ":" == c.charAt(c.length - 1) && (c = c.substring(0, c.length - 1));
        return c
    };
    d.formatNumber = function(a, b, c, e, h) {
        a = d.roundTo(a, b.precision);
        isNaN(c) && (c = b.precision);
        var f = b.decimalSeparator;
        b = b.thousandsSeparator;
        var g;
        g = 0 > a ? "-" : "";
        a = Math.abs(a);
        var k = String(a),
            l = !1; - 1 != k.indexOf("e") && (l = !0);
        0 <= c && !l && (k = d.toFixed(a, c));
        var m = "";
        if (l) m = k;
        else {
            var k = k.split("."),
                l = String(k[0]),
                n;
            for (n = l.length; 0 <= n; n -= 3) m = n != l.length ? 0 !== n ? l.substring(n - 3, n) + b + m : l.substring(n - 3, n) + m : l.substring(n - 3, n);
            void 0 !== k[1] && (m = m + f + k[1]);
            void 0 !== c && 0 < c && "0" != m && (m = d.addZeroes(m, f, c))
        }
        m = g + m;
        "" === g && !0 === e && 0 !== a && (m = "+" + m);
        !0 === h && (m += "%");
        return m
    };
    d.addZeroes = function(a, b, c) {
        a = a.split(b);
        void 0 === a[1] && 0 < c && (a[1] = "0");
        return a[1].length < c ? (a[1] += "0", d.addZeroes(a[0] + b + a[1], b, c)) : void 0 !== a[1] ? a[0] + b + a[1] : a[0]
    };
    d.scientificToNormal = function(a) {
        var b;
        a = String(a).split("e");
        var c;
        if ("-" == a[1].substr(0, 1)) {
            b = "0.";
            for (c = 0; c < Math.abs(Number(a[1])) - 1; c++) b += "0";
            b += a[0].split(".").join("")
        } else {
            var e = 0;
            b = a[0].split(".");
            b[1] && (e = b[1].length);
            b = a[0].split(".").join("");
            for (c = 0; c < Math.abs(Number(a[1])) - e; c++) b += "0"
        }
        return b
    };
    d.toScientific = function(a, b) {
        if (0 === a) return "0";
        var c = Math.floor(Math.log(Math.abs(a)) * Math.LOG10E),
            e = String(e).split(".").join(b);
        return String(e) + "e" + c
    };
    d.randomColor = function() {
        return "#" + ("00000" + (16777216 * Math.random() << 0).toString(16)).substr(-6)
    };
    d.hitTest = function(a, b, c) {
        var e = !1,
            h = a.x,
            f = a.x + a.width,
            g = a.y,
            k = a.y + a.height,
            l = d.isInRectangle;
        e || (e = l(h, g, b));
        e || (e = l(h, k, b));
        e || (e = l(f, g, b));
        e || (e = l(f, k, b));
        e || !0 === c || (e = d.hitTest(b, a, !0));
        return e
    };
    d.isInRectangle = function(a, b, c) {
        return a >= c.x - 5 && a <= c.x + c.width + 5 && b >= c.y - 5 && b <= c.y + c.height + 5 ? !0 : !1
    };
    d.isPercents = function(a) {
        if (-1 != String(a).indexOf("%")) return !0
    };
    d.findPosX = function(a) {
        var b = a,
            c = a.offsetLeft;
        if (a.offsetParent) {
            for (; a = a.offsetParent;) c += a.offsetLeft;
            for (;
                (b = b.parentNode) && b != document.body;) c -= b.scrollLeft || 0
        }
        return c
    };
    d.findPosY = function(a) {
        var b = a,
            c = a.offsetTop;
        if (a.offsetParent) {
            for (; a = a.offsetParent;) c += a.offsetTop;
            for (;
                (b = b.parentNode) && b != document.body;) c -= b.scrollTop || 0
        }
        return c
    };
    d.findIfFixed = function(a) {
        if (a.offsetParent)
            for (; a = a.offsetParent;)
                if ("fixed" == d.getStyle(a, "position")) return !0;
        return !1
    };
    d.findIfAuto = function(a) {
        return a.style && "auto" == d.getStyle(a, "overflow") ? !0 : a.parentNode ? d.findIfAuto(a.parentNode) : !1
    };
    d.findScrollLeft = function(a, b) {
        a.scrollLeft && (b += a.scrollLeft);
        return a.parentNode ? d.findScrollLeft(a.parentNode, b) : b
    };
    d.findScrollTop = function(a, b) {
        a.scrollTop && (b += a.scrollTop);
        return a.parentNode ? d.findScrollTop(a.parentNode, b) : b
    };
    d.formatValue = function(a, b, c, e, h, f, g, k) {
        if (b) {
            void 0 === h && (h = "");
            var l;
            for (l = 0; l < c.length; l++) {
                var m = c[l],
                    n = b[m];
                void 0 !== n && (n = f ? d.addPrefix(n, k, g, e) : d.formatNumber(n, e), a = a.replace(new RegExp("\\[\\[" + h + "" + m + "\\]\\]", "g"), n))
            }
        }
        return a
    };
    d.formatDataContextValue = function(a, b) {
        if (a) {
            var c = a.match(/\[\[.*?\]\]/g),
                e;
            for (e = 0; e < c.length; e++) {
                var h = c[e],
                    h = h.substr(2, h.length - 4);
                void 0 !== b[h] && (a = a.replace(new RegExp("\\[\\[" + h + "\\]\\]", "g"), b[h]))
            }
        }
        return a
    };
    d.massReplace = function(a, b) {
        for (var c in b)
            if (b.hasOwnProperty(c)) {
                var e = b[c];
                void 0 === e && (e = "");
                a = a.replace(c, e)
            }
        return a
    };
    d.cleanFromEmpty = function(a) {
        return a.replace(/\[\[[^\]]*\]\]/g, "")
    };
    d.addPrefix = function(a, b, c, e, h) {
        var f = d.formatNumber(a, e),
            g = "",
            k, l, m;
        if (0 === a) return "0";
        0 > a && (g = "-");
        a = Math.abs(a);
        if (1 < a)
            for (k = b.length - 1; - 1 < k; k--) {
                if (a >= b[k].number && (l = a / b[k].number, m = Number(e.precision), 1 > m && (m = 1), c = d.roundTo(l, m), m = d.formatNumber(c, {
                        precision: -1,
                        decimalSeparator: e.decimalSeparator,
                        thousandsSeparator: e.thousandsSeparator
                    }), !h || l == c)) {
                    f = g + "" + m + "" + b[k].prefix;
                    break
                }
            } else
                for (k = 0; k < c.length; k++)
                    if (a <= c[k].number) {
                        l = a / c[k].number;
                        m = Math.abs(Math.round(Math.log(l) * Math.LOG10E));
                        l = d.roundTo(l, m);
                        f = g + "" + l + "" + c[k].prefix;
                        break
                    }
        return f
    };
    d.remove = function(a) {
        a && a.remove()
    };
    d.getEffect = function(a) {
        ">" == a && (a = "easeOutSine");
        "<" == a && (a = "easeInSine");
        "elastic" == a && (a = "easeOutElastic");
        return a
    };
    d.getObjById = function(a, b) {
        var c, e;
        for (e = 0; e < a.length; e++) {
            var h = a[e];
            h.id == b && (c = h)
        }
        return c
    };
    d.applyTheme = function(a, b, c) {
        b || (b = d.theme);
        b && b[c] && d.extend(a, b[c])
    };
    d.isString = function(a) {
        return "string" == typeof a ? !0 : !1
    };
    d.extend = function(a, b, c) {
        var e;
        a || (a = {});
        for (e in b) c ? a.hasOwnProperty(e) || (a[e] = b[e]) : a[e] = b[e];
        return a
    };
    d.copyProperties = function(a, b) {
        for (var c in a) a.hasOwnProperty(c) && "events" != c && void 0 !== a[c] && "function" != typeof a[c] && "cname" != c && (b[c] = a[c])
    };
    d.processObject = function(a, b, c, e) {
        if (!1 === a instanceof b && (a = e ? d.extend(new b(c), a) : d.extend(a, new b(c), !0), a.listeners))
            for (var h in a.listeners) b = a.listeners[h], a.addListener(b.event, b.method);
        return a
    };
    d.fixNewLines = function(a) {
        var b = RegExp("\\n", "g");
        a && (a = a.replace(b, "<br />"));
        return a
    };
    d.fixBrakes = function(a) {
        if (d.isModern) {
            var b = RegExp("<br>", "g");
            a && (a = a.replace(b, "\n"))
        } else a = d.fixNewLines(a);
        return a
    };
    d.deleteObject = function(a, b) {
        if (a) {
            if (void 0 === b || null === b) b = 20;
            if (0 !== b)
                if ("[object Array]" === Object.prototype.toString.call(a))
                    for (var c = 0; c < a.length; c++) d.deleteObject(a[c], b - 1), a[c] = null;
                else if (a && !a.tagName) try {
                for (c in a) a[c] && ("object" == typeof a[c] && d.deleteObject(a[c], b - 1), "function" != typeof a[c] && (a[c] = null))
            } catch (e) {}
        }
    };
    d.bounce = function(a, b, c, e, h) {
        return (b /= h) < 1 / 2.75 ? 7.5625 * e * b * b + c : b < 2 / 2.75 ? e * (7.5625 * (b -= 1.5 / 2.75) * b + .75) + c : b < 2.5 / 2.75 ? e * (7.5625 * (b -= 2.25 / 2.75) * b + .9375) + c : e * (7.5625 * (b -= 2.625 / 2.75) * b + .984375) + c
    };
    d.easeInSine = function(a, b, c, e, h) {
        return -e * Math.cos(b / h * (Math.PI / 2)) + e + c
    };
    d.easeOutSine = function(a, b, c, e, h) {
        return e * Math.sin(b / h * (Math.PI / 2)) + c
    };
    d.easeOutElastic = function(a, b, c, e, h) {
        a = 1.70158;
        var d = 0,
            g = e;
        if (0 === b) return c;
        if (1 == (b /= h)) return c + e;
        d || (d = .3 * h);
        g < Math.abs(e) ? (g = e, a = d / 4) : a = d / (2 * Math.PI) * Math.asin(e / g);
        return g * Math.pow(2, -10 * b) * Math.sin(2 * (b * h - a) * Math.PI / d) + e + c
    };
    d.fixStepE = function(a) {
        a = a.toExponential(0).split("e");
        var b = Number(a[1]);
        9 == Number(a[0]) && b++;
        return d.generateNumber(1, b)
    };
    d.generateNumber = function(a, b) {
        var c = "",
            e;
        e = 0 > b ? Math.abs(b) - 1 : Math.abs(b);
        var h;
        for (h = 0; h < e; h++) c += "0";
        return 0 > b ? Number("0." + c + String(a)) : Number(String(a) + c)
    };
    d.setCN = function(a, b, c, e) {
        if (a.addClassNames && b && (b = b.node) && c) {
            var h = b.getAttribute("class");
            a = a.classNamePrefix + "-";
            e && (a = "");
            h ? b.setAttribute("class", h + " " + a + c) : b.setAttribute("class", a + c)
        }
    };
    d.parseDefs = function(a, b) {
        for (var c in a) {
            var e = typeof a[c];
            if (0 < a[c].length && "object" == e)
                for (var h = 0; h < a[c].length; h++) e = document.createElementNS(d.SVG_NS, c), b.appendChild(e), d.parseDefs(a[c][h], e);
            else "object" == e ? (e = document.createElementNS(d.SVG_NS, c), b.appendChild(e), d.parseDefs(a[c], e)) : b.setAttribute(c, a[c])
        }
    }
})();
(function() {
    var d = window.AmCharts;
    d.AxisBase = d.Class({
        construct: function(a) {
            this.createEvents("clickItem", "rollOverItem", "rollOutItem");
            this.viY = this.viX = this.titleDY = this.y = this.x = this.dy = this.dx = 0;
            this.axisThickness = 1;
            this.axisColor = "#000000";
            this.axisAlpha = 1;
            this.gridCount = this.tickLength = 5;
            this.gridAlpha = .15;
            this.gridThickness = 1;
            this.gridColor = "#000000";
            this.dashLength = 0;
            this.labelFrequency = 1;
            this.showLastLabel = this.showFirstLabel = !0;
            this.fillColor = "#FFFFFF";
            this.fillAlpha = 0;
            this.labelsEnabled = !0;
            this.labelRotation = 0;
            this.autoGridCount = !0;
            this.offset = 0;
            this.guides = [];
            this.visible = !0;
            this.counter = 0;
            this.guides = [];
            this.ignoreAxisWidth = this.inside = !1;
            this.minHorizontalGap = 75;
            this.minVerticalGap = 35;
            this.titleBold = !0;
            this.minorGridEnabled = !1;
            this.minorGridAlpha = .07;
            this.autoWrap = !1;
            this.titleAlign = "middle";
            this.labelOffset = 0;
            this.bcn = "axis-";
            this.centerLabels = !1;
            this.periods = [{
                period: "ss",
                count: 1
            }, {
                period: "ss",
                count: 5
            }, {
                period: "ss",
                count: 10
            }, {
                period: "ss",
                count: 30
            }, {
                period: "mm",
                count: 1
            }, {
                period: "mm",
                count: 5
            }, {
                period: "mm",
                count: 10
            }, {
                period: "mm",
                count: 30
            }, {
                period: "hh",
                count: 1
            }, {
                period: "hh",
                count: 3
            }, {
                period: "hh",
                count: 6
            }, {
                period: "hh",
                count: 12
            }, {
                period: "DD",
                count: 1
            }, {
                period: "DD",
                count: 2
            }, {
                period: "DD",
                count: 3
            }, {
                period: "DD",
                count: 4
            }, {
                period: "DD",
                count: 5
            }, {
                period: "WW",
                count: 1
            }, {
                period: "MM",
                count: 1
            }, {
                period: "MM",
                count: 2
            }, {
                period: "MM",
                count: 3
            }, {
                period: "MM",
                count: 6
            }, {
                period: "YYYY",
                count: 1
            }, {
                period: "YYYY",
                count: 2
            }, {
                period: "YYYY",
                count: 5
            }, {
                period: "YYYY",
                count: 10
            }, {
                period: "YYYY",
                count: 50
            }, {
                period: "YYYY",
                count: 100
            }];
            this.dateFormats = [{
                period: "fff",
                format: "JJ:NN:SS"
            }, {
                period: "ss",
                format: "JJ:NN:SS"
            }, {
                period: "mm",
                format: "JJ:NN"
            }, {
                period: "hh",
                format: "JJ:NN"
            }, {
                period: "DD",
                format: "MMM DD"
            }, {
                period: "WW",
                format: "MMM DD"
            }, {
                period: "MM",
                format: "MMM"
            }, {
                period: "YYYY",
                format: "YYYY"
            }];
            this.nextPeriod = {
                fff: "ss",
                ss: "mm",
                mm: "hh",
                hh: "DD",
                DD: "MM",
                MM: "YYYY"
            };
            d.applyTheme(this, a, "AxisBase")
        },
        zoom: function(a, b) {
            this.start = a;
            this.end = b;
            this.dataChanged = !0;
            this.draw()
        },
        fixAxisPosition: function() {
            var a = this.position;
            "H" == this.orientation ? ("left" == a && (a = "bottom"), "right" == a && (a = "top")) : ("bottom" == a && (a = "left"), "top" == a && (a = "right"));
            this.position = a
        },
        draw: function() {
            var a = this.chart;
            this.allLabels = [];
            this.counter = 0;
            this.destroy();
            this.fixAxisPosition();
            this.labels = [];
            var b = a.container,
                c = b.set();
            a.gridSet.push(c);
            this.set = c;
            b = b.set();
            a.axesLabelsSet.push(b);
            this.labelsSet = b;
            this.axisLine = new this.axisRenderer(this);
            this.autoGridCount ? ("V" == this.orientation ? (a = this.height / this.minVerticalGap, 3 > a && (a = 3)) : a = this.width / this.minHorizontalGap, this.gridCountR = Math.max(a, 1)) : this.gridCountR = this.gridCount;
            this.axisWidth = this.axisLine.axisWidth;
            this.addTitle()
        },
        setOrientation: function(a) {
            this.orientation = a ? "H" : "V"
        },
        addTitle: function() {
            var a = this.title;
            this.titleLabel = null;
            if (a) {
                var b = this.chart,
                    c = this.titleColor;
                void 0 === c && (c = b.color);
                var e = this.titleFontSize;
                isNaN(e) && (e = b.fontSize + 1);
                a = d.text(b.container, a, c, b.fontFamily, e, this.titleAlign, this.titleBold);
                d.setCN(b, a, this.bcn + "title");
                this.titleLabel = a
            }
        },
        positionTitle: function() {
            var a = this.titleLabel;
            if (a) {
                var b, c, e = this.labelsSet,
                    h = {};
                0 < e.length() ? h = e.getBBox() : (h.x = 0, h.y = 0, h.width = this.viW, h.height = this.viH, d.VML && (h.y += this.y, h.x += this.x));
                e.push(a);
                var e = h.x,
                    f = h.y;
                d.VML && (this.rotate ? e -= this.x : f -= this.y);
                var g = h.width,
                    h = h.height,
                    k = this.viW,
                    l = this.viH,
                    m = 0,
                    n = a.getBBox().height / 2,
                    p = this.inside,
                    q = this.titleAlign;
                switch (this.position) {
                    case "top":
                        b = "left" == q ? -1 : "right" == q ? k : k / 2;
                        c = f - 10 - n;
                        break;
                    case "bottom":
                        b = "left" == q ? -1 : "right" == q ? k : k / 2;
                        c = f + h + 10 + n;
                        break;
                    case "left":
                        b = e - 10 - n;
                        p && (b -= 5);
                        m = -90;
                        c = ("left" == q ? l + 1 : "right" == q ? -1 : l / 2) + this.titleDY;
                        break;
                    case "right":
                        b = e + g + 10 + n, p && (b += 7), c = ("left" == q ? l + 2 : "right" == q ? -2 : l / 2) + this.titleDY, m = -90
                }
                this.marginsChanged ? (a.translate(b, c), this.tx = b, this.ty = c) : a.translate(this.tx, this.ty);
                this.marginsChanged = !1;
                isNaN(this.titleRotation) || (m = this.titleRotation);
                0 !== m && a.rotate(m)
            }
        },
        pushAxisItem: function(a, b) {
            var c = this,
                e = a.graphics();
            0 < e.length() && (b ? c.labelsSet.push(e) : c.set.push(e));
            if (e = a.getLabel()) this.labelsSet.push(e), e.click(function(b) {
                c.handleMouse(b, a, "clickItem")
            }).mouseover(function(b) {
                c.handleMouse(b, a, "rollOverItem")
            }).mouseout(function(b) {
                c.handleMouse(b, a, "rollOutItem")
            })
        },
        handleMouse: function(a, b, c) {
            this.fire(c, {
                type: c,
                value: b.value,
                serialDataItem: b.serialDataItem,
                axis: this,
                target: b.label,
                chart: this.chart,
                event: a
            })
        },
        addGuide: function(a) {
            for (var b = this.guides, c = !1, e = b.length, h = 0; h < b.length; h++) b[h] == a && (c = !0, e = h);
            a = d.processObject(a, d.Guide, this.theme);
            a.id || (a.id = "guideAuto" + e + "_" + (new Date).getTime());
            c || b.push(a)
        },
        removeGuide: function(a) {
            var b = this.guides,
                c;
            for (c = 0; c < b.length; c++) b[c] == a && b.splice(c, 1)
        },
        handleGuideOver: function(a) {
            clearTimeout(this.chart.hoverInt);
            var b = a.graphics.getBBox(),
                c = b.x + b.width / 2,
                b = b.y + b.height / 2,
                e = a.fillColor;
            void 0 === e && (e = a.lineColor);
            this.chart.showBalloon(a.balloonText, e, !0, c, b)
        },
        handleGuideOut: function() {
            this.chart.hideBalloon()
        },
        addEventListeners: function(a, b) {
            var c = this;
            a.mouseover(function() {
                c.handleGuideOver(b)
            });
            a.touchstart(function() {
                c.handleGuideOver(b)
            });
            a.mouseout(function() {
                c.handleGuideOut(b)
            })
        },
        getBBox: function() {
            var a = this.labelsSet.getBBox();
            d.VML || (a = {
                x: a.x + this.x,
                y: a.y + this.y,
                width: a.width,
                height: a.height
            });
            return a
        },
        destroy: function() {
            d.remove(this.set);
            d.remove(this.labelsSet);
            var a = this.axisLine;
            a && d.remove(a.set);
            d.remove(this.grid0)
        },
        chooseMinorFrequency: function(a) {
            for (var b = 10; 0 < b; b--)
                if (a / b == Math.round(a / b)) return a / b
        },
        parseDatesDraw: function() {
            var a, b = this.chart,
                c = this.showFirstLabel,
                e = this.showLastLabel,
                h, f = "",
                g = d.extractPeriod(this.minPeriod),
                k = d.getPeriodDuration(g.period, g.count),
                l, m, n, p, q, r = this.firstDayOfWeek,
                u = this.boldPeriodBeginning;
            a = this.minorGridEnabled;
            var t, z = this.gridAlpha,
                y, v = this.choosePeriod(0),
                w = v.period,
                v = v.count,
                A = d.getPeriodDuration(w, v);
            A < k && (w = g.period, v = g.count, A = k);
            g = w;
            "WW" == g && (g = "DD");
            this.stepWidth = this.getStepWidth(this.timeDifference);
            var B = Math.ceil(this.timeDifference / A) + 5,
                C = l = d.resetDateToMin(new Date(this.startTime - A), w, v, r).getTime();
            if (g == w && 1 == v && this.centerLabelOnFullPeriod || this.autoWrap || this.centerLabels) n = A * this.stepWidth, this.autoWrap && !this.centerLabels && (n = -n);
            this.cellWidth = k * this.stepWidth;
            p = Math.round(l / A);
            k = -1;
            p / 2 == Math.round(p / 2) && (k = -2, l -= A);
            p = this.firstTime;
            var D = 0,
                J = 0;
            a && 1 < v && (t = this.chooseMinorFrequency(v), y = d.getPeriodDuration(w, t));
            if (0 < this.gridCountR)
                for (B - 5 - k > this.autoRotateCount && !isNaN(this.autoRotateAngle) && (this.labelRotationR = this.autoRotateAngle), a = k; a <= B; a++) {
                    q = p + A * (a + Math.floor((C - p) / A)) - D;
                    "DD" == w && (q += 36E5);
                    q = d.resetDateToMin(new Date(q), w, v, r).getTime();
                    "MM" == w && (h = (q - l) / A, 1.5 <= (q - l) / A && (q = q - (h - 1) * A + d.getPeriodDuration("DD", 3), q = d.resetDateToMin(new Date(q), w, 1).getTime(), D += A));
                    h = (q - this.startTime) * this.stepWidth;
                    if ("radar" == b.type) {
                        if (0 > h || h > this.axisWidth) continue;
                        h = this.y + (this.axisWidth - h)
                    } else this.rotate ? (h += this.x - this.viX, "date" == this.type && "middle" == this.gridPosition && (J = -A * this.stepWidth / 2)) : h = "date" == this.type ? this.axisWidth - h + (this.y - this.viY) : h + (this.y - this.viY);
                    f = !1;
                    this.nextPeriod[g] && (f = this.checkPeriodChange(this.nextPeriod[g], 1, q, l, g));
                    l = !1;
                    f && this.markPeriodChange ? (f = this.dateFormatsObject[this.nextPeriod[g]], this.twoLineMode && (f = this.dateFormatsObject[g] + "\n" + f, f = d.fixBrakes(f)), l = !0) : f = this.dateFormatsObject[g];
                    u || (l = !1);
                    this.currentDateFormat = f;
                    f = d.formatDate(new Date(q), f, b);
                    if (a == k && !c || a == B && !e) f = " ";
                    this.labelFunction && (f = this.labelFunction(f, new Date(q), this, w, v, m).toString());
                    this.boldLabels && (l = !0);
                    m = new this.axisItemRenderer(this, h, f, !1, n, J, !1, l);
                    this.pushAxisItem(m);
                    m = l = q;
                    if (!isNaN(t))
                        for (h = 1; h < v; h += t) this.gridAlpha = this.minorGridAlpha, f = q + y * h, f = d.resetDateToMin(new Date(f), w, t, r).getTime(), f = new this.axisItemRenderer(this, (f - this.startTime) * this.stepWidth, void 0, void 0, void 0, void 0, void 0, void 0, void 0, !0), this.pushAxisItem(f);
                    this.gridAlpha = z
                }
        },
        choosePeriod: function(a) {
            var b = d.getPeriodDuration(this.periods[a].period, this.periods[a].count),
                c = Math.ceil(this.timeDifference / b),
                e = this.periods;
            return this.timeDifference < b && 0 < a ? e[a - 1] : c <= this.gridCountR ? e[a] : a + 1 < e.length ? this.choosePeriod(a + 1) : e[a]
        },
        getStepWidth: function(a) {
            var b;
            this.startOnAxis ? (b = this.axisWidth / (a - 1), 1 == a && (b = this.axisWidth)) : b = this.axisWidth / a;
            return b
        },
        timeZoom: function(a, b) {
            this.startTime = a;
            this.endTime = b
        },
        minDuration: function() {
            var a = d.extractPeriod(this.minPeriod);
            return d.getPeriodDuration(a.period, a.count)
        },
        checkPeriodChange: function(a, b, c, e, h) {
            c = new Date(c);
            var f = new Date(e),
                g = this.firstDayOfWeek;
            e = b;
            "DD" == a && (b = 1);
            c = d.resetDateToMin(c, a, b, g).getTime();
            b = d.resetDateToMin(f, a, b, g).getTime();
            return "DD" == a && "hh" != h && c - b < d.getPeriodDuration(a, e) ? !1 : c != b ? !0 : !1
        },
        generateDFObject: function() {
            this.dateFormatsObject = {};
            var a;
            for (a = 0; a < this.dateFormats.length; a++) {
                var b = this.dateFormats[a];
                this.dateFormatsObject[b.period] = b.format
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ValueAxis = d.Class({
        inherits: d.AxisBase,
        construct: function(a) {
            this.cname = "ValueAxis";
            this.createEvents("axisChanged", "logarithmicAxisFailed", "axisSelfZoomed", "axisZoomed");
            d.ValueAxis.base.construct.call(this, a);
            this.dataChanged = !0;
            this.stackType = "none";
            this.position = "left";
            this.unitPosition = "right";
            this.includeAllValues = this.recalculateToPercents = this.includeHidden = this.includeGuidesInMinMax = this.integersOnly = !1;
            this.durationUnits = {
                DD: "d. ",
                hh: ":",
                mm: ":",
                ss: ""
            };
            this.scrollbar = !1;
            this.baseValue = 0;
            this.radarCategoriesEnabled = !0;
            this.gridType = "polygons";
            this.useScientificNotation = !1;
            this.axisTitleOffset = 10;
            this.pointPosition = "axis";
            this.minMaxMultiplier = 1;
            this.logGridLimit = 2;
            this.totalTextOffset = this.treatZeroAs = 0;
            this.minPeriod = "ss";
            d.applyTheme(this, a, this.cname)
        },
        updateData: function() {
            0 >= this.gridCountR && (this.gridCountR = 1);
            this.totals = [];
            this.data = this.chart.chartData;
            var a = this.chart;
            "xy" != a.type && (this.stackGraphs("smoothedLine"), this.stackGraphs("line"), this.stackGraphs("column"), this.stackGraphs("step"));
            this.recalculateToPercents && this.recalculate();
            this.synchronizationMultiplier && this.synchronizeWith ? (d.isString(this.synchronizeWith) && (this.synchronizeWith = a.getValueAxisById(this.synchronizeWith)), this.synchronizeWith && (this.synchronizeWithAxis(this.synchronizeWith), this.foundGraphs = !0)) : (this.foundGraphs = !1, this.getMinMax())
        },
        draw: function() {
            d.ValueAxis.base.draw.call(this);
            var a = this.chart,
                b = this.set;
            this.labelRotationR = this.labelRotation;
            d.setCN(a, this.set, "value-axis value-axis-" + this.id);
            d.setCN(a, this.labelsSet, "value-axis value-axis-" + this.id);
            d.setCN(a, this.axisLine.axisSet, "value-axis value-axis-" + this.id);
            var c = this.type;
            "duration" == c && (this.duration = "ss");
            !0 === this.dataChanged && (this.updateData(), this.dataChanged = !1);
            "date" == c && (this.logarithmic = !1, this.min = this.minRR, this.max = this.maxRR, this.getDateMinMax());
            if (this.logarithmic) {
                var e = this.treatZeroAs,
                    h = this.getMin(0, this.data.length - 1);
                this.minReal < h && (this.minReal = h);
                isNaN(this.minReal) && (this.minReal = h);
                0 < e && 0 === h && (this.minReal = h = e);
                if (0 >= h || 0 >= this.minimum) {
                    this.fire("logarithmicAxisFailed", {
                        type: "logarithmicAxisFailed",
                        chart: a
                    });
                    return
                }
            }
            this.grid0 = null;
            var f, g, k = a.dx,
                l = a.dy,
                e = !1,
                h = this.logarithmic;
            if (isNaN(this.min) || isNaN(this.max) || !this.foundGraphs || Infinity == this.min || -Infinity == this.max) e = !0;
            else {
                var m = this.labelFrequency,
                    n = this.showFirstLabel,
                    p = this.showLastLabel,
                    q = 1;
                f = 0;
                this.minCalc = this.min;
                this.maxCalc = this.max;
                this.strictMinMax && (isNaN(this.minimum) || (this.min = this.minimum), isNaN(this.maximum) || (this.max = this.maximum));
                isNaN(this.minZoom) || (this.min = this.minZoom);
                isNaN(this.maxZoom) || (this.max = this.maxZoom);
                var r = Math.round((this.maxCalc - this.minCalc) / this.step) + 1,
                    u;
                !0 === h ? (u = Math.log(this.max) * Math.LOG10E - Math.log(this.minReal) * Math.LOG10E, this.stepWidth = this.axisWidth / u, u > this.logGridLimit && (r = Math.ceil(Math.log(this.max) * Math.LOG10E) + 1, f = Math.round(Math.log(this.minReal) * Math.LOG10E), r > this.gridCountR && (q = Math.ceil(r / this.gridCountR)))) : this.stepWidth = this.axisWidth / (this.max - this.min);
                var t = 0;
                1 > this.step && -1 < this.step && (t = d.getDecimals(this.step));
                this.integersOnly && (t = 0);
                t > this.maxDecCount && (t = this.maxDecCount);
                var z = this.precision;
                isNaN(z) || (t = z);
                this.max = d.roundTo(this.max, this.maxDecCount);
                this.min = d.roundTo(this.min, this.maxDecCount);
                g = {};
                g.precision = t;
                g.decimalSeparator = a.nf.decimalSeparator;
                g.thousandsSeparator = a.nf.thousandsSeparator;
                this.numberFormatter = g;
                var y, v = this.guides,
                    w = v.length;
                if (0 < w) {
                    var A = this.fillAlpha;
                    for (g = this.fillAlpha = 0; g < w; g++) {
                        var B = v[g],
                            C = NaN,
                            D = B.above;
                        isNaN(B.toValue) || (C = this.getCoordinate(B.toValue), y = new this.axisItemRenderer(this, C, "", !0, NaN, NaN, B), this.pushAxisItem(y, D));
                        var J = NaN;
                        isNaN(B.value) || (J = this.getCoordinate(B.value), y = new this.axisItemRenderer(this, J, B.label, !0, NaN, (C - J) / 2, B), this.pushAxisItem(y, D));
                        isNaN(C - J) || (y = new this.guideFillRenderer(this, J, C, B), this.pushAxisItem(y, D), y = y.graphics(), B.graphics = y, B.balloonText && this.addEventListeners(y, B))
                    }
                    this.fillAlpha = A
                }
                this.exponential = !1;
                for (g = f; g < r; g += q) v = d.roundTo(this.step * g + this.min, t), -1 != String(v).indexOf("e") && (this.exponential = !0);
                this.duration && (this.maxInterval = d.getMaxInterval(this.max, this.duration));
                var t = this.step,
                    E, v = this.minorGridAlpha;
                this.minorGridEnabled && (E = this.getMinorGridStep(t, this.stepWidth * t));
                if ("date" == c) this.generateDFObject(), this.timeDifference = this.max - this.min, this.maxTime = this.lastTime = this.max, this.startTime = this.firstTime = this.min, this.parseDatesDraw();
                else
                    for (r >= this.autoRotateCount && !isNaN(this.autoRotateAngle) && (this.labelRotationR = this.autoRotateAngle), g = f; g < r; g += q)
                        if (c = t * g + this.minCalc, h && this.max - this.min > 10 * this.min && (c -= this.min), c = d.roundTo(c, this.maxDecCount + 1), !this.integersOnly || Math.round(c) == c)
                            if (isNaN(z) || Number(d.toFixed(c, z)) == c) {
                                !0 === h && (0 === c && (c = this.minReal), u > this.logGridLimit && (c = Math.pow(10, g)));
                                y = this.formatValue(c, !1, g);
                                Math.round(g / m) != g / m && (y = void 0);
                                if (0 === g && !n || g == r - 1 && !p) y = " ";
                                f = this.getCoordinate(c);
                                var O;
                                this.rotate && this.autoWrap && (O = this.stepWidth * t - 10);
                                y = new this.axisItemRenderer(this, f, y, void 0, O, void 0, void 0, this.boldLabels);
                                this.pushAxisItem(y);
                                if (c == this.baseValue && "radar" != a.type) {
                                    var I, W, A = this.viW,
                                        B = this.viH;
                                    y = this.viX;
                                    w = this.viY;
                                    "H" == this.orientation ? 0 <= f && f <= A + 1 && (I = [f, f, f + k], W = [B, 0, l]) : 0 <= f && f <= B + 1 && (I = [0, A, A + k], W = [f, f, f + l]);
                                    I && (f = d.fitToBounds(2 * this.gridAlpha, 0, 1), f = d.line(a.container, I, W, this.gridColor, f, 1, this.dashLength), f.translate(y, w), this.grid0 = f, a.axesSet.push(f), f.toBack(), d.setCN(a, f, this.bcn + "zero-grid-" + this.id), d.setCN(a, f, this.bcn + "zero-grid"))
                                }
                                if (!isNaN(E) && 0 < v && g < r - 1) {
                                    f = this.gridAlpha;
                                    this.gridAlpha = this.minorGridAlpha;
                                    for (y = 1; y < t / E; y++) w = this.getCoordinate(c + E * y), w = new this.axisItemRenderer(this, w, "", !1, 0, 0, !1, !1, 0, !0), this.pushAxisItem(w);
                                    this.gridAlpha = f
                                }
                            }
                u = this.baseValue;
                this.min > this.baseValue && this.max > this.baseValue && (u = this.min);
                this.min < this.baseValue && this.max < this.baseValue && (u = this.max);
                h && u < this.minReal && (u = this.minReal);
                this.baseCoord = this.getCoordinate(u);
                u = {
                    type: "axisChanged",
                    target: this,
                    chart: a
                };
                u.min = h ? this.minReal : this.min;
                u.max = this.max;
                this.fire("axisChanged", u);
                this.axisCreated = !0
            }
            h = this.axisLine.set;
            u = this.labelsSet;
            this.positionTitle();
            "radar" != a.type ? (a = this.viX, E = this.viY, b.translate(a, E), u.translate(a, E)) : h.toFront();
            !this.visible || e ? (b.hide(), h.hide(), u.hide()) : (b.show(), h.show(), u.show());
            this.axisY = this.y - this.viY;
            this.axisX = this.x - this.viX
        },
        getDateMinMax: function() {
            this.minimumDate && (this.minimumDate instanceof Date || (this.minimumDate = d.getDate(this.minimumDate, this.chart.dataDateFormat, "fff")), this.min = this.minimumDate.getTime());
            this.maximumDate && (this.maximumDate instanceof Date || (this.maximumDate = d.getDate(this.maximumDate, this.chart.dataDateFormat, "fff")), this.max = this.maximumDate.getTime())
        },
        formatValue: function(a, b, c) {
            var e = this.exponential,
                h = this.logarithmic,
                f = this.numberFormatter,
                g = this.chart;
            !0 === this.logarithmic && (e = -1 != String(a).indexOf("e") ? !0 : !1);
            this.useScientificNotation && (e = !0);
            this.usePrefixes && (e = !1);
            e ? (c = -1 == String(a).indexOf("e") ? a.toExponential(15) : String(a), e = c.split("e"), c = Number(e[0]), e = Number(e[1]), c = d.roundTo(c, 14), 10 == c && (c = 1, e += 1), c = c + "e" + e, 0 === a && (c = "0"), 1 == a && (c = "1")) : (h && (e = String(a).split("."), e[1] ? (f.precision = e[1].length, 0 > c && (f.precision = Math.abs(c)), b && 1 < a && (f.precision = 0)) : f.precision = -1), c = this.usePrefixes ? d.addPrefix(a, g.prefixesOfBigNumbers, g.prefixesOfSmallNumbers, f, !b) : d.formatNumber(a, f, f.precision));
            this.duration && (b && (f.precision = 0), c = d.formatDuration(a, this.duration, "", this.durationUnits, this.maxInterval, f));
            "date" == this.type && (c = d.formatDate(new Date(a), this.currentDateFormat, g));
            this.recalculateToPercents ? c += "%" : (b = this.unit) && (c = "left" == this.unitPosition ? b + c : c + b);
            this.labelFunction && (c = this.labelFunction(a, c, this).toString());
            return c
        },
        getMinorGridStep: function(a, b) {
            var c = [5, 4, 2];
            60 > b && c.shift();
            for (var e = Math.floor(Math.log(Math.abs(a)) * Math.LOG10E), h = 0; h < c.length; h++) {
                var d = a / c[h],
                    g = Math.floor(Math.log(Math.abs(d)) * Math.LOG10E);
                if (!(1 < Math.abs(e - g)))
                    if (1 > a) {
                        if (g = Math.pow(10, -g) * d, g == Math.round(g)) return d
                    } else if (d == Math.round(d)) return d
            }
        },
        stackGraphs: function(a) {
            var b = this.stackType;
            "stacked" == b && (b = "regular");
            "line" == b && (b = "none");
            "100% stacked" == b && (b = "100%");
            this.stackType = b;
            var c = [],
                e = [],
                h = [],
                f = [],
                g, k = this.chart.graphs,
                l, m, n, p, q = this.baseValue,
                r = !1;
            if ("line" == a || "step" == a || "smoothedLine" == a) r = !0;
            if (r && ("regular" == b || "100%" == b))
                for (p = 0; p < k.length; p++) n = k[p], n.hidden || (m = n.type, n.chart == this.chart && n.valueAxis == this && a == m && n.stackable && (l && (n.stackGraph = l), l = n));
            for (l = this.start; l <= this.end; l++) {
                var u = 0;
                for (p = 0; p < k.length; p++)
                    if (n = k[p], n.hidden) n.newStack && (h[l] = NaN, e[l] = NaN);
                    else if (m = n.type, n.chart == this.chart && n.valueAxis == this && a == m && n.stackable)
                    if (m = this.data[l].axes[this.id].graphs[n.id], g = m.values.value, isNaN(g)) n.newStack && (h[l] = NaN, e[l] = NaN);
                    else {
                        var t = d.getDecimals(g);
                        u < t && (u = t);
                        isNaN(f[l]) ? f[l] = Math.abs(g) : f[l] += Math.abs(g);
                        f[l] = d.roundTo(f[l], u);
                        t = n.fillToGraph;
                        r && t && (t = this.data[l].axes[this.id].graphs[t.id]) && (m.values.open = t.values.value);
                        "regular" == b && (r && (isNaN(c[l]) ? (c[l] = g, m.values.close = g, m.values.open = this.baseValue) : (isNaN(g) ? m.values.close = c[l] : m.values.close = g + c[l], m.values.open = c[l], c[l] = m.values.close)), "column" == a && (n.newStack && (h[l] = NaN, e[l] = NaN), m.values.close = g, 0 > g ? (m.values.close = g, isNaN(e[l]) ? m.values.open = q : (m.values.close += e[l], m.values.open = e[l]), e[l] = m.values.close) : (m.values.close = g, isNaN(h[l]) ? m.values.open = q : (m.values.close += h[l], m.values.open = h[l]), h[l] = m.values.close)))
                    }
            }
            for (l = this.start; l <= this.end; l++)
                for (p = 0; p < k.length; p++)(n = k[p], n.hidden) ? n.newStack && (h[l] = NaN, e[l] = NaN) : (m = n.type, n.chart == this.chart && n.valueAxis == this && a == m && n.stackable && (m = this.data[l].axes[this.id].graphs[n.id], g = m.values.value, isNaN(g) || (c = g / f[l] * 100, m.values.percents = c, m.values.total = f[l], n.newStack && (h[l] = NaN, e[l] = NaN), "100%" == b && (isNaN(e[l]) && (e[l] = 0), isNaN(h[l]) && (h[l] = 0), 0 > c ? (m.values.close = d.fitToBounds(c + e[l], -100, 100), m.values.open = e[l], e[l] = m.values.close) : (m.values.close = d.fitToBounds(c + h[l], -100, 100), m.values.open = h[l], h[l] = m.values.close)))))
        },
        recalculate: function() {
            var a = this.chart,
                b = a.graphs,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c];
                if (e.valueAxis == this) {
                    var h = "value";
                    if ("candlestick" == e.type || "ohlc" == e.type) h = "open";
                    var f, g, k = this.end + 2,
                        k = d.fitToBounds(this.end + 1, 0, this.data.length - 1),
                        l = this.start;
                    0 < l && l--;
                    var m;
                    g = this.start;
                    e.compareFromStart && (g = 0);
                    if (!isNaN(a.startTime) && (m = a.categoryAxis)) {
                        var n = m.minDuration(),
                            n = new Date(a.startTime + n / 2),
                            p = d.resetDateToMin(new Date(a.startTime), m.minPeriod).getTime();
                        d.resetDateToMin(new Date(n), m.minPeriod).getTime() > p && g++
                    }
                    if (m = a.recalculateFromDate) m = d.getDate(m, a.dataDateFormat, "fff"), g = a.getClosestIndex(a.chartData, "time", m.getTime(), !0, 0, a.chartData.length), k = a.chartData.length - 1;
                    for (m = g; m <= k && (g = this.data[m].axes[this.id].graphs[e.id], f = g.values[h], e.recalculateValue && (f = g.dataContext["value" + e.recalculateValue]), isNaN(f)); m++);
                    this.recBaseValue = f;
                    for (h = l; h <= k; h++) {
                        g = this.data[h].axes[this.id].graphs[e.id];
                        g.percents = {};
                        var l = g.values,
                            q;
                        for (q in l) g.percents[q] = "percents" != q ? l[q] / f * 100 - 100 : l[q]
                    }
                }
            }
        },
        getMinMax: function() {
            var a = !1,
                b = this.chart,
                c = b.graphs,
                e;
            for (e = 0; e < c.length; e++) {
                var h = c[e].type;
                ("line" == h || "step" == h || "smoothedLine" == h) && this.expandMinMax && (a = !0)
            }
            a && (0 < this.start && this.start--, this.end < this.data.length - 1 && this.end++);
            "serial" == b.type && (!0 !== b.categoryAxis.parseDates || a || this.end < this.data.length - 1 && this.end++);
            this.includeAllValues && (this.start = 0, this.end = this.data.length - 1);
            a = this.minMaxMultiplier;
            this.min = this.getMin(this.start, this.end);
            this.max = this.getMax();
            this.minRR = this.min;
            this.maxRR = this.max;
            a = (this.max - this.min) * (a - 1);
            this.min -= a;
            this.max += a;
            a = this.guides.length;
            if (this.includeGuidesInMinMax && 0 < a)
                for (b = 0; b < a; b++) c = this.guides[b], c.toValue < this.min && (this.min = c.toValue), c.value < this.min && (this.min = c.value), c.toValue > this.max && (this.max = c.toValue), c.value > this.max && (this.max = c.value);
            isNaN(this.minimum) || (this.min = this.minimum);
            isNaN(this.maximum) || (this.max = this.maximum);
            "date" == this.type && this.getDateMinMax();
            this.min > this.max && (a = this.max, this.max = this.min, this.min = a);
            isNaN(this.minTemp) || (this.min = this.minTemp);
            isNaN(this.maxTemp) || (this.max = this.maxTemp);
            this.minReal = this.min;
            this.maxReal = this.max;
            0 === this.min && 0 === this.max && (this.max = 9);
            this.min > this.max && (this.min = this.max - 1);
            a = this.min;
            b = this.max;
            c = this.max - this.min;
            e = 0 === c ? Math.pow(10, Math.floor(Math.log(Math.abs(this.max)) * Math.LOG10E)) / 10 : Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;
            isNaN(this.maximum) && isNaN(this.maxTemp) && (this.max = Math.ceil(this.max / e) * e + e);
            isNaN(this.minimum) && isNaN(this.minTemp) && (this.min = Math.floor(this.min / e) * e - e);
            0 > this.min && 0 <= a && (this.min = 0);
            0 < this.max && 0 >= b && (this.max = 0);
            "100%" == this.stackType && (this.min = 0 > this.min ? -100 : 0, this.max = 0 > this.max ? 0 : 100);
            c = this.max - this.min;
            e = Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;
            this.step = Math.ceil(c / this.gridCountR / e) * e;
            c = Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E));
            c = d.fixStepE(c);
            e = Math.ceil(this.step / c);
            5 < e && (e = 10);
            5 >= e && 2 < e && (e = 5);
            this.step = Math.ceil(this.step / (c * e)) * c * e;
            1 > c ? (this.maxDecCount = Math.abs(Math.log(Math.abs(c)) * Math.LOG10E), this.maxDecCount = Math.round(this.maxDecCount), this.step = d.roundTo(this.step, this.maxDecCount + 1)) : this.maxDecCount = 0;
            this.min = this.step * Math.floor(this.min / this.step);
            this.max = this.step * Math.ceil(this.max / this.step);
            0 > this.min && 0 <= a && (this.min = 0);
            0 < this.max && 0 >= b && (this.max = 0);
            1 < this.minReal && 1 < this.max - this.minReal && (this.minReal = Math.floor(this.minReal));
            c = Math.pow(10, Math.floor(Math.log(Math.abs(this.minReal)) * Math.LOG10E));
            0 === this.min && (this.minReal = c);
            0 === this.min && 1 < this.minReal && (this.minReal = 1);
            0 < this.min && 0 < this.minReal - this.step && (this.minReal = this.min + this.step < this.minReal ? this.min + this.step : this.min);
            this.logarithmic && (2 < Math.log(b) * Math.LOG10E - Math.log(a) * Math.LOG10E ? (this.minReal = this.min = Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)), this.max = Math.pow(10, Math.ceil(Math.log(Math.abs(b)) * Math.LOG10E))) : (b = Math.pow(10, Math.floor(Math.log(Math.abs(this.min)) * Math.LOG10E)) / 10, a = Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)) / 10, b < a && (this.minReal = this.min = 10 * a)))
        },
        getMin: function(a, b) {
            var c, e;
            for (e = a; e <= b; e++) {
                var d = this.data[e].axes[this.id].graphs,
                    f;
                for (f in d)
                    if (d.hasOwnProperty(f)) {
                        var g = this.chart.getGraphById(f);
                        if (g.includeInMinMax && (!g.hidden || this.includeHidden)) {
                            isNaN(c) && (c = Infinity);
                            this.foundGraphs = !0;
                            g = d[f].values;
                            this.recalculateToPercents && (g = d[f].percents);
                            var k;
                            if (this.minMaxField) k = g[this.minMaxField], k < c && (c = k);
                            else
                                for (var l in g) g.hasOwnProperty(l) && "percents" != l && "total" != l && (k = g[l], k < c && (c = k))
                        }
                    }
            }
            return c
        },
        getMax: function() {
            var a, b;
            for (b = this.start; b <= this.end; b++) {
                var c = this.data[b].axes[this.id].graphs,
                    e;
                for (e in c)
                    if (c.hasOwnProperty(e)) {
                        var d = this.chart.getGraphById(e);
                        if (d.includeInMinMax && (!d.hidden || this.includeHidden)) {
                            isNaN(a) && (a = -Infinity);
                            this.foundGraphs = !0;
                            d = c[e].values;
                            this.recalculateToPercents && (d = c[e].percents);
                            var f;
                            if (this.minMaxField) f = d[this.minMaxField], f > a && (a = f);
                            else
                                for (var g in d) d.hasOwnProperty(g) && "percents" != g && "total" != g && (f = d[g], f > a && (a = f))
                        }
                    }
            }
            return a
        },
        dispatchZoomEvent: function(a, b) {
            var c = {
                type: "axisZoomed",
                startValue: a,
                endValue: b,
                target: this,
                chart: this.chart
            };
            this.fire(c.type, c)
        },
        zoomOut: function() {
            var a = this.chart;
            "xy" != a.type && (this.maxZoom = this.minZoom = void 0, a.updateAfterValueZoom())
        },
        zoomToValues: function(a, b) {
            var c = this.chart;
            "xy" == c.type ? (b < a && (c = b, b = a, a = c), a < this.min && (a = this.min), b > this.max && (b = this.max), c = {
                type: "axisSelfZoomed"
            }, c.chart = this.chart, c.valueAxis = this, c.multiplier = this.axisWidth / Math.abs(this.getCoordinate(b) - this.getCoordinate(a)), c.startValue = a, c.endValue = b, c.position = "V" == this.orientation ? this.reversed ? this.getCoordinate(a) : this.getCoordinate(b) : this.reversed ? this.getCoordinate(b) : this.getCoordinate(a), this.fire(c.type, c)) : (this.minZoom = a, this.maxZoom = b, c.updateAfterValueZoom())
        },
        coordinateToValue: function(a) {
            if (isNaN(a)) return NaN;
            var b = this.axisWidth,
                c = this.stepWidth,
                e = this.reversed,
                d = this.rotate,
                f = this.min,
                g = this.minReal;
            return !0 === this.logarithmic ? Math.pow(10, (d ? !0 === e ? (b - a) / c : a / c : !0 === e ? a / c : (b - a) / c) + Math.log(g) * Math.LOG10E) : !0 === e ? d ? f - (a - b) / c : a / c + f : d ? a / c + f : f - (a - b) / c
        },
        getCoordinate: function(a) {
            if (isNaN(a)) return NaN;
            var b = this.rotate,
                c = this.reversed,
                e = this.axisWidth,
                d = this.stepWidth,
                f = this.min,
                g = this.minReal;
            !0 === this.logarithmic ? (0 === a && (a = this.treatZeroAs), a = Math.log(a) * Math.LOG10E - Math.log(g) * Math.LOG10E, b = b ? !0 === c ? e - d * a : d * a : !0 === c ? d * a : e - d * a) : b = !0 === c ? b ? e - d * (a - f) : d * (a - f) : b ? d * (a - f) : e - d * (a - f);
            b = this.rotate ? b + (this.x - this.viX) : b + (this.y - this.viY);
            1E7 < Math.abs(b) && (b = 1E7 * (b / Math.abs(b)));
            return Math.round(b)
        },
        synchronizeWithAxis: function(a) {
            this.synchronizeWith = a;
            this.listenTo(this.synchronizeWith, "axisChanged", this.handleSynchronization)
        },
        handleSynchronization: function() {
            if (this.synchronizeWith) {
                d.isString(this.synchronizeWith) && (this.synchronizeWith = this.chart.getValueAxisById(this.synchronizeWith));
                var a = this.synchronizeWith,
                    b = a.min,
                    c = a.max,
                    a = a.step,
                    e = this.synchronizationMultiplier;
                e && (this.min = b * e, this.max = c * e, this.step = a * e, b = Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E)), b = Math.abs(Math.log(Math.abs(b)) * Math.LOG10E), this.maxDecCount = b = Math.round(b), this.draw())
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.RecAxis = d.Class({
        construct: function(a) {
            var b = a.chart,
                c = a.axisThickness,
                e = a.axisColor,
                h = a.axisAlpha,
                f = a.offset,
                g = a.dx,
                k = a.dy,
                l = a.viX,
                m = a.viY,
                n = a.viH,
                p = a.viW,
                q = b.container;
            "H" == a.orientation ? (e = d.line(q, [0, p], [0, 0], e, h, c), this.axisWidth = a.width, "bottom" == a.position ? (k = c / 2 + f + n + m - 1, c = l) : (k = -c / 2 - f + m + k, c = g + l)) : (this.axisWidth = a.height, "right" == a.position ? (e = d.line(q, [0, 0, -g], [0, n, n - k], e, h, c), k = m + k, c = c / 2 + f + g + p + l - 1) : (e = d.line(q, [0, 0], [0, n], e, h, c), k = m, c = -c / 2 - f + l));
            e.translate(c, k);
            c = b.container.set();
            c.push(e);
            b.axesSet.push(c);
            d.setCN(b, e, a.bcn + "line");
            this.axisSet = c;
            this.set = e
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.RecItem = d.Class({
        construct: function(a, b, c, e, h, f, g, k, l, m, n, p) {
            b = Math.round(b);
            var q = a.chart;
            this.value = c;
            void 0 == c && (c = "");
            l || (l = 0);
            void 0 == e && (e = !0);
            var r = q.fontFamily,
                u = a.fontSize;
            void 0 == u && (u = q.fontSize);
            var t = a.color;
            void 0 == t && (t = q.color);
            void 0 !== n && (t = n);
            var z = a.chart.container,
                y = z.set();
            this.set = y;
            var v = a.axisThickness,
                w = a.axisColor,
                A = a.axisAlpha,
                B = a.tickLength,
                C = a.gridAlpha,
                D = a.gridThickness,
                J = a.gridColor,
                E = a.dashLength,
                O = a.fillColor,
                I = a.fillAlpha,
                W = a.labelsEnabled;
            n = a.labelRotationR;
            var ea = a.counter,
                P = a.inside,
                oa = a.labelOffset,
                qa = a.dx,
                ka = a.dy,
                Ra = a.orientation,
                ca = a.position,
                aa = a.previousCoord,
                V = a.viH,
                sa = a.viW,
                ba = a.offset,
                da, ta;
            g ? (void 0 !== g.id && (p = q.classNamePrefix + "-guide-" + g.id), W = !0, isNaN(g.tickLength) || (B = g.tickLength), void 0 != g.lineColor && (J = g.lineColor), void 0 != g.color && (t = g.color), isNaN(g.lineAlpha) || (C = g.lineAlpha), isNaN(g.dashLength) || (E = g.dashLength), isNaN(g.lineThickness) || (D = g.lineThickness), !0 === g.inside && (P = !0, 0 < ba && (ba = 0)), isNaN(g.labelRotation) || (n = g.labelRotation), isNaN(g.fontSize) || (u = g.fontSize), g.position && (ca = g.position), void 0 !== g.boldLabel && (k = g.boldLabel), isNaN(g.labelOffset) || (oa = g.labelOffset)) : "" === c && (B = 0);
            m && !isNaN(a.minorTickLength) && (B = a.minorTickLength);
            var fa = "start";
            0 < h && (fa = "middle");
            a.centerLabels && (fa = "middle");
            var R = n * Math.PI / 180,
                X, wa, H = 0,
                x = 0,
                la = 0,
                ga = X = 0,
                Ja = 0;
            "V" == Ra && (n = 0);
            var Z;
            W && "" !== c && (Z = a.autoWrap && 0 === n ? d.wrappedText(z, c, t, r, u, fa, k, Math.abs(h), 0) : d.text(z, c, t, r, u, fa, k), fa = Z.getBBox(), ga = fa.width, Ja = fa.height);
            if ("H" == Ra) {
                if (0 <= b && b <= sa + 1 && (0 < B && 0 < A && b + l <= sa + 1 && (da = d.line(z, [b + l, b + l], [0, B], w, A, D), y.push(da)), 0 < C && (ta = d.line(z, [b, b + qa, b + qa], [V, V + ka, ka], J, C, D, E), y.push(ta))), x = 0, H = b, g && 90 == n && P && (H -= u), !1 === e ? (fa = "start", x = "bottom" == ca ? P ? x + B : x - B : P ? x - B : x + B, H += 3, 0 < h && (H += h / 2 - 3, fa = "middle"), 0 < n && (fa = "middle")) : fa = "middle", 1 == ea && 0 < I && !g && !m && aa < sa && (e = d.fitToBounds(b, 0, sa), aa = d.fitToBounds(aa, 0, sa), X = e - aa, 0 < X && (wa = d.rect(z, X, a.height, O, I), wa.translate(e - X + qa, ka), y.push(wa))), "bottom" == ca ? (x += V + u / 2 + ba, P ? (0 < n ? (x = V - ga / 2 * Math.sin(R) - B - 3, H += ga / 2 * Math.cos(R) - 4 + 2) : 0 > n ? (x = V + ga * Math.sin(R) - B - 3 + 2, H += -ga * Math.cos(R) - Ja * Math.sin(R) - 4) : x -= B + u + 3 + 3, x -= oa) : (0 < n ? (x = V + ga / 2 * Math.sin(R) + B + 3, H -= ga / 2 * Math.cos(R)) : 0 > n ? (x = V + B + 3 - ga / 2 * Math.sin(R) + 2, H += ga / 2 * Math.cos(R)) : x += B + v + 3 + 3, x += oa)) : (x += ka + u / 2 - ba, H += qa, P ? (0 < n ? (x = ga / 2 * Math.sin(R) + B + 3, H -= ga / 2 * Math.cos(R)) : x += B + 3, x += oa) : (0 < n ? (x = -(ga / 2) * Math.sin(R) - B - 6, H += ga / 2 * Math.cos(R)) : x -= B + u + 3 + v + 3, x -= oa)), "bottom" == ca ? X = (P ? V - B - 1 : V + v - 1) + ba : (la = qa, X = (P ? ka : ka - B - v + 1) - ba), f && (H += f), f = H, 0 < n && (f += ga / 2 * Math.cos(R)), Z && (u = 0, P && (u = ga / 2 * Math.cos(R)), f + u > sa + 2 || 0 > f)) Z.remove(), Z = null
            } else {
                0 <= b && b <= V + 1 && (0 < B && 0 < A && b + l <= V + 1 && (da = d.line(z, [0, B], [b + l, b + l], w, A, D), y.push(da)), 0 < C && (ta = d.line(z, [0, qa, sa + qa], [b, b + ka, b + ka], J, C, D, E), y.push(ta)));
                fa = "end";
                if (!0 === P && "left" == ca || !1 === P && "right" == ca) fa = "start";
                x = b - Ja / 2 + 2;
                1 == ea && 0 < I && !g && !m && (e = d.fitToBounds(b, 0, V), aa = d.fitToBounds(aa, 0, V), R = e - aa, wa = d.polygon(z, [0, a.width, a.width, 0], [0, 0, R, R], O, I), wa.translate(qa, e - R + ka), y.push(wa));
                x += u / 2;
                "right" == ca ? (H += qa + sa + ba, x += ka, P ? (f || (x -= u / 2 + 3), H = H - (B + 4) - oa) : (H += B + 4 + v, x -= 2, H += oa)) : P ? (H += B + 4 - ba, f || (x -= u / 2 + 3), g && (H += qa, x += ka), H += oa) : (H += -B - v - 4 - 2 - ba, x -= 2, H -= oa);
                da && ("right" == ca ? (la += qa + ba + sa, X += ka, la = P ? la - v : la + v) : (la -= ba, P || (la -= B + v)));
                f && (x += f);
                P = -3;
                "right" == ca && (P += ka);
                Z && (x > V + 1 || x < P) && (Z.remove(), Z = null)
            }
            da && (da.translate(la, X), d.setCN(q, da, a.bcn + "tick"), d.setCN(q, da, p, !0), g && d.setCN(q, da, "guide"));
            !1 === a.visible && (da && da.remove(), Z && (Z.remove(), Z = null));
            Z && (Z.attr({
                "text-anchor": fa
            }), Z.translate(H, x), 0 !== n && Z.rotate(-n, a.chart.backgroundColor), a.allLabels.push(Z), this.label = Z, d.setCN(q, Z, a.bcn + "label"), d.setCN(q, Z, p, !0), g && d.setCN(q, Z, "guide"));
            ta && (d.setCN(q, ta, a.bcn + "grid"), d.setCN(q, ta, p, !0), g && d.setCN(q, ta, "guide"));
            wa && (d.setCN(q, wa, a.bcn + "fill"), d.setCN(q, wa, p, !0));
            m ? ta && d.setCN(q, ta, a.bcn + "grid-minor") : (a.counter = 0 === ea ? 1 : 0, a.previousCoord = b);
            0 === this.set.node.childNodes.length && this.set.remove()
        },
        graphics: function() {
            return this.set
        },
        getLabel: function() {
            return this.label
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.RecFill = d.Class({
        construct: function(a, b, c, e) {
            var h = a.dx,
                f = a.dy,
                g = a.orientation,
                k = 0;
            if (c < b) {
                var l = b;
                b = c;
                c = l
            }
            var m = e.fillAlpha;
            isNaN(m) && (m = 0);
            var l = a.chart.container,
                n = e.fillColor;
            "V" == g ? (b = d.fitToBounds(b, 0, a.viH), c = d.fitToBounds(c, 0, a.viH)) : (b = d.fitToBounds(b, 0, a.viW), c = d.fitToBounds(c, 0, a.viW));
            c -= b;
            isNaN(c) && (c = 4, k = 2, m = 0);
            0 > c && "object" == typeof n && (n = n.join(",").split(",").reverse());
            "V" == g ? (g = d.rect(l, a.viW, c, n, m), g.translate(h, b - k + f)) : (g = d.rect(l, c, a.viH, n, m), g.translate(b - k + h, f));
            d.setCN(a.chart, g, "guide-fill");
            e.id && d.setCN(a.chart, g, "guide-fill-" + e.id);
            this.set = l.set([g])
        },
        graphics: function() {
            return this.set
        },
        getLabel: function() {}
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmChart = d.Class({
        construct: function(a) {
            this.svgIcons = this.tapToActivate = !0;
            this.theme = a;
            this.classNamePrefix = "amcharts";
            this.addClassNames = !1;
            this.version = "3.16.0";
            d.addChart(this);
            this.createEvents("dataUpdated", "init", "rendered", "drawn", "failed", "resized");
            this.height = this.width = "100%";
            this.dataChanged = !0;
            this.chartCreated = !1;
            this.previousWidth = this.previousHeight = 0;
            this.backgroundColor = "#FFFFFF";
            this.borderAlpha = this.backgroundAlpha = 0;
            this.color = this.borderColor = "#000000";
            this.fontFamily = "Verdana";
            this.fontSize = 11;
            this.usePrefixes = !1;
            this.autoResize = !0;
            this.autoDisplay = !1;
            this.addCodeCredits = !0;
            this.precision = -1;
            this.percentPrecision = 2;
            this.decimalSeparator = ".";
            this.thousandsSeparator = ",";
            this.labels = [];
            this.allLabels = [];
            this.titles = [];
            this.marginRight = this.marginLeft = this.autoMarginOffset = 0;
            this.timeOuts = [];
            this.creditsPosition = "top-left";
            var b = document.createElement("div"),
                c = b.style;
            c.overflow = "hidden";
            c.position = "relative";
            c.textAlign = "left";
            this.chartDiv = b;
            b = document.createElement("div");
            c = b.style;
            c.overflow = "hidden";
            c.position = "relative";
            c.textAlign = "left";
            this.legendDiv = b;
            this.titleHeight = 0;
            this.hideBalloonTime = 150;
            this.handDrawScatter = 2;
            this.handDrawThickness = 1;
            this.prefixesOfBigNumbers = [{
                number: 1E3,
                prefix: "k"
            }, {
                number: 1E6,
                prefix: "M"
            }, {
                number: 1E9,
                prefix: "G"
            }, {
                number: 1E12,
                prefix: "T"
            }, {
                number: 1E15,
                prefix: "P"
            }, {
                number: 1E18,
                prefix: "E"
            }, {
                number: 1E21,
                prefix: "Z"
            }, {
                number: 1E24,
                prefix: "Y"
            }];
            this.prefixesOfSmallNumbers = [{
                number: 1E-24,
                prefix: "y"
            }, {
                number: 1E-21,
                prefix: "z"
            }, {
                number: 1E-18,
                prefix: "a"
            }, {
                number: 1E-15,
                prefix: "f"
            }, {
                number: 1E-12,
                prefix: "p"
            }, {
                number: 1E-9,
                prefix: "n"
            }, {
                number: 1E-6,
                prefix: "\u03bc"
            }, {
                number: .001,
                prefix: "m"
            }];
            this.panEventsEnabled = !0;
            this.product = "amcharts";
            this.animations = [];
            this.balloon = new d.AmBalloon(this.theme);
            this.balloon.chart = this;
            d.applyTheme(this, a, "AmChart")
        },
        drawChart: function() {
            0 < this.realWidth && 0 < this.realHeight && (this.drawBackground(), this.redrawLabels(), this.drawTitles(), this.brr(), this.renderFix())
        },
        drawBackground: function() {
            d.remove(this.background);
            var a = this.container,
                b = this.backgroundColor,
                c = this.backgroundAlpha,
                e = this.set;
            d.isModern || 0 !== c || (c = .001);
            var h = this.updateWidth();
            this.realWidth = h;
            var f = this.updateHeight();
            this.realHeight = f;
            b = d.polygon(a, [0, h - 1, h - 1, 0], [0, 0, f - 1, f - 1], b, c, 1, this.borderColor, this.borderAlpha);
            d.setCN(this, b, "bg");
            this.background = b;
            e.push(b);
            if (b = this.backgroundImage) a = a.image(b, 0, 0, h, f), d.setCN(this, b, "bg-image"), this.bgImg = a, e.push(a)
        },
        drawTitles: function(a) {
            var b = this.titles;
            this.titleHeight = 0;
            if (d.ifArray(b)) {
                var c = 20,
                    e;
                for (e = 0; e < b.length; e++) {
                    var h = b[e],
                        h = d.processObject(h, d.Title, this.theme);
                    if (!1 !== h.enabled) {
                        var f = h.color;
                        void 0 === f && (f = this.color);
                        var g = h.size;
                        isNaN(g) && (g = this.fontSize + 2);
                        isNaN(h.alpha);
                        var k = this.marginLeft,
                            f = d.wrappedText(this.container, h.text, f, this.fontFamily, g, "middle", !1, this.divRealWidth - 20);
                        f.translate(k + (this.realWidth - this.marginRight - k) / 2, c);
                        f.node.style.pointerEvents = "none";
                        h.sprite = f;
                        d.setCN(this, f, "title");
                        h.id && d.setCN(this, f, "title-" + h.id);
                        k = !0;
                        void 0 !== h.bold && (k = h.bold);
                        k && f.attr({
                            "font-weight": "bold"
                        });
                        f.attr({
                            opacity: h.alpha
                        });
                        c += f.getBBox().height + 5;
                        a ? f.remove() : this.freeLabelsSet.push(f)
                    }
                }
                this.titleHeight = c - 10
            }
        },
        write: function(a) {
            if (a = "object" != typeof a ? document.getElementById(a) : a) {
                for (; a.firstChild;) a.removeChild(a.firstChild);
                this.div = a;
                a.style.overflow = "hidden";
                a.style.textAlign = "left";
                var b = this.chartDiv,
                    c = this.legendDiv,
                    e = this.legend,
                    h = c.style,
                    f = b.style;
                this.measure();
                this.previousHeight = this.divRealHeight;
                this.previousWidth = this.divRealWidth;
                var g, k = document.createElement("div");
                g = k.style;
                g.position = "relative";
                this.containerDiv = k;
                k.className = this.classNamePrefix + "-main-div";
                b.className = this.classNamePrefix + "-chart-div";
                a.appendChild(k);
                var l = this.exportConfig;
                l && d.AmExport && !this.AmExport && (this.AmExport = new d.AmExport(this, l));
                this.amExport && d.AmExport && (this.AmExport = d.extend(this.amExport, new d.AmExport(this), !0));
                this.AmExport && this.AmExport.init && this.AmExport.init();
                if (e)
                    if (e = this.addLegend(e, e.divId), e.enabled) switch (e.position) {
                        case "bottom":
                            k.appendChild(b);
                            k.appendChild(c);
                            break;
                        case "top":
                            k.appendChild(c);
                            k.appendChild(b);
                            break;
                        case "absolute":
                            g.width = a.style.width;
                            g.height = a.style.height;
                            h.position = "absolute";
                            f.position = "absolute";
                            void 0 !== e.left && (h.left = e.left + "px");
                            void 0 !== e.right && (h.right = e.right + "px");
                            void 0 !== e.top && (h.top = e.top + "px");
                            void 0 !== e.bottom && (h.bottom = e.bottom + "px");
                            e.marginLeft = 0;
                            e.marginRight = 0;
                            k.appendChild(b);
                            k.appendChild(c);
                            break;
                        case "right":
                            g.width = a.style.width;
                            g.height = a.style.height;
                            h.position = "relative";
                            f.position = "absolute";
                            k.appendChild(b);
                            k.appendChild(c);
                            break;
                        case "left":
                            g.width = a.style.width;
                            g.height = a.style.height;
                            h.position = "absolute";
                            f.position = "relative";
                            k.appendChild(b);
                            k.appendChild(c);
                            break;
                        case "outside":
                            k.appendChild(b)
                    } else k.appendChild(b);
                    else k.appendChild(b);
                this.listenersAdded || (this.addListeners(), this.listenersAdded = !0);
                this.initChart()
            }
        },
        createLabelsSet: function() {
            d.remove(this.labelsSet);
            this.labelsSet = this.container.set();
            this.freeLabelsSet.push(this.labelsSet)
        },
        initChart: function() {
            window.AmCharts_path && (this.path = window.AmCharts_path);
            void 0 === this.path && (this.path = d.getPath());
            void 0 === this.path && (this.path = "amcharts/");
            this.path = d.normalizeUrl(this.path);
            void 0 === this.pathToImages && (this.pathToImages = this.path + "images/");
            this.initHC || (d.callInitHandler(this), this.initHC = !0);
            d.applyLang(this.language, this);
            var a = this.numberFormatter;
            a && (isNaN(a.precision) || (this.precision = a.precision), void 0 !== a.thousandsSeparator && (this.thousandsSeparator = a.thousandsSeparator), void 0 !== a.decimalSeparator && (this.decimalSeparator = a.decimalSeparator));
            (a = this.percentFormatter) && !isNaN(a.precision) && (this.percentPrecision = a.precision);
            this.nf = {
                precision: this.precision,
                thousandsSeparator: this.thousandsSeparator,
                decimalSeparator: this.decimalSeparator
            };
            this.pf = {
                precision: this.percentPrecision,
                thousandsSeparator: this.thousandsSeparator,
                decimalSeparator: this.decimalSeparator
            };
            this.destroy();
            (a = this.container) ? (a.container.innerHTML = "", a.width = this.realWidth, a.height = this.realHeight, a.addDefs(this), this.chartDiv.appendChild(a.container)) : a = new d.AmDraw(this.chartDiv, this.realWidth, this.realHeight, this);
            this.container = a;
            this.extension = ".png";
            this.svgIcons && d.SVG && (this.extension = ".svg");
            this.checkDisplay();
            a.chart = this;
            d.VML || d.SVG ? (a.handDrawn = this.handDrawn, a.handDrawScatter = this.handDrawScatter, a.handDrawThickness = this.handDrawThickness, this.set && this.set.remove(), this.set = a.set(), this.gridSet && this.gridSet.remove(), this.gridSet = a.set(), this.cursorLineSet && this.cursorLineSet.remove(), this.cursorLineSet = a.set(), this.graphsBehindSet && this.graphsBehindSet.remove(), this.graphsBehindSet = a.set(), this.bulletBehindSet && this.bulletBehindSet.remove(), this.bulletBehindSet = a.set(), this.columnSet && this.columnSet.remove(), this.columnSet = a.set(), this.graphsSet && this.graphsSet.remove(), this.graphsSet = a.set(), this.trendLinesSet && this.trendLinesSet.remove(), this.trendLinesSet = a.set(), this.axesSet && this.axesSet.remove(), this.axesSet = a.set(), this.cursorSet && this.cursorSet.remove(), this.cursorSet = a.set(), this.scrollbarsSet && this.scrollbarsSet.remove(), this.scrollbarsSet = a.set(), this.bulletSet && this.bulletSet.remove(), this.bulletSet = a.set(), this.freeLabelsSet && this.freeLabelsSet.remove(), this.axesLabelsSet && this.axesLabelsSet.remove(), this.axesLabelsSet = a.set(), this.freeLabelsSet = a.set(), this.balloonsSet && this.balloonsSet.remove(), this.balloonsSet = a.set(), this.zoomButtonSet && this.zoomButtonSet.remove(), this.zbSet && (this.zbSet.remove(), this.zbSet = null), this.zoomButtonSet = a.set(), this.linkSet && this.linkSet.remove(), this.linkSet = a.set()) : this.fire("failed", {
                type: "failed",
                chart: this
            })
        },
        premeasure: function() {
            var a = this.div;
            if (a) {
                this.boundingRect = this.chartDiv.getBoundingClientRect();
                var b = a.offsetWidth,
                    c = a.offsetHeight;
                a.clientHeight && (b = a.clientWidth, c = a.clientHeight);
                if (b != this.mw || c != this.mh) this.mw = b, this.mh = c, this.measure()
            }
        },
        measure: function() {
            var a = this.div;
            if (a) {
                var b = this.chartDiv,
                    c = a.offsetWidth,
                    e = a.offsetHeight,
                    h = this.container;
                a.clientHeight && (c = a.clientWidth, e = a.clientHeight);
                var f = d.removePx(d.getStyle(a, "padding-left")),
                    g = d.removePx(d.getStyle(a, "padding-right")),
                    k = d.removePx(d.getStyle(a, "padding-top")),
                    l = d.removePx(d.getStyle(a, "padding-bottom"));
                isNaN(f) || (c -= f);
                isNaN(g) || (c -= g);
                isNaN(k) || (e -= k);
                isNaN(l) || (e -= l);
                f = a.style;
                a = f.width;
                f = f.height; - 1 != a.indexOf("px") && (c = d.removePx(a)); - 1 != f.indexOf("px") && (e = d.removePx(f));
                e = Math.round(e);
                c = Math.round(c);
                a = Math.round(d.toCoordinate(this.width, c));
                f = Math.round(d.toCoordinate(this.height, e));
                (c != this.previousWidth || e != this.previousHeight) && 0 < a && 0 < f && (b.style.width = a + "px", b.style.height = f + "px", b.style.padding = 0, h && h.setSize(a, f), this.balloon = d.processObject(this.balloon, d.AmBalloon, this.theme), this.balloon.setBounds(2, 2, a - 2, f));
                this.balloon.chart = this;
                this.realWidth = a;
                this.realHeight = f;
                this.divRealWidth = c;
                this.divRealHeight = e
            }
        },
        checkDisplay: function() {
            if (this.autoDisplay && this.container) {
                var a = d.rect(this.container, 10, 10),
                    b = a.getBBox();
                0 === b.width && 0 === b.height && (this.divRealHeight = this.divRealWidth = this.realHeight = this.realWidth = 0, this.previousWidth = this.previousHeight = NaN);
                a.remove()
            }
        },
        destroy: function() {
            this.chartDiv.innerHTML = "";
            this.clearTimeOuts();
            this.legend && this.legend.destroy()
        },
        clearTimeOuts: function() {
            var a = this.timeOuts;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) clearTimeout(a[b])
            }
            this.timeOuts = []
        },
        clear: function(a) {
            d.callMethod("clear", [this.chartScrollbar, this.scrollbarV, this.scrollbarH, this.chartCursor]);
            this.chartCursor = this.scrollbarH = this.scrollbarV = this.chartScrollbar = null;
            this.clearTimeOuts();
            this.container && (this.container.remove(this.chartDiv), this.container.remove(this.legendDiv));
            a || d.removeChart(this);
            if (a = this.div)
                for (; a.firstChild;) a.removeChild(a.firstChild);
            this.legend && this.legend.destroy()
        },
        setMouseCursor: function(a) {
            "auto" == a && d.isNN && (a = "default");
            this.chartDiv.style.cursor = a;
            this.legendDiv.style.cursor = a
        },
        redrawLabels: function() {
            this.labels = [];
            var a = this.allLabels;
            this.createLabelsSet();
            var b;
            for (b = 0; b < a.length; b++) this.drawLabel(a[b])
        },
        drawLabel: function(a) {
            if (this.container && !1 !== a.enabled) {
                a = d.processObject(a, d.Label, this.theme);
                var b = a.y,
                    c = a.text,
                    e = a.align,
                    h = a.size,
                    f = a.color,
                    g = a.rotation,
                    k = a.alpha,
                    l = a.bold,
                    m = d.toCoordinate(a.x, this.realWidth),
                    b = d.toCoordinate(b, this.realHeight);
                m || (m = 0);
                b || (b = 0);
                void 0 === f && (f = this.color);
                isNaN(h) && (h = this.fontSize);
                e || (e = "start");
                "left" == e && (e = "start");
                "right" == e && (e = "end");
                "center" == e && (e = "middle", g ? b = this.realHeight - b + b / 2 : m = this.realWidth / 2 - m);
                void 0 === k && (k = 1);
                void 0 === g && (g = 0);
                b += h / 2;
                c = d.text(this.container, c, f, this.fontFamily, h, e, l, k);
                c.translate(m, b);
                d.setCN(this, c, "label");
                a.id && d.setCN(this, c, "label-" + a.id);
                0 !== g && c.rotate(g);
                a.url ? (c.setAttr("cursor", "pointer"), c.click(function() {
                    d.getURL(a.url)
                })) : c.node.style.pointerEvents = "none";
                this.labelsSet.push(c);
                this.labels.push(c)
            }
        },
        addLabel: function(a, b, c, e, d, f, g, k, l, m) {
            a = {
                x: a,
                y: b,
                text: c,
                align: e,
                size: d,
                color: f,
                alpha: k,
                rotation: g,
                bold: l,
                url: m,
                enabled: !0
            };
            this.container && this.drawLabel(a);
            this.allLabels.push(a)
        },
        clearLabels: function() {
            var a = this.labels,
                b;
            for (b = a.length - 1; 0 <= b; b--) a[b].remove();
            this.labels = [];
            this.allLabels = []
        },
        updateHeight: function() {
            var a = this.divRealHeight,
                b = this.legend;
            if (b) {
                var c = this.legendDiv.offsetHeight,
                    b = b.position;
                if ("top" == b || "bottom" == b) {
                    a -= c;
                    if (0 > a || isNaN(a)) a = 0;
                    this.chartDiv.style.height = a + "px"
                }
            }
            return a
        },
        updateWidth: function() {
            var a = this.divRealWidth,
                b = this.divRealHeight,
                c = this.legend;
            if (c) {
                var e = this.legendDiv,
                    d = e.offsetWidth;
                isNaN(c.width) || (d = c.width);
                c.ieW && (d = c.ieW);
                var f = e.offsetHeight,
                    e = e.style,
                    g = this.chartDiv.style,
                    c = c.position;
                if ("right" == c || "left" == c) {
                    a -= d;
                    if (0 > a || isNaN(a)) a = 0;
                    g.width = a + "px";
                    this.balloon.setBounds(2, 2, a - 2, this.realHeight);
                    "left" == c ? (g.left = d + "px", e.left = "0px") : (g.left = "0px", e.left = a + "px");
                    b > f && (e.top = (b - f) / 2 + "px")
                }
            }
            return a
        },
        getTitleHeight: function() {
            this.drawTitles(!0);
            return this.titleHeight
        },
        addTitle: function(a, b, c, e, d) {
            isNaN(b) && (b = this.fontSize + 2);
            a = {
                text: a,
                size: b,
                color: c,
                alpha: e,
                bold: d,
                enabled: !0
            };
            this.titles.push(a);
            return a
        },
        handleWheel: function(a) {
            var b = 0;
            a || (a = window.event);
            a.wheelDelta ? b = a.wheelDelta / 120 : a.detail && (b = -a.detail / 3);
            b && this.handleWheelReal(b, a.shiftKey);
            a.preventDefault && a.preventDefault()
        },
        handleWheelReal: function() {},
        handleDocTouchStart: function() {
            this.hideBalloonReal();
            this.handleMouseMove();
            this.tmx = this.mouseX;
            this.tmy = this.mouseY
        },
        handleDocTouchEnd: function() {
            -.5 < this.tmx && this.tmx < this.divRealWidth + 1 && 0 < this.tmy && this.tmy < this.divRealHeight ? (this.handleMouseMove(), 4 > Math.abs(this.mouseX - this.tmx) && 4 > Math.abs(this.mouseY - this.tmy) && (this.tapped = !0)) : this.tapped = !1
        },
        addListeners: function() {
            var a = this,
                b = a.chartDiv;
            document.addEventListener ? (a.panEventsEnabled && (b.style.msTouchAction = "none"), "ontouchstart" in document.documentElement && (b.addEventListener("touchstart", function(b) {
                a.handleTouchStart.call(a, b)
            }, !0), b.addEventListener("touchmove", function(b) {
                a.handleMouseMove.call(a, b)
            }, !0), b.addEventListener("touchend", function(b) {
                a.handleTouchEnd.call(a, b)
            }, !0), document.addEventListener("touchstart", function(b) {
                a.handleDocTouchStart.call(a, b)
            }), document.addEventListener("touchend", function(b) {
                a.handleDocTouchEnd.call(a, b)
            })), b.addEventListener("mousedown", function(b) {
                a.mouseIsOver = !0;
                a.handleMouseMove.call(a, b);
                a.handleMouseDown.call(a, b)
            }, !0), b.addEventListener("mouseover", function(b) {
                a.handleMouseOver.call(a, b)
            }, !0), b.addEventListener("mouseout", function(b) {
                a.handleMouseOut.call(a, b)
            }, !0)) : (b.attachEvent("onmousedown", function(b) {
                a.handleMouseDown.call(a, b)
            }), b.attachEvent("onmouseover", function(b) {
                a.handleMouseOver.call(a, b)
            }), b.attachEvent("onmouseout", function(b) {
                a.handleMouseOut.call(a, b)
            }))
        },
        dispDUpd: function() {
            if (!this.skipEvents) {
                var a;
                this.dispatchDataUpdated && (this.dispatchDataUpdated = !1, a = "dataUpdated", this.fire(a, {
                    type: a,
                    chart: this
                }));
                this.chartCreated || (this.chartCreated = !0, a = "init", this.fire(a, {
                    type: a,
                    chart: this
                }));
                this.chartRendered || (a = "rendered", this.fire(a, {
                    type: a,
                    chart: this
                }), this.chartRendered = !0);
                a = "drawn";
                this.fire(a, {
                    type: a,
                    chart: this
                })
            }
            this.skipEvents = !1
        },
        validateSize: function() {
            var a = this;
            a.premeasure();
            a.checkDisplay();
            if (a.divRealWidth != a.previousWidth || a.divRealHeight != a.previousHeight) {
                var b = a.legend;
                if (0 < a.realWidth && 0 < a.realHeight) {
                    a.sizeChanged = !0;
                    if (b) {
                        a.legendInitTO && clearTimeout(a.legendInitTO);
                        var c = setTimeout(function() {
                            b.invalidateSize()
                        }, 10);
                        a.timeOuts.push(c);
                        a.legendInitTO = c
                    }
                    "xy" != a.type ? a.marginsUpdated = !1 : (a.marginsUpdated = !0, a.selfZoom = !0);
                    clearTimeout(a.initTO);
                    c = setTimeout(function() {
                        a.initChart()
                    }, 10);
                    a.timeOuts.push(c);
                    a.initTO = c
                }
                a.fire("resized", {
                    type: "resized",
                    chart: a
                });
                a.renderFix();
                b && b.renderFix && b.renderFix();
                a.previousHeight = a.divRealHeight;
                a.previousWidth = a.divRealWidth
            }
        },
        invalidateSize: function() {
            this.previousHeight = this.previousWidth = NaN;
            this.invalidateSizeReal()
        },
        invalidateSizeReal: function() {
            var a = this;
            a.marginsUpdated = !1;
            clearTimeout(a.validateTO);
            var b = setTimeout(function() {
                a.validateSize()
            }, 5);
            a.timeOuts.push(b);
            a.validateTO = b
        },
        validateData: function(a) {
            this.chartCreated && (this.dataChanged = !0, this.marginsUpdated = !1, this.initChart(a))
        },
        validateNow: function(a, b) {
            this.initTO && clearTimeout(this.initTO);
            a && (this.dataChanged = !0);
            this.skipEvents = b;
            this.chartRendered = !1;
            this.write(this.div)
        },
        showItem: function(a) {
            a.hidden = !1;
            this.initChart()
        },
        hideItem: function(a) {
            a.hidden = !0;
            this.initChart()
        },
        hideBalloon: function() {
            var a = this;
            clearTimeout(a.hoverInt);
            clearTimeout(a.balloonTO);
            a.hoverInt = setTimeout(function() {
                a.hideBalloonReal.call(a)
            }, a.hideBalloonTime)
        },
        cleanChart: function() {},
        hideBalloonReal: function() {
            var a = this.balloon;
            a && a.hide()
        },
        showBalloon: function(a, b, c, e, d) {
            var f = this;
            clearTimeout(f.balloonTO);
            clearTimeout(f.hoverInt);
            f.balloonTO = setTimeout(function() {
                f.showBalloonReal.call(f, a, b, c, e, d)
            }, 1)
        },
        showBalloonReal: function(a, b, c, e, d) {
            this.handleMouseMove();
            var f = this.balloon;
            f.enabled && (f.followCursor(!1), f.changeColor(b), !c || f.fixedPosition ? (f.setPosition(e, d), isNaN(e) || isNaN(d) ? f.followCursor(!0) : f.followCursor(!1)) : f.followCursor(!0), a && f.showBalloon(a))
        },
        handleMouseOver: function() {
            this.outTO && clearTimeout(this.outTO);
            d.resetMouseOver();
            this.mouseIsOver = !0
        },
        handleMouseOut: function() {
            var a = this;
            a.outTO && clearTimeout(a.outTO);
            a.outTO = setTimeout(function() {
                a.handleMouseOutReal()
            }, 10)
        },
        handleMouseOutReal: function() {
            d.resetMouseOver();
            this.mouseIsOver = !1
        },
        handleMouseMove: function(a) {
            a || (a = window.event);
            if (a) {
                if (a.touches) {
                    if (a = a.touches.item(0), !a) return
                } else this.wasTouched = !1;
                this.boundingRect && a.clientX && (this.mouseX = a.clientX - this.boundingRect.left, this.mouseY = a.clientY - this.boundingRect.top)
            }
        },
        handleTouchStart: function(a) {
            this.hideBalloonReal();
            a && (a.touches && this.tapToActivate && !this.tapped || !this.panRequired) || (this.handleMouseMove(a), this.handleMouseDown(a))
        },
        handleTouchEnd: function(a) {
            this.wasTouched = !0;
            this.handleMouseMove(a);
            d.resetMouseOver();
            this.handleReleaseOutside(a)
        },
        handleReleaseOutside: function() {},
        handleMouseDown: function(a) {
            d.resetMouseOver();
            this.mouseIsOver = !0;
            a && a.preventDefault && (this.panEventsEnabled ? a.preventDefault() : a.touches || a.preventDefault())
        },
        addLegend: function(a, b) {
            a = d.processObject(a, d.AmLegend, this.theme);
            a.divId = b;
            a.ieW = 0;
            var c;
            c = "object" != typeof b && b ? document.getElementById(b) : b;
            this.legend = a;
            a.chart = this;
            c ? (a.div = c, a.position = "outside", a.autoMargins = !1) : a.div = this.legendDiv;
            return a
        },
        removeLegend: function() {
            this.legend = void 0;
            this.legendDiv.innerHTML = ""
        },
        handleResize: function() {
            (d.isPercents(this.width) || d.isPercents(this.height)) && this.invalidateSizeReal();
            this.renderFix()
        },
        renderFix: function() {
            if (!d.VML) {
                var a = this.container;
                a && a.renderFix()
            }
        },
        getSVG: function() {
            if (d.hasSVG) return this.container
        },
        animate: function(a, b, c, e, h, f, g) {
            a["an_" + b] && d.removeFromArray(this.animations, a["an_" + b]);
            c = {
                obj: a,
                frame: 0,
                attribute: b,
                from: c,
                to: e,
                time: h,
                effect: f,
                suffix: g
            };
            a["an_" + b] = c;
            this.animations.push(c);
            return c
        },
        setLegendData: function(a) {
            var b = this.legend;
            b && b.setData(a)
        },
        stopAnim: function(a) {
            d.removeFromArray(this.animations, a)
        },
        updateAnimations: function() {
            var a;
            this.container && this.container.update();
            if (this.animations)
                for (a = this.animations.length - 1; 0 <= a; a--) {
                    var b = this.animations[a],
                        c = 1E3 * b.time / d.updateRate,
                        e = b.frame + 1,
                        h = b.obj,
                        f = b.attribute;
                    if (e <= c) {
                        b.frame++;
                        var g = Number(b.from),
                            k = Number(b.to) - g,
                            c = d[b.effect](0, e, g, k, c);
                        0 === k ? (this.animations.splice(a, 1), h.node.style[f] = Number(b.to) + b.suffix) : h.node.style[f] = c + b.suffix
                    } else h.node.style[f] = Number(b.to) + b.suffix, this.animations.splice(a, 1)
                }
        },
        update: function() {
            this.updateAnimations()
        },
        inIframe: function() {
            try {
                return window.self !== window.top
            } catch (a) {
                return !0
            }
        },
        brr: function() {
            var a = "cryptocompare.com",
                b = window.location.hostname.split("."),
                c;
            2 <= b.length && (c = b[b.length - 2] + "." + b[b.length - 1]);
            this.amLink && (b = this.amLink.parentNode) && b.removeChild(this.amLink);
            b = this.creditsPosition;
            if (c != a || !0 === this.inIframe()) {
                var a = "https://www." + a,
                    e = c = 0,
                    d = this.realWidth,
                    f = this.realHeight,
                    g = this.type;
                if ("serial" == g || "xy" == g || "gantt" == g) c = this.marginLeftReal, e = this.marginTopReal, d = c + this.plotAreaWidth, f = e + this.plotAreaHeight;
                var g = a + "/",
                    k = "CryptoCompare Charts",
                    l = "CryptoCompare.com";
                "ammap" == this.product && (g = a + "/", k = "CryptoCompare.com", l = "CryptoCompare.com");
                a = document.createElement("a");
                l = document.createTextNode(l);
                a.setAttribute("href", g);
                a.setAttribute("title", k);
                a.appendChild(l);
                this.chartDiv.appendChild(a);
                this.amLink = a;
                g = a.style;
                g.position = "absolute";
                g.textDecoration = "none";
                g.color = this.color;
                g.fontFamily = this.fontFamily;
                g.fontSize = this.fontSize + "px";
                g.opacity = .7;
                g.display = "block";
                var k = a.offsetWidth,
                    a = a.offsetHeight,
                    l = 5 + c,
                    m = e + 5;
                "bottom-left" == b && (l = 5 + c, m = f - a - 3);
                "bottom-right" == b && (l = d - k - 5, m = f - a - 3);
                "top-right" == b && (l = d - k - 5, m = e + 5);
                g.left = l + "px";
                g.top = m + "px"
            }
        }
    });
    d.Slice = d.Class({
        construct: function() {}
    });
    d.SerialDataItem = d.Class({
        construct: function() {}
    });
    d.GraphDataItem = d.Class({
        construct: function() {}
    });
    d.Guide = d.Class({
        construct: function(a) {
            this.cname = "Guide";
            d.applyTheme(this, a, this.cname)
        }
    });
    d.Title = d.Class({
        construct: function(a) {
            this.cname = "Title";
            d.applyTheme(this, a, this.cname)
        }
    });
    d.Label = d.Class({
        construct: function(a) {
            this.cname = "Label";
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmGraph = d.Class({
        construct: function(a) {
            this.cname = "AmGraph";
            this.createEvents("rollOverGraphItem", "rollOutGraphItem", "clickGraphItem", "doubleClickGraphItem", "rightClickGraphItem", "clickGraph", "rollOverGraph", "rollOutGraph");
            this.type = "line";
            this.stackable = !0;
            this.columnCount = 1;
            this.columnIndex = 0;
            this.centerCustomBullets = this.showBalloon = !0;
            this.maxBulletSize = 50;
            this.minBulletSize = 4;
            this.balloonText = "[[value]]";
            this.hidden = this.scrollbar = this.animationPlayed = !1;
            this.pointPosition = "middle";
            this.depthCount = 1;
            this.includeInMinMax = !0;
            this.negativeBase = 0;
            this.visibleInLegend = !0;
            this.showAllValueLabels = !1;
            this.showBulletsAt = this.showBalloonAt = "close";
            this.lineThickness = 1;
            this.dashLength = 0;
            this.connect = !0;
            this.lineAlpha = 1;
            this.bullet = "none";
            this.bulletBorderThickness = 2;
            this.bulletBorderAlpha = 0;
            this.bulletAlpha = 1;
            this.bulletSize = 8;
            this.cornerRadiusTop = this.hideBulletsCount = this.bulletOffset = 0;
            this.cursorBulletAlpha = 1;
            this.gradientOrientation = "vertical";
            this.dy = this.dx = 0;
            this.periodValue = "";
            this.clustered = !0;
            this.periodSpan = 1;
            this.y = this.x = 0;
            this.switchable = !0;
            this.tcc = this.minDistance = 1;
            this.labelRotation = 0;
            this.labelAnchor = "auto";
            this.labelOffset = 3;
            this.bcn = "graph-";
            this.dateFormat = "MMM DD, YYYY";
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this.chart,
                b = a.type;
            isNaN(this.precision) || (this.numberFormatter ? this.numberFormatter.precision = this.precision : this.numberFormatter = {
                precision: this.precision,
                decimalSeparator: a.decimalSeparator,
                thousandsSeparator: a.thousandsSeparator
            });
            var c = a.container;
            this.container = c;
            this.destroy();
            var e = c.set(),
                h = c.set();
            this.behindColumns ? (a.graphsBehindSet.push(e), a.bulletBehindSet.push(h)) : (a.graphsSet.push(e), a.bulletSet.push(h));
            var f = this.bulletAxis;
            d.isString(f) && (this.bulletAxis = a.getValueAxisById(f));
            this.bulletSet = h;
            if (!this.scrollbar) {
                var f = a.marginLeftReal,
                    g = a.marginTopReal;
                e.translate(f, g);
                h.translate(f, g)
            }
            c = c.set();
            d.remove(this.columnsSet);
            e.push(c);
            this.set = e;
            d.setCN(a, e, "graph-" + this.type);
            d.setCN(a, e, "graph-" + this.id);
            d.setCN(a, h, "graph-" + this.type);
            d.setCN(a, h, "graph-" + this.id);
            this.columnsSet = c;
            this.columnsArray = [];
            this.ownColumns = [];
            this.allBullets = [];
            this.animationArray = [];
            e = this.labelPosition;
            e || (h = this.valueAxis.stackType, e = "top", "column" == this.type && (a.rotate && (e = "right"), "100%" == h || "regular" == h) && (e = "middle"), this.labelPosition = e);
            d.ifArray(this.data) && (a = !1, "xy" == b ? this.xAxis.axisCreated && this.yAxis.axisCreated && (a = !0) : this.valueAxis.axisCreated && (a = !0), !this.hidden && a && this.createGraph())
        },
        createGraph: function() {
            var a = this,
                b = a.chart;
            a.startAlpha = b.startAlpha;
            a.seqAn = b.sequencedAnimation;
            a.baseCoord = a.valueAxis.baseCoord;
            void 0 === a.fillAlphas && (a.fillAlphas = 0);
            a.bulletColorR = a.bulletColor;
            void 0 === a.bulletColorR && (a.bulletColorR = a.lineColorR, a.bulletColorNegative = a.negativeLineColor);
            void 0 === a.bulletAlpha && (a.bulletAlpha = a.lineAlpha);
            b = b.type;
            "gantt" == b && (b = "serial");
            clearTimeout(a.playedTO);
            if (!isNaN(a.valueAxis.min) && !isNaN(a.valueAxis.max)) {
                switch (b) {
                    case "serial":
                        a.categoryAxis && (a.createSerialGraph(), "candlestick" == a.type && 1 > a.valueAxis.minMaxMultiplier && a.positiveClip(a.set));
                        break;
                    case "radar":
                        a.createRadarGraph();
                        break;
                    case "xy":
                        a.createXYGraph(), a.positiveClip(a.set)
                }
                a.playedTO = setTimeout(function() {
                    a.setAnimationPlayed.call(a)
                }, 500 * a.chart.startDuration)
            }
        },
        setAnimationPlayed: function() {
            this.animationPlayed = !0
        },
        createXYGraph: function() {
            var a = [],
                b = [],
                c = this.xAxis,
                e = this.yAxis;
            this.pmh = e.viH + 1;
            this.pmw = c.viW + 1;
            this.pmy = this.pmx = 0;
            var d;
            for (d = this.start; d <= this.end; d++) {
                var f = this.data[d].axes[c.id].graphs[this.id],
                    g = f.values,
                    k = g.x,
                    l = g.y,
                    g = c.getCoordinate(k),
                    m = e.getCoordinate(l);
                !isNaN(k) && !isNaN(l) && (a.push(g), b.push(m), f.x = g, f.y = m, k = this.createBullet(f, g, m, d), l = this.labelText) && (f = this.createLabel(f, g, m, l), this.positionLabel(g, m, f, k), this.allBullets.push(f))
            }
            this.drawLineGraph(a, b);
            this.launchAnimation()
        },
        createRadarGraph: function() {
            var a = this.valueAxis.stackType,
                b = [],
                c = [],
                e = [],
                d = [],
                f, g, k, l, m;
            for (m = this.start; m <= this.end; m++) {
                var n = this.data[m].axes[this.valueAxis.id].graphs[this.id],
                    p, q;
                "none" == a || "3d" == a ? p = n.values.value : (p = n.values.close, q = n.values.open);
                if (isNaN(p)) this.connect || (this.drawLineGraph(b, c, e, d), b = [], c = [], e = [], d = []);
                else {
                    var r = this.y - (this.valueAxis.getCoordinate(p) - this.height),
                        r = r * this.valueAxis.rMultiplier,
                        u = 180 - 360 / (this.end - this.start + 1) * m;
                    "middle" == this.valueAxis.pointPosition && (u -= 180 / (this.end - this.start + 1));
                    p = r * Math.sin(u / 180 * Math.PI);
                    r *= Math.cos(u / 180 * Math.PI);
                    b.push(p);
                    c.push(r);
                    if (!isNaN(q)) {
                        var t = this.y - (this.valueAxis.getCoordinate(q) - this.height),
                            t = t * this.valueAxis.rMultiplier,
                            z = t * Math.sin(u / 180 * Math.PI),
                            u = t * Math.cos(u / 180 * Math.PI);
                        e.push(z);
                        d.push(u);
                        isNaN(k) && (k = z);
                        isNaN(l) && (l = u)
                    }
                    u = this.createBullet(n, p, r, m);
                    n.x = p;
                    n.y = r;
                    if (z = this.labelText) n = this.createLabel(n, p, r, z), this.positionLabel(p, r, n, u), this.allBullets.push(n);
                    isNaN(f) && (f = p);
                    isNaN(g) && (g = r)
                }
            }
            b.push(f);
            c.push(g);
            isNaN(k) || (e.push(k), d.push(l));
            this.drawLineGraph(b, c, e, d);
            this.launchAnimation()
        },
        positionLabel: function(a, b, c, e) {
            var d = "middle",
                f = !1,
                g = this.labelPosition,
                k = c.getBBox();
            if (e) {
                var l = e.graphDataItem,
                    m = this.chart.rotate,
                    n = l.isNegative,
                    p = this.chart,
                    q = this.valueAxis;
                b -= k.height / 4 / 2;
                switch (g) {
                    case "top":
                        g = m ? "top" : n ? "bottom" : "top";
                        break;
                    case "right":
                        g = m ? n ? "left" : "right" : "right";
                        break;
                    case "bottom":
                        g = m ? "bottom" : n ? "top" : "bottom";
                        break;
                    case "left":
                        g = m ? n ? "right" : "left" : "left"
                }
                var r = l.columnGraphics,
                    u = 0,
                    t = 0;
                r && (u = r.x, t = r.y);
                var z = this.labelOffset;
                switch (g) {
                    case "top":
                        b = q.reversed ? b + (e.size / 2 + k.height / 2 + z) : b - (e.size / 2 + k.height / 2 + z);
                        break;
                    case "right":
                        d = "start";
                        a += e.size / 2 + z;
                        break;
                    case "bottom":
                        b = q.reversed ? b - (e.size / 2 + k.height / 2 + z) : b + (e.size / 2 + k.height / 2 + z);
                        break;
                    case "left":
                        d = "end";
                        a -= e.size / 2 + z;
                        break;
                    case "inside":
                        "column" == this.type && (f = !0, m ? n ? (d = "end", a = u - 3 - z) : (d = "start", a = u + 3 + z) : b = n ? t + 7 + z : t - 10 - z);
                        break;
                    case "middle":
                        "column" == this.type && (f = !0, m ? a -= (a - u) / 2 + z - 3 : b -= (b - t) / 2 + z - 3)
                }
                "auto" != this.labelAnchor && (d = this.labelAnchor);
                c.attr({
                    "text-anchor": d
                });
                this.labelRotation && c.rotate(this.labelRotation);
                c.translate(a, b);
                k = c.getBBox();
                !this.showAllValueLabels && r && f && (k.height > l.columnHeight || k.width > l.columnWidth) && (c.remove(), c = !1);
                if (c && ("serial" == p.type || "gantt" == p.type))
                    if (m) {
                        if (0 > b || b > this.height) c.remove(), c = !1
                    } else if (0 > a || a > this.width) c.remove(), c = !1;
                return c
            }
        },
        getGradRotation: function() {
            var a = 270;
            "horizontal" == this.gradientOrientation && (a = 0);
            return this.gradientRotation = a
        },
        createSerialGraph: function() {
            this.dashLengthSwitched = this.fillColorsSwitched = this.lineColorSwitched = void 0;
            var a = this.chart,
                b = this.id,
                c = this.index,
                e = this.data,
                h = this.chart.container,
                f = this.valueAxis,
                g = this.type,
                k = this.columnWidthReal,
                l = this.showBulletsAt;
            isNaN(this.columnWidth) || (k = this.columnWidth);
            isNaN(k) && (k = .8);
            var m = this.useNegativeColorIfDown,
                n = this.width,
                p = this.height,
                q = this.y,
                r = this.rotate,
                u = this.columnCount,
                t = d.toCoordinate(this.cornerRadiusTop, k / 2),
                z = this.connect,
                y = [],
                v = [],
                w, A, B, C, D = this.chart.graphs.length,
                J, E = this.dx / this.tcc,
                O = this.dy / this.tcc,
                I = f.stackType,
                W = this.start,
                ea = this.end,
                P = this.scrollbar,
                oa = "graph-column-";
            P && (oa = "scrollbar-graph-column-");
            var qa = this.categoryAxis,
                ka = this.baseCoord,
                Ra = this.negativeBase,
                ca = this.columnIndex,
                aa = this.lineThickness,
                V = this.lineAlpha,
                sa = this.lineColorR,
                ba = this.dashLength,
                da = this.set,
                ta, fa = this.getGradRotation(),
                R = this.chart.columnSpacing,
                X = qa.cellWidth,
                wa = (X * k - u) / u;
            R > wa && (R = wa);
            var H, x, la, ga = p + 1,
                Ja = n + 1,
                Z = 0,
                qb = 0,
                rb, sb, eb, fb, tb = this.fillColorsR,
                Ka = this.negativeFillColors,
                Da = this.negativeLineColor,
                Wa = this.fillAlphas,
                Xa = this.negativeFillAlphas;
            "object" == typeof Wa && (Wa = Wa[0]);
            "object" == typeof Xa && (Xa = Xa[0]);
            var gb = f.getCoordinate(f.min);
            f.logarithmic && (gb = f.getCoordinate(f.minReal));
            this.minCoord = gb;
            this.resetBullet && (this.bullet = "none");
            if (!(P || "line" != g && "smoothedLine" != g && "step" != g || (1 == e.length && "step" != g && "none" == this.bullet && (this.bullet = "round", this.resetBullet = !0), !Ka && void 0 == Da || m))) {
                var Sa = Ra;
                Sa > f.max && (Sa = f.max);
                Sa < f.min && (Sa = f.min);
                f.logarithmic && (Sa = f.minReal);
                var Ga = f.getCoordinate(Sa),
                    Ib = f.getCoordinate(f.max);
                r ? (ga = p, Ja = Math.abs(Ib - Ga) + 1, rb = p, sb = Math.abs(gb - Ga) + 1, fb = qb = 0, f.reversed ? (Z = 0, eb = Ga) : (Z = Ga, eb = 0)) : (Ja = n, ga = Math.abs(Ib - Ga) + 1, sb = n, rb = Math.abs(gb - Ga) + 1, eb = Z = 0, f.reversed ? (fb = q, qb = Ga) : fb = Ga + 1)
            }
            var Ha = Math.round;
            this.pmx = Ha(Z);
            this.pmy = Ha(qb);
            this.pmh = Ha(ga);
            this.pmw = Ha(Ja);
            this.nmx = Ha(eb);
            this.nmy = Ha(fb);
            this.nmh = Ha(rb);
            this.nmw = Ha(sb);
            d.isModern || (this.nmy = this.nmx = 0, this.nmh = this.height);
            this.clustered || (u = 1);
            k = "column" == g ? (X * k - R * (u - 1)) / u : X * k;
            1 > k && (k = 1);
            var Jb = this.fixedColumnWidth;
            isNaN(Jb) || (k = Jb);
            var K;
            if ("line" == g || "step" == g || "smoothedLine" == g) {
                if (0 < W) {
                    for (K = W - 1; - 1 < K; K--)
                        if (H = e[K], x = H.axes[f.id].graphs[b], la = x.values.value, !isNaN(la)) {
                            W = K;
                            break
                        }
                    if (this.lineColorField)
                        for (K = W; - 1 < K; K--)
                            if (H = e[K], x = H.axes[f.id].graphs[b], x.lineColor) {
                                this.bulletColorSwitched = this.lineColorSwitched = x.lineColor;
                                break
                            }
                    if (this.fillColorsField)
                        for (K = W; - 1 < K; K--)
                            if (H = e[K], x = H.axes[f.id].graphs[b], x.fillColors) {
                                this.fillColorsSwitched = x.fillColors;
                                break
                            }
                    if (this.dashLengthField)
                        for (K = W; - 1 < K; K--)
                            if (H = e[K], x = H.axes[f.id].graphs[b], !isNaN(x.dashLength)) {
                                this.dashLengthSwitched = x.dashLength;
                                break
                            }
                }
                if (ea < e.length - 1)
                    for (K = ea + 1; K < e.length; K++)
                        if (H = e[K], x = H.axes[f.id].graphs[b], la = x.values.value, !isNaN(la)) {
                            ea = K;
                            break
                        }
            }
            ea < e.length - 1 && ea++;
            var S = [],
                T = [],
                La = !1;
            if ("line" == g || "step" == g || "smoothedLine" == g)
                if (this.stackable && "regular" == I || "100%" == I || this.fillToGraph) La = !0;
            var Kb = this.noStepRisers,
                hb = -1E3,
                ib = -1E3,
                jb = this.minDistance,
                Ma = !0,
                Ya = !1;
            for (K = W; K <= ea; K++) {
                H = e[K];
                x = H.axes[f.id].graphs[b];
                x.index = K;
                var Za, Na = NaN;
                if (m && void 0 == this.openField)
                    for (var ub = K + 1; ub < e.length && (!e[ub] || !(Za = e[K + 1].axes[f.id].graphs[b]) || !Za.values || (Na = Za.values.value, isNaN(Na))); ub++);
                var U, Q, M, ha, ma = NaN,
                    G = NaN,
                    F = NaN,
                    N = NaN,
                    L = NaN,
                    Oa = NaN,
                    Ea = NaN,
                    Pa = NaN,
                    Fa = NaN,
                    ya = NaN,
                    za = NaN,
                    ia = NaN,
                    ja = NaN,
                    Y = NaN,
                    vb = NaN,
                    wb = NaN,
                    na = NaN,
                    pa = void 0,
                    Ia = tb,
                    Ta = Wa,
                    Ba = sa,
                    ua, xa, xb = this.proCandlesticks,
                    kb = this.topRadius,
                    $a = this.pattern;
                void 0 != x.pattern && ($a = x.pattern);
                isNaN(x.alpha) || (Ta = x.alpha);
                isNaN(x.dashLength) || (ba = x.dashLength);
                var Ca = x.values;
                f.recalculateToPercents && (Ca = x.percents);
                if (Ca) {
                    Y = this.stackable && "none" != I && "3d" != I ? Ca.close : Ca.value;
                    if ("candlestick" == g || "ohlc" == g) Y = Ca.close, wb = Ca.low, Ea = f.getCoordinate(wb), vb = Ca.high, Fa = f.getCoordinate(vb);
                    na = Ca.open;
                    F = f.getCoordinate(Y);
                    isNaN(na) || (L = f.getCoordinate(na), m && (Na = na, na = L = NaN));
                    m && (void 0 == this.openField ? Za && (Za.isNegative = Na < Y ? !0 : !1, isNaN(Na) && (x.isNegative = !Ma)) : x.isNegative = Na > Y ? !0 : !1);
                    if (!P) switch (this.showBalloonAt) {
                        case "close":
                            x.y = F;
                            break;
                        case "open":
                            x.y = L;
                            break;
                        case "high":
                            x.y = Fa;
                            break;
                        case "low":
                            x.y = Ea
                    }
                    var ma = H.x[qa.id],
                        Ua = this.periodSpan - 1,
                        ra = Math.floor(X / 2) + Math.floor(Ua * X / 2),
                        Aa = ra,
                        lb = 0;
                    "left" == this.stepDirection && (lb = (2 * X + Ua * X) / 2, ma -= lb);
                    "center" == this.stepDirection && (lb = X / 2, ma -= lb);
                    "start" == this.pointPosition && (ma -= X / 2 + Math.floor(Ua * X / 2), ra = 0, Aa = Math.floor(X) + Math.floor(Ua * X));
                    "end" == this.pointPosition && (ma += X / 2 + Math.floor(Ua * X / 2), ra = Math.floor(X) + Math.floor(Ua * X), Aa = 0);
                    if (Kb) {
                        var yb = this.columnWidth;
                        isNaN(yb) || (ra *= yb, Aa *= yb)
                    }
                    P || (x.x = ma); - 1E5 > ma && (ma = -1E5);
                    ma > n + 1E5 && (ma = n + 1E5);
                    r ? (G = F, N = L, L = F = ma, isNaN(na) && !this.fillToGraph && (N = ka), Oa = Ea, Pa = Fa) : (N = G = ma, isNaN(na) && !this.fillToGraph && (L = ka));
                    if (!xb && Y < na || xb && Y < ta) x.isNegative = !0, Ka && (Ia = Ka), Xa && (Ta = Xa), void 0 != Da && (Ba = Da);
                    Ya = !1;
                    isNaN(Y) || (m ? Y > Na ? (Ma && (Ya = !0), Ma = !1) : (Ma || (Ya = !0), Ma = !0) : x.isNegative = Y < Ra ? !0 : !1, ta = Y);
                    var Lb = !1;
                    P && a.chartScrollbar.ignoreCustomColors && (Lb = !0);
                    Lb || (void 0 != x.color && (Ia = x.color), x.fillColors && (Ia = x.fillColors));
                    switch (g) {
                        case "line":
                            if (isNaN(Y)) z || (this.drawLineGraph(y, v, S, T), y = [], v = [], S = [], T = []);
                            else {
                                if (Math.abs(G - hb) >= jb || Math.abs(F - ib) >= jb) y.push(G), v.push(F), hb = G, ib = F;
                                ya = G;
                                za = F;
                                ia = G;
                                ja = F;
                                !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L));
                                if (Ya || void 0 != x.lineColor || void 0 != x.fillColors || !isNaN(x.dashLength)) this.drawLineGraph(y, v, S, T), y = [G], v = [F], S = [], T = [], !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L)), m ? Ma ? (this.lineColorSwitched = sa, this.fillColorsSwitched = tb) : (this.lineColorSwitched = Da, this.fillColorsSwitched = Ka) : (this.lineColorSwitched = x.lineColor, this.fillColorsSwitched = x.fillColors), this.dashLengthSwitched = x.dashLength;
                                x.gap && (this.drawLineGraph(y, v, S, T), y = [], v = [], S = [], T = [])
                            }
                            break;
                        case "smoothedLine":
                            if (isNaN(Y)) z || (this.drawSmoothedGraph(y, v, S, T), y = [], v = [], S = [], T = []);
                            else {
                                if (Math.abs(G -
                                        hb) >= jb || Math.abs(F - ib) >= jb) y.push(G), v.push(F), hb = G, ib = F;
                                ya = G;
                                za = F;
                                ia = G;
                                ja = F;
                                !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L));
                                void 0 == x.lineColor && void 0 == x.fillColors && isNaN(x.dashLength) || (this.drawSmoothedGraph(y, v, S, T), y = [G], v = [F], S = [], T = [], !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L)), this.lineColorSwitched = x.lineColor, this.fillColorsSwitched = x.fillColors, this.dashLengthSwitched = x.dashLength);
                                x.gap && (this.drawSmoothedGraph(y, v, S, T), y = [], v = [], S = [], T = [])
                            }
                            break;
                        case "step":
                            if (!isNaN(Y)) {
                                r ? (isNaN(w) || (y.push(w), v.push(F - ra)), v.push(F - ra), y.push(G), v.push(F + Aa), y.push(G), !La || isNaN(L) || isNaN(N) || (isNaN(B) || (S.push(B), T.push(L - ra)), S.push(N), T.push(L - ra), S.push(N), T.push(L + Aa))) : (isNaN(A) || (v.push(A), y.push(G - ra)), y.push(G - ra), v.push(F), y.push(G + Aa), v.push(F), !La || isNaN(L) || isNaN(N) || (isNaN(C) || (S.push(N - ra), T.push(C)), S.push(N - ra), T.push(L), S.push(N + Aa), T.push(L)));
                                w = G;
                                A = F;
                                B = N;
                                C = L;
                                ya = G;
                                za = F;
                                ia = G;
                                ja = F;
                                if (Ya || void 0 != x.lineColor || void 0 != x.fillColors || !isNaN(x.dashLength)) {
                                    var Zb = y[y.length - 2],
                                        $b = v[v.length - 2];
                                    y.pop();
                                    v.pop();
                                    this.drawLineGraph(y, v, S, T);
                                    y = [Zb];
                                    v = [$b];
                                    r ? (v.push(F + Aa), y.push(G)) : (y.push(G + Aa), v.push(F));
                                    S = [];
                                    T = [];
                                    this.lineColorSwitched = x.lineColor;
                                    this.fillColorsSwitched = x.fillColors;
                                    this.dashLengthSwitched = x.dashLength;
                                    m && (Ma ? (this.lineColorSwitched = sa, this.fillColorsSwitched = tb) : (this.lineColorSwitched = Da, this.fillColorsSwitched = Ka))
                                }
                                if (Kb || x.gap) w = A = NaN, this.drawLineGraph(y, v, S, T), y = [], v = [], S = [], T = []
                            } else if (!z) {
                                if (1 >= this.periodSpan || 1 < this.periodSpan && G - w > ra + Aa) w = A = NaN;
                                this.drawLineGraph(y, v, S, T);
                                y = [];
                                v = [];
                                S = [];
                                T = []
                            }
                            break;
                        case "column":
                            ua = Ba;
                            void 0 != x.lineColor && (ua = x.lineColor);
                            if (!isNaN(Y)) {
                                m || (x.isNegative = Y < Ra ? !0 : !1);
                                x.isNegative && (Ka && (Ia = Ka), void 0 != Da && (ua = Da));
                                var Mb = f.min,
                                    Nb = f.max;
                                if (!(Y < Mb && na < Mb || Y > Nb && na > Nb)) {
                                    var va;
                                    if (r) {
                                        "3d" == I ? (Q = F - (u / 2 - this.depthCount + 1) * (k + R) + R / 2 + O * ca, U = N + E * ca, va = ca) : (Q = Math.floor(F - (u / 2 - ca) * (k + R) + R / 2), U = N, va = 0);
                                        M = k;
                                        ya = G;
                                        za = Q + k / 2;
                                        isNaN(N) || N > G && !x.isNegative && (ya = N);
                                        ia = G;
                                        ja = Q + k / 2;
                                        Q + M > p + va * O && (M = p - Q + va * O);
                                        Q < va * O && (M += Q, Q = va * O);
                                        ha = G - N;
                                        var ac = U;
                                        U = d.fitToBounds(U, 0, n);
                                        ha += ac - U;
                                        ha = d.fitToBounds(ha, -U, n - U + E * ca);
                                        Q < p && 0 < M && (pa = new d.Cuboid(h, ha, M, E - a.d3x, O - a.d3y, Ia, Ta, aa, ua, V, fa, t, r, ba, $a, kb, oa), x.columnWidth = Math.abs(ha), x.columnHeight = Math.abs(M))
                                    } else {
                                        "3d" == I ? (U = G - (u / 2 - this.depthCount + 1) * (k + R) + R / 2 + E * ca, Q = L + O * ca, va = ca) : (U = G - (u / 2 - ca) * (k + R) + R / 2, Q = L, va = 0);
                                        M = k;
                                        ya = U + k / 2;
                                        za = F;
                                        isNaN(L) || L < F && !x.isNegative && !f.reversed && (za = L);
                                        ia = U + k / 2;
                                        ja = F;
                                        U + M > n + va * E && (M = n - U + va * E);
                                        U < va * E && (M += U - va * E, U = va * E);
                                        ha = F - L;
                                        var bc = Q;
                                        Q = d.fitToBounds(Q, this.dy, p);
                                        ha += bc - Q;
                                        ha = d.fitToBounds(ha, -Q + O * ca, p - Q);
                                        U < n + ca * E && 0 < M && (this.showOnAxis && (Q -= O / 2), pa = new d.Cuboid(h, M, ha, E - a.d3x, O - a.d3y, Ia, Ta, aa, ua, this.lineAlpha, fa, t, r, ba, $a, kb, oa), x.columnHeight = Math.abs(ha), x.columnWidth = Math.abs(M))
                                    }
                                }
                                if (pa && (xa = pa.set, d.setCN(a, pa.set, "graph-" + this.type), d.setCN(a, pa.set, "graph-" + this.id), x.className && d.setCN(a, pa.set, x.className, !0), x.columnGraphics = xa, xa.translate(U, Q), this.columnsSet.push(xa), (x.url || this.showHandOnHover) && xa.setAttr("cursor", "pointer"), !P)) {
                                    "none" == I && (J = r ? (this.end + 1 - K) * D - c : D * K + c);
                                    "3d" == I && (r ? (J = (this.end + 1 - K) * D - c - 1E3 * this.depthCount, ya += E * this.columnIndex, ia += E * this.columnIndex, x.y += E * this.columnIndex) : (J = (D - c) * (K + 1) + 1E3 * this.depthCount, za += O * this.columnIndex, ja += O * this.columnIndex, x.y += O * this.columnIndex));
                                    if ("regular" == I || "100%" == I) J = r ? 0 < Ca.value ? (this.end + 1 - K) * D + c : (this.end + 1 - K) * D - c : 0 < Ca.value ? D * K + c : D * K - c;
                                    this.columnsArray.push({
                                        column: pa,
                                        depth: J
                                    });
                                    x.x = r ? Q + M / 2 : U + M / 2;
                                    this.ownColumns.push(pa);
                                    this.animateColumns(pa, K, G, N, F, L);
                                    this.addListeners(xa, x)
                                }
                            }
                            break;
                        case "candlestick":
                            if (!isNaN(na) && !isNaN(Y)) {
                                var Va, ab;
                                ua = Ba;
                                void 0 != x.lineColor && (ua = x.lineColor);
                                if (r) {
                                    if (Q = F - k / 2, U = N, M = k, Q + M > p && (M = p - Q), 0 > Q && (M += Q, Q = 0), Q < p && 0 < M) {
                                        var zb, Ab;
                                        Y > na ? (zb = [G, Pa], Ab = [N, Oa]) : (zb = [N, Pa], Ab = [G, Oa]);
                                        !isNaN(Pa) && !isNaN(Oa) && F < p && 0 < F && (Va = d.line(h, zb, [F, F], ua, V, aa), ab = d.line(h, Ab, [F, F], ua, V, aa));
                                        ha = G - N;
                                        pa = new d.Cuboid(h, ha, M, E, O, Ia, Wa, aa, ua, V, fa, t, r, ba, $a, kb, oa)
                                    }
                                } else if (U = G - k / 2, Q = L + aa / 2, M = k, U + M > n && (M = n - U), 0 > U && (M += U, U = 0), ha = F - L, U < n && 0 < M) {
                                    xb && Y >= na && (Ta = 0);
                                    var pa = new d.Cuboid(h, M, ha, E, O, Ia, Ta, aa, ua, V, fa, t, r, ba, $a, kb, oa),
                                        Bb, Cb;
                                    Y > na ? (Bb = [F, Fa], Cb = [L, Ea]) : (Bb = [L, Fa], Cb = [F, Ea]);
                                    !isNaN(Fa) && !isNaN(Ea) && G < n && 0 < G && (Va = d.line(h, [G, G], Bb, ua, V, aa), ab = d.line(h, [G, G], Cb, ua, V, aa), d.setCN(a, Va, this.bcn + "line-high"), x.className && d.setCN(a, Va, x.className, !0), d.setCN(a, ab, this.bcn + "line-low"), x.className && d.setCN(a, ab, x.className, !0))
                                }
                                pa && (xa = pa.set, x.columnGraphics = xa, da.push(xa), xa.translate(U, Q - aa / 2), (x.url || this.showHandOnHover) && xa.setAttr("cursor", "pointer"), Va && (da.push(Va), da.push(ab)), ya = G, za = F, r ? (ja = F, ia = G, "open" == l && (ia = N), "high" == l && (ia = Pa), "low" == l && (ia = Oa)) : (ja = F, "open" == l && (ja = L), "high" == l && (ja = Fa), "low" == l && (ja = Ea), ia = G), P || (x.x = r ? Q + M / 2 : U + M / 2, this.animateColumns(pa, K, G, N, F, L), this.addListeners(xa, x)))
                            }
                            break;
                        case "ohlc":
                            if (!(isNaN(na) || isNaN(vb) || isNaN(wb) || isNaN(Y))) {
                                var Ob = h.set();
                                da.push(Ob);
                                Y < na && (x.isNegative = !0, void 0 != Da && (Ba = Da));
                                var mb, nb, ob;
                                if (r) {
                                    var Db = F - k / 2,
                                        Db = d.fitToBounds(Db, 0, p),
                                        Pb = d.fitToBounds(F, 0, p),
                                        Eb = F + k / 2,
                                        Eb = d.fitToBounds(Eb, 0, p);
                                    nb = d.line(h, [N, N], [Db, Pb], Ba, V, aa, ba);
                                    0 < F && F < p && (mb = d.line(h, [Oa, Pa], [F, F], Ba, V, aa, ba));
                                    ob = d.line(h, [G, G], [Pb, Eb], Ba, V, aa, ba);
                                    ja = F;
                                    ia = G;
                                    "open" == l && (ia = N);
                                    "high" == l && (ia = Pa);
                                    "low" == l && (ia = Oa)
                                } else {
                                    var Fb = G - k / 2,
                                        Fb = d.fitToBounds(Fb, 0, n),
                                        Qb = d.fitToBounds(G, 0, n),
                                        Gb = G + k / 2,
                                        Gb = d.fitToBounds(Gb, 0, n);
                                    nb = d.line(h, [Fb, Qb], [L, L], Ba, V, aa, ba);
                                    0 < G && G < n && (mb = d.line(h, [G, G], [Ea, Fa], Ba, V, aa, ba));
                                    ob = d.line(h, [Qb, Gb], [F, F], Ba, V, aa, ba);
                                    ja = F;
                                    "open" == l && (ja = L);
                                    "high" == l && (ja = Fa);
                                    "low" == l && (ja = Ea);
                                    ia = G
                                }
                                da.push(nb);
                                da.push(mb);
                                da.push(ob);
                                d.setCN(a, nb, this.bcn + "stroke-open");
                                d.setCN(a, ob, this.bcn + "stroke-close");
                                d.setCN(a, mb, this.bcn + "stroke");
                                x.className && d.setCN(a, Ob, x.className, !0);
                                ya = G;
                                za = F
                            }
                    }
                    if (!P && !isNaN(Y)) {
                        var Rb = this.hideBulletsCount;
                        if (this.end - this.start <= Rb || 0 === Rb) {
                            var Sb = this.createBullet(x, ia, ja, K),
                                Tb = this.labelText;
                            if (Tb && Sb) {
                                var Hb = this.createLabel(x, ia, ja, Tb);
                                (Hb = this.positionLabel(ya, za, Hb, Sb, M, ha)) && this.allBullets.push(Hb)
                            }
                            if ("regular" == I || "100%" == I) {
                                var Ub = f.totalText;
                                if (Ub) {
                                    var Qa = this.createLabel(x, 0, 0, Ub, f.totalTextColor);
                                    d.setCN(a, Qa, this.bcn + "label-total");
                                    this.allBullets.push(Qa);
                                    var Vb = Qa.getBBox(),
                                        Wb = Vb.width,
                                        Xb = Vb.height,
                                        bb, cb, pb = f.totalTextOffset,
                                        Yb = f.totals[K];
                                    Yb && Yb.remove();
                                    var db = 0;
                                    "column" != g && (db = this.bulletSize);
                                    r ? (cb = F, bb = 0 > Y ? G - Wb / 2 - 2 - db - pb : G + Wb / 2 + 3 + db + pb) : (bb = G, cb = 0 > Y ? F + Xb / 2 + db + pb : F - Xb / 2 - 3 - db - pb);
                                    Qa.translate(bb, cb);
                                    f.totals[K] = Qa;
                                    r ? (0 > cb || cb > p) && Qa.remove() : (0 > bb || bb > n) && Qa.remove()
                                }
                            }
                        }
                    }
                }
            }
            if ("line" == g || "step" == g || "smoothedLine" == g) "smoothedLine" == g ? this.drawSmoothedGraph(y, v, S, T) : this.drawLineGraph(y, v, S, T), P || this.launchAnimation();
            this.bulletsHidden && this.hideBullets();
            this.customBulletsHidden && this.hideCustomBullets()
        },
        animateColumns: function(a, b) {
            var c = this,
                e = c.chart.startDuration;
            0 < e && !c.animationPlayed && (c.seqAn ? (a.set.hide(), c.animationArray.push(a), e = setTimeout(function() {
                c.animate.call(c)
            }, e / (c.end - c.start + 1) * (b - c.start) * 1E3), c.timeOuts.push(e)) : c.animate(a))
        },
        createLabel: function(a, b, c, e, h) {
            var f = this.chart,
                g = a.labelColor;
            g || (g = this.color);
            g || (g = f.color);
            h && (g = h);
            h = this.fontSize;
            void 0 === h && (this.fontSize = h = f.fontSize);
            var k = this.labelFunction;
            e = f.formatString(e, a);
            e = d.cleanFromEmpty(e);
            k && (e = k(a, e));
            a = d.text(this.container, e, g, f.fontFamily, h);
            a.node.style.pointerEvents = "none";
            d.setCN(f, a, this.bcn + "label");
            a.translate(b, c);
            this.bulletSet.push(a);
            return a
        },
        positiveClip: function(a) {
            a.clipRect(this.pmx, this.pmy, this.pmw, this.pmh)
        },
        negativeClip: function(a) {
            a.clipRect(this.nmx, this.nmy, this.nmw, this.nmh)
        },
        drawLineGraph: function(a, b, c, e) {
            var h = this;
            if (1 < a.length) {
                var f = h.set,
                    g = h.chart,
                    k = h.container,
                    l = k.set(),
                    m = k.set();
                f.push(m);
                f.push(l);
                var n = h.lineAlpha,
                    p = h.lineThickness,
                    f = h.fillAlphas,
                    q = h.lineColorR,
                    r = h.negativeLineAlpha;
                isNaN(r) && (r = n);
                var u = h.lineColorSwitched;
                u && (q = u);
                var u = h.fillColorsR,
                    t = h.fillColorsSwitched;
                t && (u = t);
                var z = h.dashLength;
                (t = h.dashLengthSwitched) && (z = t);
                var t = h.negativeLineColor,
                    y = h.negativeFillColors,
                    v = h.negativeFillAlphas,
                    w = h.baseCoord;
                0 !== h.negativeBase && (w = h.valueAxis.getCoordinate(h.negativeBase), w > h.height && (w = h.height), 0 > w && (w = 0));
                n = d.line(k, a, b, q, n, p, z, !1, !0);
                d.setCN(g, n, h.bcn + "stroke");
                l.push(n);
                l.click(function(a) {
                    h.handleGraphEvent(a, "clickGraph")
                }).mouseover(function(a) {
                    h.handleGraphEvent(a, "rollOverGraph")
                }).mouseout(function(a) {
                    h.handleGraphEvent(a, "rollOutGraph")
                });
                void 0 === t || h.useNegativeColorIfDown || (p = d.line(k, a, b, t, r, p, z, !1, !0), d.setCN(g, p, h.bcn + "stroke"), d.setCN(g, p, h.bcn + "stroke-negative"), m.push(p));
                if (0 < f || 0 < v)
                    if (p = a.join(";").split(";"), r = b.join(";").split(";"), n = g.type, "serial" == n || "radar" == n ? 0 < c.length ? (c.reverse(), e.reverse(), p = a.concat(c), r = b.concat(e)) : "radar" == n ? (r.push(0), p.push(0)) : h.rotate ? (r.push(r[r.length - 1]), p.push(w), r.push(r[0]), p.push(w), r.push(r[0]), p.push(p[0])) : (p.push(p[p.length - 1]), r.push(w), p.push(p[0]), r.push(w), p.push(a[0]), r.push(r[0])) : "xy" == n && (b = h.fillToAxis) && (d.isString(b) && (b = g.getValueAxisById(b)), "H" == b.orientation ? (w = "top" == b.position ? 0 : b.viH, p.push(p[p.length - 1]), r.push(w), p.push(p[0]), r.push(w), p.push(a[0]), r.push(r[0])) : (w = "left" == b.position ? 0 : b.viW, r.push(r[r.length - 1]), p.push(w), r.push(r[0]), p.push(w), r.push(r[0]), p.push(p[0]))), a = h.gradientRotation, 0 < f && (b = d.polygon(k, p, r, u, f, 1, "#000", 0, a), b.pattern(h.pattern, NaN, g.path), d.setCN(g, b, h.bcn + "fill"), l.push(b)), y || void 0 !== t) isNaN(v) && (v = f), y || (y = t), k = d.polygon(k, p, r, y, v, 1, "#000", 0, a), d.setCN(g, k, h.bcn + "fill"), d.setCN(g, k, h.bcn + "fill-negative"), k.pattern(h.pattern, NaN, g.path), m.push(k), m.click(function(a) {
                        h.handleGraphEvent(a, "clickGraph")
                    }).mouseover(function(a) {
                        h.handleGraphEvent(a, "rollOverGraph")
                    }).mouseout(function(a) {
                        h.handleGraphEvent(a, "rollOutGraph")
                    });
                h.applyMask(m, l)
            }
        },
        applyMask: function(a, b) {
            var c = a.length();
            "serial" != this.chart.type || this.scrollbar || (this.positiveClip(b), 0 < c && this.negativeClip(a))
        },
        drawSmoothedGraph: function(a, b, c, e) {
            if (1 < a.length) {
                var h = this.set,
                    f = this.chart,
                    g = this.container,
                    k = g.set(),
                    l = g.set();
                h.push(l);
                h.push(k);
                var m = this.lineAlpha,
                    n = this.lineThickness,
                    h = this.dashLength,
                    p = this.fillAlphas,
                    q = this.lineColorR,
                    r = this.fillColorsR,
                    u = this.negativeLineColor,
                    t = this.negativeFillColors,
                    z = this.negativeFillAlphas,
                    y = this.baseCoord,
                    v = this.lineColorSwitched;
                v && (q = v);
                (v = this.fillColorsSwitched) && (r = v);
                v = this.negativeLineAlpha;
                isNaN(v) && (v = m);
                m = new d.Bezier(g, a, b, q, m, n, r, 0, h);
                d.setCN(f, m, this.bcn + "stroke");
                k.push(m.path);
                void 0 !== u && (n = new d.Bezier(g, a, b, u, v, n, r, 0, h), d.setCN(f, n, this.bcn + "stroke"), d.setCN(f, n, this.bcn + "stroke-negative"), l.push(n.path));
                0 < p && (m = a.join(";").split(";"), q = b.join(";").split(";"), n = "", 0 < c.length ? (c.push("M"), e.push("M"), c.reverse(), e.reverse(), m = a.concat(c), q = b.concat(e)) : (this.rotate ? (n += " L" + y + "," + b[b.length - 1], n += " L" + y + "," + b[0]) : (n += " L" + a[a.length - 1] + "," + y, n += " L" + a[0] + "," + y), n += " L" + a[0] + "," + b[0]), c = new d.Bezier(g, m, q, NaN, 0, 0, r, p, h, n), d.setCN(f, c, this.bcn + "fill"), c.path.pattern(this.pattern, NaN, f.path), k.push(c.path), t || void 0 !== u) && (z || (z = p), t || (t = u), a = new d.Bezier(g, a, b, NaN, 0, 0, t, z, h, n), a.path.pattern(this.pattern, NaN, f.path), d.setCN(f, a, this.bcn + "fill"), d.setCN(f, a, this.bcn + "fill-negative"), l.push(a.path));
                this.applyMask(l, k)
            }
        },
        launchAnimation: function() {
            var a = this,
                b = a.chart.startDuration;
            if (0 < b && !a.animationPlayed) {
                var c = a.set,
                    e = a.bulletSet;
                d.VML || (c.attr({
                    opacity: a.startAlpha
                }), e.attr({
                    opacity: a.startAlpha
                }));
                c.hide();
                e.hide();
                a.seqAn ? (b = setTimeout(function() {
                    a.animateGraphs.call(a)
                }, a.index * b * 1E3), a.timeOuts.push(b)) : a.animateGraphs()
            }
        },
        animateGraphs: function() {
            var a = this.chart,
                b = this.set,
                c = this.bulletSet,
                e = this.x,
                d = this.y;
            b.show();
            c.show();
            var f = a.startDuration,
                a = a.startEffect;
            b && (this.rotate ? (b.translate(-1E3, d), c.translate(-1E3, d)) : (b.translate(e, -1E3), c.translate(e, -1E3)), b.animate({
                opacity: 1,
                translate: e + "," + d
            }, f, a), c.animate({
                opacity: 1,
                translate: e + "," + d
            }, f, a))
        },
        animate: function(a) {
            var b = this.chart,
                c = this.animationArray;
            !a && 0 < c.length && (a = c[0], c.shift());
            c = d[d.getEffect(b.startEffect)];
            b = b.startDuration;
            a && (this.rotate ? a.animateWidth(b, c) : a.animateHeight(b, c), a.set.show())
        },
        legendKeyColor: function() {
            var a = this.legendColor,
                b = this.lineAlpha;
            void 0 === a && (a = this.lineColorR, 0 === b && (b = this.fillColorsR) && (a = "object" == typeof b ? b[0] : b));
            return a
        },
        legendKeyAlpha: function() {
            var a = this.legendAlpha;
            void 0 === a && (a = this.lineAlpha, this.fillAlphas > a && (a = this.fillAlphas), 0 === a && (a = this.bulletAlpha), 0 === a && (a = 1));
            return a
        },
        createBullet: function(a, b, c) {
            if (!isNaN(b) && !isNaN(c)) {
                var e = this.chart,
                    h = this.container,
                    f = this.bulletOffset,
                    g = this.bulletSize;
                isNaN(a.bulletSize) || (g = a.bulletSize);
                var k = a.values.value,
                    l = this.maxValue,
                    m = this.minValue,
                    n = this.maxBulletSize,
                    p = this.minBulletSize;
                isNaN(l) || (isNaN(k) || (g = (k - m) / (l - m) * (n - p) + p), m == l && (g = n));
                l = g;
                this.bulletAxis && (g = a.values.error, isNaN(g) || (k = g), g = this.bulletAxis.stepWidth * k);
                g < this.minBulletSize && (g = this.minBulletSize);
                this.rotate ? b = a.isNegative ? b - f : b + f : c = a.isNegative ? c + f : c - f;
                var q, p = this.bulletColorR;
                a.lineColor && (this.bulletColorSwitched = a.lineColor);
                this.bulletColorSwitched && (p = this.bulletColorSwitched);
                a.isNegative && void 0 !== this.bulletColorNegative && (p = this.bulletColorNegative);
                void 0 !== a.color && (p = a.color);
                var r;
                "xy" == e.type && this.valueField && (r = this.pattern, a.pattern && (r = a.pattern));
                f = this.bullet;
                a.bullet && (f = a.bullet);
                var k = this.bulletBorderThickness,
                    m = this.bulletBorderColorR,
                    n = this.bulletBorderAlpha,
                    u = this.bulletAlpha;
                m || (m = p);
                this.useLineColorForBulletBorder && (m = this.lineColorR, this.lineColorSwitched && (m = this.lineColorSwitched));
                var t = a.alpha;
                isNaN(t) || (u = t);
                if ("none" != this.bullet || a.bullet) q = d.bullet(h, f, g, p, u, k, m, n, l, 0, r, e.path);
                if (this.customBullet || a.customBullet) r = this.customBullet, a.customBullet && (r = a.customBullet), r && (q && q.remove(), "function" == typeof r ? (r = new r, r.chart = e, a.bulletConfig && (r.availableSpace = c, r.graph = this, r.graphDataItem = a, r.bulletY = c, a.bulletConfig.minCoord = this.minCoord - c, r.bulletConfig = a.bulletConfig), r.write(h), q && r.showBullet && r.set.push(q), a.customBulletGraphics = r.cset, q = r.set) : (q = h.set(), h = h.image(r, 0, 0, g, g), q.push(h), this.centerCustomBullets && h.translate(-g / 2, -g / 2)));
                if (q) {
                    (a.url || this.showHandOnHover) && q.setAttr("cursor", "pointer");
                    if ("serial" == e.type || "gantt" == e.type)
                        if (-.5 > b - 0 || b - 0 > this.width || c < -g / 2 || c - 0 > this.height) q.remove(), q = null;
                    q && (this.bulletSet.push(q), q.translate(b, c), this.addListeners(q, a), this.allBullets.push(q));
                    a.bx = b;
                    a.by = c;
                    d.setCN(e, q, this.bcn + "bullet");
                    a.className && d.setCN(e, q, a.className, !0)
                }
                q ? (q.size = g || 0, a.bulletGraphics = q) : q = {
                    size: 0
                };
                q.graphDataItem = a;
                return q
            }
        },
        showBullets: function() {
            var a = this.allBullets,
                b;
            this.bulletsHidden = !1;
            for (b = 0; b < a.length; b++) a[b].show()
        },
        hideBullets: function() {
            var a = this.allBullets,
                b;
            this.bulletsHidden = !0;
            for (b = 0; b < a.length; b++) a[b].hide()
        },
        showCustomBullets: function() {
            var a = this.allBullets,
                b;
            this.customBulletsHidden = !1;
            for (b = 0; b < a.length; b++) {
                var c = a[b].graphDataItem;
                c.customBulletGraphics && c.customBulletGraphics.show()
            }
        },
        hideCustomBullets: function() {
            var a = this.allBullets,
                b;
            this.customBulletsHidden = !0;
            for (b = 0; b < a.length; b++) {
                var c = a[b].graphDataItem;
                c.customBulletGraphics && c.customBulletGraphics.hide()
            }
        },
        addListeners: function(a, b) {
            var c = this;
            a.mouseover(function(a) {
                c.handleRollOver(b, a)
            }).mouseout(function(a) {
                c.handleRollOut(b, a)
            }).touchend(function(a) {
                c.handleRollOver(b, a);
                c.chart.panEventsEnabled && c.handleClick(b, a)
            }).touchstart(function(a) {
                c.handleRollOver(b, a)
            }).click(function(a) {
                c.handleClick(b, a)
            }).dblclick(function(a) {
                c.handleDoubleClick(b, a)
            }).contextmenu(function(a) {
                c.handleRightClick(b, a)
            })
        },
        handleRollOver: function(a, b) {
            if (a) {
                var c = this.chart,
                    e = {
                        type: "rollOverGraphItem",
                        item: a,
                        index: a.index,
                        graph: this,
                        target: this,
                        chart: this.chart,
                        event: b
                    };
                this.fire("rollOverGraphItem", e);
                c.fire("rollOverGraphItem", e);
                clearTimeout(c.hoverInt);
                e = this.showBalloon;
                !c.chartCursor || "serial" != c.type && "gantt" != c.type || (e = !1, !c.chartCursor.valueBalloonsEnabled && this.showBalloon && (e = !0));
                if (e) {
                    var e = c.formatString(this.balloonText, a, !0),
                        h = this.balloonFunction;
                    h && (e = h(a, a.graph));
                    e = d.cleanFromEmpty(e);
                    h = c.getBalloonColor(this, a);
                    c.balloon.showBullet = !1;
                    c.balloon.pointerOrientation = "V";
                    var f = a.x,
                        g = a.y;
                    c.rotate && (f = a.y, g = a.x);
                    "" !== e ? c.showBalloon(e, h, !0, f + c.marginLeftReal, g + c.marginTopReal) : this.chart.hideBalloonReal()
                } else this.chart.hideBalloonReal()
            }
            this.handleGraphEvent(b, "rollOverGraph")
        },
        handleRollOut: function(a, b) {
            this.chart.hideBalloon();
            if (a) {
                var c = {
                    type: "rollOutGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("rollOutGraphItem", c);
                this.chart.fire("rollOutGraphItem", c)
            }
            this.handleGraphEvent(b, "rollOutGraph")
        },
        handleClick: function(a, b) {
            if (a) {
                var c = {
                    type: "clickGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("clickGraphItem", c);
                this.chart.fire("clickGraphItem", c);
                d.getURL(a.url, this.urlTarget)
            }
            this.handleGraphEvent(b, "clickGraph")
        },
        handleGraphEvent: function(a, b) {
            var c = {
                type: b,
                graph: this,
                target: this,
                chart: this.chart,
                event: a
            };
            this.fire(b, c);
            this.chart.fire(b, c)
        },
        handleRightClick: function(a, b) {
            if (a) {
                var c = {
                    type: "rightClickGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("rightClickGraphItem", c);
                this.chart.fire("rightClickGraphItem", c)
            }
        },
        handleDoubleClick: function(a, b) {
            if (a) {
                var c = {
                    type: "doubleClickGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("doubleClickGraphItem", c);
                this.chart.fire("doubleClickGraphItem", c)
            }
        },
        zoom: function(a, b) {
            this.start = a;
            this.end = b;
            this.draw()
        },
        changeOpacity: function(a) {
            var b = this.set;
            b && b.setAttr("opacity", a);
            if (b = this.ownColumns) {
                var c;
                for (c = 0; c < b.length; c++) {
                    var e = b[c].set;
                    e && e.setAttr("opacity", a)
                }
            }(b = this.bulletSet) && b.setAttr("opacity", a)
        },
        destroy: function() {
            d.remove(this.set);
            d.remove(this.bulletSet);
            var a = this.timeOuts;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) clearTimeout(a[b])
            }
            this.timeOuts = []
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ChartCursor = d.Class({
        construct: function(a) {
            this.cname = "ChartCursor";
            this.createEvents("changed", "zoomed", "onHideCursor", "draw", "selected", "moved");
            this.enabled = !0;
            this.cursorAlpha = 1;
            this.selectionAlpha = .2;
            this.cursorColor = "#CC0000";
            this.categoryBalloonAlpha = 1;
            this.color = "#FFFFFF";
            this.type = "cursor";
            this.zoomed = !1;
            this.zoomable = !0;
            this.pan = !1;
            this.categoryBalloonDateFormat = "MMM DD, YYYY";
            this.categoryBalloonText = "[[category]]";
            this.categoryBalloonEnabled = this.valueBalloonsEnabled = !0;
            this.rolledOver = !1;
            this.cursorPosition = "middle";
            this.bulletsEnabled = this.skipZoomDispatch = !1;
            this.bulletSize = 8;
            this.selectWithoutZooming = this.oneBalloonOnly = !1;
            this.graphBulletSize = 1.7;
            this.animationDuration = .3;
            this.zooming = !1;
            this.adjustment = 0;
            this.avoidBalloonOverlapping = !0;
            this.leaveCursor = !1;
            this.leaveAfterTouch = !0;
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            this.destroy();
            var a = this.chart;
            a.panRequired = !0;
            var b = a.container;
            this.rotate = a.rotate;
            this.container = b;
            b = b.set();
            b.translate(this.x, this.y);
            this.set = b;
            a.cursorSet.push(b);
            b = new d.AmBalloon;
            b.className = "category";
            b.chart = a;
            this.categoryBalloon = b;
            d.copyProperties(a.balloon, b);
            b.cornerRadius = 0;
            b.shadowAlpha = 0;
            b.borderThickness = 1;
            b.borderAlpha = 1;
            b.showBullet = !1;
            var c = this.categoryBalloonColor;
            void 0 === c && (c = this.cursorColor);
            b.fillColor = c;
            b.balloonColor = c;
            b.fillAlpha = this.categoryBalloonAlpha;
            b.borderColor = c;
            b.color = this.color;
            c = this.valueLineAxis;
            d.isString(c) && (c = a.getValueAxisById(c));
            c || (c = a.valueAxes[0]);
            this.valueLineAxis = c;
            this.valueLineBalloonEnabled && (this.vaBalloon = c = new d.AmBalloon, d.copyProperties(b, c), c.animationDuration = 0, this.rotate || (c.pointerOrientation = "H"));
            this.rotate && (b.pointerOrientation = "H");
            this.extraWidth = 0;
            this.prevX = [];
            this.prevY = [];
            this.prevTX = [];
            this.prevTY = [];
            if (this.valueBalloonsEnabled)
                for (b = 0; b < a.graphs.length; b++) c = new d.AmBalloon, c.className = a.graphs[b].id, c.chart = a, d.copyProperties(a.balloon, c), a.graphs[b].valueBalloon = c;
            "cursor" == this.type ? this.createCursor() : this.createCrosshair()
        },
        updateData: function() {
            var a = this.chart;
            this.data = a.chartData;
            this.firstTime = a.firstTime;
            this.lastTime = a.lastTime
        },
        createCursor: function() {
            var a = this.chart,
                b = this.cursorAlpha,
                c = a.categoryAxis,
                e = this.categoryBalloon,
                h, f, g, k;
            g = a.dx;
            k = a.dy;
            var l = this.width,
                m = this.height,
                n = a.rotate;
            e.pointerWidth = c.tickLength;
            n ? (h = [0, l, l + g], f = [0, 0, k], g = [g, 0, 0], k = [k, 0, m]) : (h = [g, 0, 0], f = [k, 0, m], g = [0, l, l + g], k = [0, 0, k]);
            h = d.line(this.container, h, f, this.cursorColor, b, 1);
            d.setCN(a, h, "cursor-line");
            this.line = h;
            h.node.style.pointerEvents = "none";
            (f = this.fullRectSet) ? (f.push(h), f.translate(this.x, this.y)) : this.set.push(h);
            this.valueLineEnabled && (h = this.valueLineAlpha, isNaN(h) || (b = h), b = d.line(this.container, g, k, this.cursorColor, b, 1), b.node.style.pointerEvents = "none", d.setCN(a, b, "cursor-value-line"), this.vLine = b, this.set.push(b));
            this.setBalloonBounds(e, c, n);
            (a = this.vaBalloon) && this.setBalloonBounds(a, this.valueLineAxis, !n);
            this.hideCursor()
        },
        createCrosshair: function() {
            var a = this.cursorAlpha,
                b = this.container,
                c = d.line(b, [0, 0], [0, this.height], this.cursorColor, a, 1),
                a = d.line(b, [0, this.width], [0, 0], this.cursorColor, a, 1);
            d.setCN(this.chart, c, "cursor-line");
            d.setCN(this.chart, a, "cursor-line");
            this.set.push(c);
            this.set.push(a);
            this.vLine = c;
            this.hLine = a;
            this.hideCursor()
        },
        update: function() {
            var a = this.chart;
            if (a)
                if (a.mouseIsOver) {
                    var b = a.mouseX - this.x,
                        c = a.mouseY - this.y; - .5 < b && b < this.width + 1 && 0 < c && c < this.height ? ((this.valueLineEnabled || this.valueLineBalloonEnabled) && this.updateVLine(b, c), this.setPosition(), this.drawing ? this.rolledOver || a.setMouseCursor("crosshair") : this.pan && (this.rolledOver || a.setMouseCursor("move")), this.rolledOver = !0) : this.rolledOver && (this.handleMouseOut(), this.rolledOver = !1)
                } else this.rolledOver && (this.handleMouseOut(), this.rolledOver = !1)
        },
        updateVLine: function(a, b) {
            var c = this.vLine,
                e = this.vaBalloon;
            if ((c || e) && !this.panning && !this.drawing) {
                c && c.show();
                var d = this.valueLineAxis,
                    f, g = this.rotate;
                g ? (c && c.translate(a, 0), d && (f = d.coordinateToValue(a)), c = a) : (c && c.translate(0, b), d && (f = d.coordinateToValue(b)), c = b - 1);
                if (e && !isNaN(f) && this.prevLineValue != f) {
                    var k = d.formatValue(f, !0);
                    this.setBalloonPosition(e, d, c, !g);
                    e.showBalloon(k)
                }
                this.prevLineValue = f
            }
        },
        getMousePosition: function() {
            var a, b = this.width,
                c = this.height;
            a = this.chart;
            this.rotate ? (a = a.mouseY - this.y, 0 > a && (a = 0), a > c && (a = c)) : (a = a.mouseX - this.x - 1, 0 > a && (a = 0), a > b && (a = b));
            return a
        },
        updateCrosshair: function() {
            var a = this.chart,
                b = a.mouseX - this.x,
                c = a.mouseY - this.y,
                e = this.vLine,
                h = this.hLine,
                b = d.fitToBounds(b, 0, this.width),
                c = d.fitToBounds(c, 0, this.height);
            e && 0 < this.cursorAlpha && (e.show(), h.show(), e.translate(b, 0), h.translate(0, c));
            this.zooming && (a.hideXScrollbar && (b = NaN), a.hideYScrollbar && (c = NaN), this.updateSelectionSize(b, c));
            this.fireMoved();
            a.mouseIsOver || this.zooming || this.hideCursor()
        },
        fireMoved: function() {
            var a = this.chart,
                b = {
                    type: "moved",
                    target: this
                };
            b.chart = a;
            b.zooming = this.zooming;
            b.x = a.mouseX - this.x;
            b.y = a.mouseY - this.y;
            this.fire("moved", b)
        },
        updateSelectionSize: function(a, b) {
            d.remove(this.selection);
            var c = this.selectionPosX,
                e = this.selectionPosY,
                h = 0,
                f = 0,
                g = this.width,
                k = this.height;
            isNaN(a) || (c > a && (h = a, g = c - a), c < a && (h = c, g = a - c), c == a && (h = a, g = 0), g += this.extraWidth, h -= this.extraWidth / 2);
            isNaN(b) || (e > b && (f = b, k = e - b), e < b && (f = e, k = b - e), e == b && (f = b, k = 0), k += this.extraWidth, f -= this.extraWidth / 2);
            0 < g && 0 < k && (c = d.rect(this.container, g, k, this.cursorColor, this.selectionAlpha), d.setCN(this.chart, c, "cursor-selection"), c.translate(h + this.x, f + this.y), this.selection = c)
        },
        arrangeBalloons: function() {
            var a = this.valueBalloons,
                b = this.x,
                c = this.y,
                e = this.height + c;
            a.sort(this.compareY);
            var d;
            for (d = 0; d < a.length; d++) {
                var f = a[d].balloon;
                f.setBounds(b, c, b + this.width, e);
                f.prevX = this.prevX[d];
                f.prevY = this.prevY[d];
                f.prevTX = this.prevTX[d];
                f.prevTY = this.prevTY[d];
                f.draw();
                e = f.yPos - 3
            }
            this.arrangeBalloons2()
        },
        compareY: function(a, b) {
            return a.yy < b.yy ? 1 : -1
        },
        arrangeBalloons2: function() {
            var a = this.valueBalloons;
            a.reverse();
            var b, c = this.x,
                e, d, f = a.length;
            for (d = 0; d < f; d++) {
                var g = a[d].balloon;
                b = g.bottom;
                var k = g.bottom - g.yPos,
                    l = f - d - 1;
                0 < d && b - k < e + 3 && (g.setBounds(c, e + 3, c + this.width, e + k + 3), g.prevX = this.prevX[l], g.prevY = this.prevY[l], g.prevTX = this.prevTX[l], g.prevTY = this.prevTY[l], g.draw());
                g.set && g.set.show();
                this.prevX[l] = g.prevX;
                this.prevY[l] = g.prevY;
                this.prevTX[l] = g.prevTX;
                this.prevTY[l] = g.prevTY;
                e = g.bottom
            }
        },
        showBullets: function() {
            d.remove(this.allBullets);
            var a = this.container,
                b = a.set();
            this.set.push(b);
            this.set.show();
            this.allBullets = b;
            var b = this.chart.graphs,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c];
                if (!e.hidden && e.balloonText) {
                    var h = this.data[this.index].axes[e.valueAxis.id].graphs[e.id],
                        f = h.y;
                    if (!isNaN(f)) {
                        var g, k;
                        g = h.x;
                        this.rotate ? (k = f, f = g) : k = g;
                        e = d.circle(a, this.bulletSize / 2, this.chart.getBalloonColor(e, h, !0), e.cursorBulletAlpha);
                        e.translate(k, f);
                        this.allBullets.push(e)
                    }
                }
            }
        },
        destroy: function() {
            this.clear();
            d.remove(this.selection);
            this.selection = null;
            var a = this.categoryBalloon;
            a && a.destroy();
            (a = this.vaBalloon) && a.destroy();
            this.destroyValueBalloons();
            d.remove(this.set)
        },
        clear: function() {},
        destroyValueBalloons: function() {
            var a = this.valueBalloons;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) a[b].balloon.hide()
            }
        },
        zoom: function(a, b, c, e) {
            var h = this.chart;
            this.destroyValueBalloons();
            this.zooming = !1;
            var f;
            this.rotate ? this.selectionPosY = f = h.mouseY : this.selectionPosX = f = h.mouseX;
            this.start = a;
            this.end = b;
            this.startTime = c;
            this.endTime = e;
            this.zoomed = !0;
            e = h.categoryAxis;
            f = this.rotate;
            b = this.width;
            c = this.height;
            a = e.stepWidth;
            if (this.fullWidth) {
                var g = 1;
                e.parseDates && !e.equalSpacing && (g = e.minDuration());
                f ? this.extraWidth = c = a * g : (this.extraWidth = b = a * g, this.categoryBalloon.minWidth = b);
                this.line && this.line.remove();
                this.line = d.rect(this.container, b, c, this.cursorColor, this.cursorAlpha, 0);
                this.line.node.style.pointerEvents = "none";
                d.setCN(h, this.line, "cursor-fill");
                this.fullRectSet && this.fullRectSet.push(this.line)
            }
            this.stepWidth = a;
            this.tempVal = this.valueBalloonsEnabled;
            this.valueBalloonsEnabled = !1;
            this.setPosition();
            this.valueBalloonsEnabled = this.tempVal;
            this.hideCursor()
        },
        hideObj: function(a) {
            a && a.hide()
        },
        hideCursor: function(a) {
            void 0 === a && (a = !0);
            this.leaveCursor || (this.hideObj(this.set), this.hideObj(this.categoryBalloon), this.hideObj(this.line), this.hideObj(this.vLine), this.hideObj(this.hLine), this.hideObj(this.vaBalloon), this.hideObj(this.allBullets), this.destroyValueBalloons(), this.selectWithoutZooming || d.remove(this.selection), this.previousIndex = NaN, a && this.fire("onHideCursor", {
                type: "onHideCursor",
                chart: this.chart,
                target: this
            }), this.drawing || this.chart.setMouseCursor("auto"), this.normalizeBulletSize())
        },
        setPosition: function(a, b, c) {
            void 0 === b && (b = !0);
            if ("cursor" == this.type) {
                if (this.tempPosition = NaN, d.ifArray(this.data)) isNaN(a) && (a = this.getMousePosition()), (a != this.previousMousePosition || !0 === this.zoomed || this.oneBalloonOnly) && !isNaN(a) && ("mouse" == this.cursorPosition && (this.tempPosition = a), isNaN(c) && (c = this.chart.categoryAxis.xToIndex(a)), c != this.previousIndex || this.zoomed || "mouse" == this.cursorPosition || this.oneBalloonOnly) && (this.updateCursor(c, b), this.zoomed = !1), this.previousMousePosition = a
            } else this.updateCrosshair()
        },
        normalizeBulletSize: function() {
            var a = this.resizedBullets;
            if (a)
                for (var b = 0; b < a.length; b++) {
                    var c = a[b],
                        e = c.bulletGraphics;
                    e && (e.translate(c.bx, c.by, 1), c = c.graph, isNaN(this.graphBulletAlpha) || (e.setAttr("fill-opacity", c.bulletAlpha), e.setAttr("stroke-opacity", c.bulletBorderAlpha)))
                }
        },
        updateCursor: function(a, b) {
            var c = this.chart,
                e = this.fullWidth,
                h = c.mouseX - this.x,
                f = c.mouseY - this.y;
            this.drawingNow && (d.remove(this.drawingLine), this.drawingLine = d.line(this.container, [this.x + this.drawStartX, this.x + h], [this.y + this.drawStartY, this.y + f], this.cursorColor, 1, 1));
            if (this.enabled) {
                void 0 === b && (b = !0);
                this.index = a += this.adjustment;
                var g = c.categoryAxis,
                    k = c.dx,
                    l = c.dy,
                    m = this.x + 1,
                    n = this.y + 1,
                    p = this.width,
                    q = this.height,
                    r = this.data[a],
                    u;
                this.data[a + 1] && (u = this.data[a + 1]);
                this.fireMoved();
                if (r) {
                    var t = r.x[g.id],
                        z = c.rotate,
                        y = this.stepWidth,
                        v = this.categoryBalloon,
                        w = this.firstTime,
                        A = this.lastTime,
                        B = this.cursorPosition,
                        C = this.zooming,
                        D = this.panning,
                        J = c.graphs;
                    if (c.mouseIsOver || C || D || this.forceShow)
                        if (this.forceShow = !1, D) {
                            var k = this.panClickPos,
                                c = this.panClickEndTime,
                                C = this.panClickStartTime,
                                E = this.panClickEnd,
                                m = this.panClickStart,
                                h = (z ? k - f : k - h) / y;
                            if (!g.parseDates || g.equalSpacing) h = Math.round(h);
                            0 !== h && (k = {
                                type: "zoomed",
                                target: this
                            }, k.chart = this.chart, g.parseDates && !g.equalSpacing ? (c + h > A && (h = A - c), C + h < w && (h = w - C), k.start = Math.round(C + h), k.end = Math.round(c + h), this.fire(k.type, k)) : E + h >= this.data.length || 0 > m + h || (k.start = m + h, k.end = E + h, this.fire(k.type, k)))
                        } else {
                            "start" == B ? t -= g.cellWidth / 2 : "mouse" == B && (c.mouseIsOver ? t = z ? f - 2 : h - 2 : isNaN(this.tempPosition) || (t = this.tempPosition - 2));
                            if (z) {
                                if (0 > t)
                                    if (C) t = 0;
                                    else {
                                        this.hideCursor();
                                        return
                                    }
                                if (t > q + 1)
                                    if (C) t = q + 1;
                                    else {
                                        this.hideCursor();
                                        return
                                    }
                            } else {
                                if (0 > t)
                                    if (C) t = 0;
                                    else {
                                        this.hideCursor();
                                        return
                                    }
                                if (t > p)
                                    if (C) t = p;
                                    else {
                                        this.hideCursor();
                                        return
                                    }
                            }
                            w = this.line;
                            0 < this.cursorAlpha && (z ? (A = 0, y = t + l, e && (y -= g.cellWidth / 2)) : (A = t, y = 0, e && (A -= g.cellWidth / 2)), B = this.animationDuration, 0 < B && !this.zooming ? isNaN(this.previousX) ? w.translate(A, y) : (w.translate(this.previousX, this.previousY), w.animate({
                                translate: A + "," + y
                            }, B, "easeOutSine")) : w.translate(A, y), this.previousX = A, this.previousY = y, w.show());
                            this.linePos = z ? t + l : t;
                            C && (e && w.hide(), z ? this.updateSelectionSize(NaN, t) : this.updateSelectionSize(t, NaN));
                            A = !0;
                            C && (A = !1);
                            this.categoryBalloonEnabled && A ? (this.setBalloonPosition(v, g, t, z), (w = this.categoryBalloonFunction) ? v.showBalloon(w(r.category)) : (w = t = "", g.parseDates ? (t = d.formatDate(r.category, this.categoryBalloonDateFormat, c), g = d.changeDate(new Date(r.category), c.categoryAxis.minPeriod, 1), w = d.formatDate(g, this.categoryBalloonDateFormat, c), -1 != t.indexOf("fff") && (t = d.formatMilliseconds(t, r.category), w = d.formatMilliseconds(w, g))) : (t = d.fixNewLines(r.category), u && (w = d.fixNewLines(u.category))), g = this.categoryBalloonText.replace(/\[\[category\]\]/g, String(t)), g = g.replace(/\[\[toCategory\]\]/g, String(w)), v.showBalloon(g))) : v.hide();
                            J && this.bulletsEnabled && this.showBullets();
                            if (this.oneBalloonOnly) {
                                t = Infinity;
                                for (g = 0; g < J.length; g++) v = J[g], v.showBalloon && !v.hidden && v.balloonText && (u = r.axes[v.valueAxis.id].graphs[v.id], w = u.y, "top" == v.showBalloonAt && (w = 0), "bottom" == v.showBalloonAt && (w = this.height), isNaN(w) || (z ? Math.abs(h - w) < t && (t = Math.abs(h - w), E = v) : Math.abs(f - w) < t && (t = Math.abs(f - w), E = v)));
                                this.mostCloseGraph && (E = this.mostCloseGraph)
                            }
                            if (a != this.previousIndex || E != this.previousMostCloseGraph)
                                if (this.normalizeBulletSize(), this.destroyValueBalloons(), this.resizedBullets = [], J && this.valueBalloonsEnabled && A && c.balloon.enabled) {
                                    this.valueBalloons = A = [];
                                    for (g = 0; g < J.length; g++)
                                        if (v = J[g], w = NaN, (!this.oneBalloonOnly || v == E) && v.showBalloon && !v.hidden && v.balloonText && ("step" == v.type && "left" == v.stepDirection && (r = this.data[a + 1]), r)) {
                                            if (u = r.axes[v.valueAxis.id].graphs[v.id]) w = u.y;
                                            "top" == v.showBalloonAt && (w = 0);
                                            "bottom" == v.showBalloonAt && (w = this.height);
                                            if (this.showNextAvailable && isNaN(w) && a + 1 < this.data.length)
                                                for (t = a + 1; t < this.data.length; t++)
                                                    if (y = this.data[t])
                                                        if (u = y.axes[v.valueAxis.id].graphs[v.id], w = u.y, !isNaN(w)) break;
                                            if (!isNaN(w)) {
                                                y = u.x;
                                                e = !0;
                                                if (z) {
                                                    if (t = w, 0 > y || y > q) e = !1
                                                } else if (t = y, y = w, 0 > t || t > p + k + 1) e = !1;
                                                e && (e = this.graphBulletSize, l = this.graphBulletAlpha, 1 == e && isNaN(l) || !d.isModern || !(B = u.bulletGraphics) || (B.translate(u.bx, u.by, e), this.resizedBullets.push(u), isNaN(l) || (B.setAttr("fill-opacity", l), B.setAttr("stroke-opacity", l))), e = v.valueBalloon, l = c.getBalloonColor(v, u), e.setBounds(m, n, m + p, n + q), e.pointerOrientation = "H", B = this.balloonPointerOrientation, "vertical" == B && (e.pointerOrientation = "V"), "horizontal" == B && (e.pointerOrientation = "H"), e.changeColor(l), void 0 !== v.balloonAlpha && (e.fillAlpha = v.balloonAlpha), void 0 !== v.balloonTextColor && (e.color = v.balloonTextColor), e.setPosition(t + m, y + n), t = c.formatString(v.balloonText, u, !0), (y = v.balloonFunction) && (t = y(u, v).toString()), "" !== t && (z ? e.showBalloon(t) : (e.text = t, e.show = !0), A.push({
                                                    yy: w,
                                                    balloon: e
                                                })), !z && e.set && (e.set.hide(), v = e.textDiv) && (v.style.visibility = "hidden"))
                                            }
                                        }
                                    this.avoidBalloonOverlapping && this.arrangeBalloons()
                                }
                            b ? (k = {
                                type: "changed"
                            }, k.index = a, k.chart = this.chart, k.zooming = C, k.mostCloseGraph = E, k.position = z ? f : h, k.target = this, c.fire("changed", k), this.fire("changed", k), this.skipZoomDispatch = !1) : (this.skipZoomDispatch = !0, c.updateLegendValues(a));
                            this.previousIndex = a;
                            this.previousMostCloseGraph = E
                        }
                }
            } else this.hideCursor()
        },
        setBalloonPosition: function(a, b, c, e) {
            var d = b.position,
                f = b.inside;
            b = b.axisThickness;
            var g = this.chart,
                k = g.dx,
                g = g.dy,
                l = this.x,
                m = this.y,
                n = this.width,
                p = this.height;
            e ? (f && ("right" == d ? a.setBounds(l, m + g, l + n + k, m + c + g) : a.setBounds(l, m + g, l + n + k, m + c)), "right" == d ? f ? a.setPosition(l + n + k, m + c + g) : a.setPosition(l + n + k + b, m + c + g) : f ? a.setPosition(l, m + c) : a.setPosition(l - b, m + c)) : "top" == d ? f ? a.setPosition(l + c + k, m + g) : a.setPosition(l + c + k, m + g - b + 1) : f ? a.setPosition(l + c, m + p) : a.setPosition(l + c, m + p + b - 1)
        },
        setBalloonBounds: function(a, b, c) {
            var e = b.position,
                d = b.inside,
                f = b.axisThickness,
                g = b.tickLength,
                k = this.chart,
                l = k.dx,
                k = k.dy,
                m = this.x,
                n = this.y,
                p = this.width,
                q = this.height;
            c ? (d && (a.pointerWidth = 0), "right" == e ? d ? a.setBounds(m, n + k, m + p + l, n + q + k) : a.setBounds(m + p + l + f, n + k, m + p + 1E3, n + q + k) : d ? a.setBounds(m, n, p + m, q + n) : a.setBounds(-1E3, -1E3, m - g - f, n + q + 15)) : (a.maxWidth = p, b.parseDates && (g = 0, a.pointerWidth = 0), "top" == e ? d ? a.setBounds(m + l, n + k, p + l + m, q + n) : a.setBounds(m + l, -1E3, p + l + m, n + k - g - f) : d ? a.setBounds(m, n, p + m, q + n - g) : a.setBounds(m, n + q + g + f - 1, m + p, n + q + g + f))
        },
        enableDrawing: function(a) {
            this.enabled = !a;
            this.hideCursor();
            this.rolledOver = !1;
            this.drawing = a
        },
        isZooming: function(a) {
            a && a != this.zooming && this.handleMouseDown("fake");
            a || a == this.zooming || this.handleMouseUp()
        },
        handleMouseOut: function() {
            if (this.enabled)
                if (this.zooming) this.setPosition();
                else {
                    this.index = void 0;
                    var a = {
                        type: "changed",
                        index: void 0,
                        target: this
                    };
                    a.chart = this.chart;
                    this.fire("changed", a);
                    this.chart.wasTouched && this.leaveAfterTouch || this.hideCursor()
                }
        },
        handleReleaseOutside: function() {
            this.handleMouseUp()
        },
        handleMouseUp: function() {
            var a = this.chart,
                b = this.data,
                c;
            if (a) {
                var e = a.mouseX - this.x,
                    h = a.mouseY - this.y;
                if (this.drawingNow) {
                    this.drawingNow = !1;
                    d.remove(this.drawingLine);
                    c = this.drawStartX;
                    var f = this.drawStartY;
                    if (2 < Math.abs(c - e) || 2 < Math.abs(f - h)) c = {
                        type: "draw",
                        target: this,
                        chart: a,
                        initialX: c,
                        initialY: f,
                        finalX: e,
                        finalY: h
                    }, this.fire(c.type, c)
                }
                if (this.enabled && 0 < b.length) {
                    if (this.pan) this.rolledOver = !1;
                    else if (this.zoomable && this.zooming) {
                        c = this.selectWithoutZooming ? {
                            type: "selected"
                        } : {
                            type: "zoomed"
                        };
                        c.target = this;
                        c.chart = a;
                        if ("cursor" == this.type) this.rotate ? this.selectionPosY = h : this.selectionPosX = h = e, 4 > Math.abs(h - this.initialMouse) && this.fromIndex == this.index || (this.index < this.fromIndex ? (c.end = this.fromIndex, c.start = this.index) : (c.end = this.index, c.start = this.fromIndex), h = a.categoryAxis, h.parseDates && !h.equalSpacing && (b[c.start] && (c.start = b[c.start].time), b[c.end] && (c.end = a.getEndTime(b[c.end].time))), this.skipZoomDispatch || this.fire(c.type, c));
                        else {
                            var g = this.initialMouseX,
                                k = this.initialMouseY;
                            3 > Math.abs(e - g) && 3 > Math.abs(h - k) || (b = Math.min(g, e), f = Math.min(k, h), e = Math.abs(g - e), h = Math.abs(k - h), a.hideXScrollbar && (b = 0, e = this.width), a.hideYScrollbar && (f = 0, h = this.height), c.selectionHeight = h, c.selectionWidth = e, c.selectionY = f, c.selectionX = b, this.skipZoomDispatch || this.fire(c.type, c))
                        }
                        this.selectWithoutZooming || d.remove(this.selection)
                    }
                    this.skipZoomDispatch = !1
                }
            }
            this.panning = this.zooming = !1
        },
        showCursorAt: function(a) {
            var b = this.chart.categoryAxis;
            a = b.parseDates ? b.dateToCoordinate(a) : b.categoryToCoordinate(a);
            this.previousMousePosition = NaN;
            this.forceShow = !0;
            this.setPosition(a, !1)
        },
        clearSelection: function() {
            d.remove(this.selection)
        },
        handleMouseDown: function(a) {
            if (this.zoomable || this.pan || this.drawing) {
                var b = this.rotate,
                    c = this.chart,
                    e = c.mouseX - this.x,
                    h = c.mouseY - this.y;
                if (0 < e && e < this.width && 0 < h && h < this.height || "fake" == a) this.setPosition(), this.selectWithoutZooming && d.remove(this.selection), this.drawing ? (this.drawStartY = h, this.drawStartX = e, this.drawingNow = !0) : this.pan ? (this.zoomable = !1, c.setMouseCursor("move"), this.panning = !0, this.panClickPos = b ? h : e, this.panClickStart = this.start, this.panClickEnd = this.end, this.panClickStartTime = this.startTime, this.panClickEndTime = this.endTime) : this.zoomable && ("cursor" == this.type ? (this.fromIndex = this.index, b ? (this.initialMouse = h, this.selectionPosY = this.linePos) : (this.initialMouse = e, this.selectionPosX = this.linePos)) : (this.initialMouseX = e, this.initialMouseY = h, this.selectionPosX = e, this.selectionPosY = h), this.zooming = !0)
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.SimpleChartScrollbar = d.Class({
        construct: function(a) {
            this.createEvents("zoomed");
            this.backgroundColor = "#D4D4D4";
            this.backgroundAlpha = 1;
            this.selectedBackgroundColor = "#EFEFEF";
            this.scrollDuration = this.selectedBackgroundAlpha = 1;
            this.resizeEnabled = !0;
            this.hideResizeGrips = !1;
            this.scrollbarHeight = 20;
            this.updateOnReleaseOnly = !1;
            9 > document.documentMode && (this.updateOnReleaseOnly = !0);
            this.dragIconHeight = this.dragIconWidth = 35;
            this.dragIcon = "dragIconRoundBig";
            d.applyTheme(this, a, "SimpleChartScrollbar")
        },
        draw: function() {
            var a = this;
            a.destroy();
            if (a.enabled) {
                var b = a.chart.container,
                    c = a.rotate,
                    e = a.chart;
                e.panRequired = !0;
                var h = b.set();
                a.set = h;
                e.scrollbarsSet.push(h);
                var f, g;
                c ? (f = a.scrollbarHeight, g = e.plotAreaHeight) : (g = a.scrollbarHeight, f = e.plotAreaWidth);
                a.width = f;
                if ((a.height = g) && f) {
                    var k = d.rect(b, f, g, a.backgroundColor, a.backgroundAlpha, 1, a.backgroundColor, a.backgroundAlpha);
                    d.setCN(e, k, "scrollbar-bg");
                    a.bg = k;
                    h.push(k);
                    k = d.rect(b, f, g, "#000", .005);
                    h.push(k);
                    a.invisibleBg = k;
                    k.click(function() {
                        a.handleBgClick()
                    }).mouseover(function() {
                        a.handleMouseOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    }).touchend(function() {
                        a.handleBgClick()
                    });
                    k = d.rect(b, f, g, a.selectedBackgroundColor, a.selectedBackgroundAlpha);
                    d.setCN(e, k, "scrollbar-bg-selected");
                    a.selectedBG = k;
                    h.push(k);
                    f = d.rect(b, f, g, "#000", .005);
                    a.dragger = f;
                    h.push(f);
                    f.mousedown(function(b) {
                        a.handleDragStart(b)
                    }).mouseup(function() {
                        a.handleDragStop()
                    }).mouseover(function() {
                        a.handleDraggerOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    }).touchstart(function(b) {
                        a.handleDragStart(b)
                    }).touchend(function() {
                        a.handleDragStop()
                    });
                    f = e.pathToImages;
                    g = a.dragIcon.replace(/\.[a-z]*$/i, "");
                    c ? (k = f + g + "H" + e.extension, f = a.dragIconWidth, c = a.dragIconHeight) : (k = f + g + e.extension, c = a.dragIconWidth, f = a.dragIconHeight);
                    g = b.image(k, 0, 0, c, f);
                    d.setCN(e, g, "scrollbar-grip-left");
                    k = b.image(k, 0, 0, c, f);
                    d.setCN(e, k, "scrollbar-grip-right");
                    var l = 10,
                        m = 20;
                    e.panEventsEnabled && (l = 25, m = a.scrollbarHeight);
                    var n = d.rect(b, l, m, "#000", .005),
                        p = d.rect(b, l, m, "#000", .005);
                    p.translate(-(l - c) / 2, -(m - f) / 2);
                    n.translate(-(l - c) / 2, -(m - f) / 2);
                    c = b.set([g, p]);
                    b = b.set([k, n]);
                    a.iconLeft = c;
                    h.push(a.iconLeft);
                    a.iconRight = b;
                    h.push(b);
                    c.mousedown(function() {
                        a.leftDragStart()
                    }).mouseup(function() {
                        a.leftDragStop()
                    }).mouseover(function() {
                        a.iconRollOver()
                    }).mouseout(function() {
                        a.iconRollOut()
                    }).touchstart(function() {
                        a.leftDragStart()
                    }).touchend(function() {
                        a.leftDragStop()
                    });
                    b.mousedown(function() {
                        a.rightDragStart()
                    }).mouseup(function() {
                        a.rightDragStop()
                    }).mouseover(function() {
                        a.iconRollOver()
                    }).mouseout(function() {
                        a.iconRollOut()
                    }).touchstart(function() {
                        a.rightDragStart()
                    }).touchend(function() {
                        a.rightDragStop()
                    });
                    d.ifArray(e.chartData) ? h.show() : h.hide();
                    a.hideDragIcons();
                    a.clipDragger(!1)
                }
                h.translate(a.x, a.y);
                h.node.style.msTouchAction = "none"
            }
        },
        updateScrollbarSize: function(a, b) {
            a = Math.round(a);
            b = Math.round(b);
            var c = this.dragger,
                e, d, f, g;
            this.rotate ? (e = 0, d = a, f = this.width + 1, g = b - a, c.setAttr("height", b - a), c.setAttr("y", d)) : (e = a, d = 0, f = b - a, g = this.height + 1, c.setAttr("width", b - a), c.setAttr("x", e));
            this.clipAndUpdate(e, d, f, g)
        },
        update: function() {
            var a, b = !1,
                c, e, d = this.x,
                f = this.y,
                g = this.dragger,
                k = this.getDBox();
            if (k) {
                c = k.x + d;
                e = k.y + f;
                var l = k.width,
                    k = k.height,
                    m = this.rotate,
                    n = this.chart,
                    p = this.width,
                    q = this.height,
                    r = n.mouseX,
                    u = n.mouseY;
                a = this.initialMouse;
                this.forceClip && this.clipDragger(!0);
                n.mouseIsOver && (this.dragging && (n = this.initialCoord, m ? (a = n + (u - a), 0 > a && (a = 0), n = q - k, a > n && (a = n), g.setAttr("y", a)) : (a = n + (r - a), 0 > a && (a = 0), n = p - l, a > n && (a = n), g.setAttr("x", a)), this.clipDragger(!0)), this.resizingRight && (m ? (a = u - e, a + e > q + f && (a = q - e + f), 0 > a ? (this.resizingRight = !1, b = this.resizingLeft = !0) : (0 === a && (a = .1), g.setAttr("height", a))) : (a = r - c, a + c > p + d && (a = p - c + d), 0 > a ? (this.resizingRight = !1, b = this.resizingLeft = !0) : (0 === a && (a = .1), g.setAttr("width", a))), this.clipDragger(!0)), this.resizingLeft && (m ? (c = e, e = u, e < f && (e = f), e > q + f && (e = q + f), a = !0 === b ? c - e : k + c - e, 0 > a ? (this.resizingRight = !0, this.resizingLeft = !1, g.setAttr("y", c + k - f)) : (0 === a && (a = .1), g.setAttr("y", e - f), g.setAttr("height", a))) : (e = r, e < d && (e = d), e > p + d && (e = p + d), a = !0 === b ? c - e : l + c - e, 0 > a ? (this.resizingRight = !0, this.resizingLeft = !1, g.setAttr("x", c + l - d)) : (0 === a && (a = .1), g.setAttr("x", e - d), g.setAttr("width", a))), this.clipDragger(!0)))
            }
        },
        stopForceClip: function() {
            this.forceClip = !1
        },
        clipDragger: function(a) {
            var b = this.getDBox();
            if (b) {
                var c = b.x,
                    e = b.y,
                    d = b.width,
                    b = b.height,
                    f = !1;
                if (this.rotate) {
                    if (c = 0, d = this.width + 1, this.clipY != e || this.clipH != b) f = !0
                } else if (e = 0, b = this.height + 1, this.clipX != c || this.clipW != d) f = !0;
                f && (this.clipAndUpdate(c, e, d, b), a && (this.updateOnReleaseOnly || this.dispatchScrollbarEvent()))
            }
        },
        maskGraphs: function() {},
        clipAndUpdate: function(a, b, c, e) {
            this.clipX = a;
            this.clipY = b;
            this.clipW = c;
            this.clipH = e;
            this.selectedBG.clipRect(a, b, c, e);
            this.updateDragIconPositions();
            this.maskGraphs(a, b, c, e)
        },
        dispatchScrollbarEvent: function() {
            if (this.skipEvent) this.skipEvent = !1;
            else {
                var a = this.chart;
                a.hideBalloon();
                var b = this.getDBox(),
                    c = b.x,
                    e = b.y,
                    d = b.width,
                    b = b.height;
                this.rotate ? (c = e, d = this.height / b) : d = this.width / d;
                a = {
                    type: "zoomed",
                    position: c,
                    chart: a,
                    target: this,
                    multiplier: d
                };
                this.fire(a.type, a)
            }
        },
        updateDragIconPositions: function() {
            var a = this.getDBox(),
                b = a.x,
                c = a.y,
                e = this.iconLeft,
                d = this.iconRight,
                f, g, k = this.scrollbarHeight;
            this.rotate ? (f = this.dragIconWidth, g = this.dragIconHeight, e.translate((k - g) / 2, c - f / 2), d.translate((k - g) / 2, c + a.height - f / 2)) : (f = this.dragIconHeight, g = this.dragIconWidth, e.translate(b - g / 2, (k - f) / 2), d.translate(b - g / 2 + a.width, (k - f) / 2))
        },
        showDragIcons: function() {
            this.resizeEnabled && (this.iconLeft.show(), this.iconRight.show())
        },
        hideDragIcons: function() {
            if (!this.resizingLeft && !this.resizingRight && !this.dragging) {
                if (this.hideResizeGrips || !this.resizeEnabled) this.iconLeft.hide(), this.iconRight.hide();
                this.removeCursors()
            }
        },
        removeCursors: function() {
            this.chart.setMouseCursor("auto")
        },
        relativeZoom: function(a, b) {
            this.enabled && (this.dragger.stop(), this.multiplier = a, this.position = b, this.updateScrollbarSize(b, this.rotate ? b + this.height / a : b + this.width / a), this.clipDragger())
        },
        destroy: function() {
            this.clear();
            d.remove(this.set);
            d.remove(this.iconRight);
            d.remove(this.iconLeft)
        },
        clear: function() {},
        handleDragStart: function() {
            if (this.enabled) {
                var a = this.chart;
                this.dragger.stop();
                this.removeCursors();
                this.dragging = !0;
                var b = this.getDBox();
                this.rotate ? (this.initialCoord = b.y, this.initialMouse = a.mouseY) : (this.initialCoord = b.x, this.initialMouse = a.mouseX)
            }
        },
        handleDragStop: function() {
            this.updateOnReleaseOnly && (this.update(), this.skipEvent = !1, this.dispatchScrollbarEvent());
            this.dragging = !1;
            this.mouseIsOver && this.removeCursors();
            this.update()
        },
        handleDraggerOver: function() {
            this.handleMouseOver()
        },
        leftDragStart: function() {
            this.dragger.stop();
            this.resizingLeft = !0
        },
        leftDragStop: function() {
            this.resizingLeft = !1;
            this.mouseIsOver || this.removeCursors();
            this.updateOnRelease()
        },
        rightDragStart: function() {
            this.dragger.stop();
            this.resizingRight = !0
        },
        rightDragStop: function() {
            this.resizingRight = !1;
            this.mouseIsOver || this.removeCursors();
            this.updateOnRelease()
        },
        iconRollOut: function() {
            this.removeCursors()
        },
        iconRollOver: function() {
            this.rotate ? this.chart.setMouseCursor("n-resize") : this.chart.setMouseCursor("e-resize");
            this.handleMouseOver()
        },
        getDBox: function() {
            if (this.dragger) return this.dragger.getBBox()
        },
        handleBgClick: function() {
            var a = this;
            if (!a.resizingRight && !a.resizingLeft) {
                a.zooming = !0;
                var b, c, e = a.scrollDuration,
                    h = a.dragger;
                b = a.getDBox();
                var f = b.height,
                    g = b.width;
                c = a.chart;
                var k = a.y,
                    l = a.x,
                    m = a.rotate;
                m ? (b = "y", c = c.mouseY - f / 2 - k, c = d.fitToBounds(c, 0, a.height - f)) : (b = "x", c = c.mouseX - g / 2 - l, c = d.fitToBounds(c, 0, a.width - g));
                a.updateOnReleaseOnly ? (a.skipEvent = !1, h.setAttr(b, c), a.dispatchScrollbarEvent(), a.clipDragger()) : (c = Math.round(c), m ? h.animate({
                    y: c
                }, e, ">") : h.animate({
                    x: c
                }, e, ">"), a.forceClip = !0, clearTimeout(a.forceTO), a.forceTO = setTimeout(function() {
                    a.stopForceClip.call(a)
                }, 5E3 * e))
            }
        },
        updateOnRelease: function() {
            this.updateOnReleaseOnly && (this.update(), this.skipEvent = !1, this.dispatchScrollbarEvent())
        },
        handleReleaseOutside: function() {
            if (this.set) {
                if (this.resizingLeft || this.resizingRight || this.dragging) this.updateOnRelease(), this.removeCursors();
                this.mouseIsOver = this.dragging = this.resizingRight = this.resizingLeft = !1;
                this.hideDragIcons();
                this.update()
            }
        },
        handleMouseOver: function() {
            this.mouseIsOver = !0;
            this.showDragIcons()
        },
        handleMouseOut: function() {
            this.mouseIsOver = !1;
            this.hideDragIcons()
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ChartScrollbar = d.Class({
        inherits: d.SimpleChartScrollbar,
        construct: function(a) {
            this.cname = "ChartScrollbar";
            d.ChartScrollbar.base.construct.call(this, a);
            this.enabled = !0;
            this.graphLineColor = "#BBBBBB";
            this.graphLineAlpha = 0;
            this.graphFillColor = "#BBBBBB";
            this.graphFillAlpha = 1;
            this.selectedGraphLineColor = "#888888";
            this.selectedGraphLineAlpha = 0;
            this.selectedGraphFillColor = "#888888";
            this.selectedGraphFillAlpha = 1;
            this.gridCount = 0;
            this.gridColor = "#FFFFFF";
            this.gridAlpha = .7;
            this.skipEvent = this.autoGridCount = !1;
            this.color = "#FFFFFF";
            this.scrollbarCreated = !1;
            this.offset = 0;
            this.oppositeAxis = !0;
            d.applyTheme(this, a, this.cname)
        },
        init: function() {
            var a = this.categoryAxis,
                b = this.chart;
            a || (this.categoryAxis = a = new d.CategoryAxis);
            a.chart = b;
            a.id = "scrollbar";
            a.dateFormats = b.categoryAxis.dateFormats;
            a.markPeriodChange = b.categoryAxis.markPeriodChange;
            a.boldPeriodBeginning = b.categoryAxis.boldPeriodBeginning;
            a.labelFunction = b.categoryAxis.labelFunction;
            a.axisItemRenderer = d.RecItem;
            a.axisRenderer = d.RecAxis;
            a.guideFillRenderer = d.RecFill;
            a.inside = !0;
            a.fontSize = this.fontSize;
            a.tickLength = 0;
            a.axisAlpha = 0;
            d.isString(this.graph) && (this.graph = d.getObjById(b.graphs, this.graph));
            if (a = this.graph) {
                var c = this.valueAxis;
                c || (this.valueAxis = c = new d.ValueAxis, c.visible = !1, c.scrollbar = !0, c.axisItemRenderer = d.RecItem, c.axisRenderer = d.RecAxis, c.guideFillRenderer = d.RecFill, c.labelsEnabled = !1, c.chart = b);
                b = this.unselectedGraph;
                b || (b = new d.AmGraph, b.scrollbar = !0, this.unselectedGraph = b, b.negativeBase = a.negativeBase, b.noStepRisers = a.noStepRisers);
                b = this.selectedGraph;
                b || (b = new d.AmGraph, b.scrollbar = !0, this.selectedGraph = b, b.negativeBase = a.negativeBase, b.noStepRisers = a.noStepRisers)
            }
            this.scrollbarCreated = !0
        },
        draw: function() {
            var a = this;
            d.ChartScrollbar.base.draw.call(a);
            if (a.enabled) {
                a.scrollbarCreated || a.init();
                var b = a.chart,
                    c = b.chartData,
                    e = a.categoryAxis,
                    h = a.rotate,
                    f = a.x,
                    g = a.y,
                    k = a.width,
                    l = a.height,
                    m = b.categoryAxis,
                    n = a.set;
                e.setOrientation(!h);
                e.parseDates = m.parseDates;
                e.rotate = h;
                e.equalSpacing = m.equalSpacing;
                e.minPeriod = m.minPeriod;
                e.startOnAxis = m.startOnAxis;
                e.viW = k;
                e.viH = l;
                e.width = k;
                e.height = l;
                e.gridCount = a.gridCount;
                e.gridColor = a.gridColor;
                e.gridAlpha = a.gridAlpha;
                e.color = a.color;
                e.tickLength = 0;
                e.axisAlpha = 0;
                e.autoGridCount = a.autoGridCount;
                e.parseDates && !e.equalSpacing && e.timeZoom(b.firstTime, b.lastTime);
                e.zoom(0, c.length - 1);
                if (m = a.graph) {
                    var p = a.valueAxis,
                        q = m.valueAxis;
                    p.id = q.id;
                    p.rotate = h;
                    p.setOrientation(h);
                    p.width = k;
                    p.height = l;
                    p.viW = k;
                    p.viH = l;
                    p.dataProvider = c;
                    p.reversed = q.reversed;
                    p.logarithmic = q.logarithmic;
                    p.gridAlpha = 0;
                    p.axisAlpha = 0;
                    n.push(p.set);
                    h ? (p.y = g, p.x = 0) : (p.x = f, p.y = 0);
                    var f = Infinity,
                        g = -Infinity,
                        r;
                    for (r = 0; r < c.length; r++) {
                        var u = c[r].axes[q.id].graphs[m.id].values,
                            t;
                        for (t in u)
                            if (u.hasOwnProperty(t) && "percents" != t && "total" != t) {
                                var z = u[t];
                                z < f && (f = z);
                                z > g && (g = z)
                            }
                    }
                    Infinity != f && (p.minimum = f); - Infinity != g && (p.maximum = g + .1 * (g - f));
                    f == g && (--p.minimum, p.maximum += 1);
                    void 0 !== a.minimum && (p.minimum = a.minimum);
                    void 0 !== a.maximum && (p.maximum = a.maximum);
                    p.zoom(0, c.length - 1);
                    t = a.unselectedGraph;
                    t.id = m.id;
                    t.bcn = "scrollbar-graph-";
                    t.rotate = h;
                    t.chart = b;
                    t.data = c;
                    t.valueAxis = p;
                    t.chart = m.chart;
                    t.categoryAxis = a.categoryAxis;
                    t.periodSpan = m.periodSpan;
                    t.valueField = m.valueField;
                    t.openField = m.openField;
                    t.closeField = m.closeField;
                    t.highField = m.highField;
                    t.lowField = m.lowField;
                    t.lineAlpha = a.graphLineAlpha;
                    t.lineColorR = a.graphLineColor;
                    t.fillAlphas = a.graphFillAlpha;
                    t.fillColorsR = a.graphFillColor;
                    t.connect = m.connect;
                    t.hidden = m.hidden;
                    t.width = k;
                    t.height = l;
                    t.pointPosition = m.pointPosition;
                    t.stepDirection = m.stepDirection;
                    t.periodSpan = m.periodSpan;
                    q = a.selectedGraph;
                    q.id = m.id;
                    q.bcn = t.bcn + "selected-";
                    q.rotate = h;
                    q.chart = b;
                    q.data = c;
                    q.valueAxis = p;
                    q.chart = m.chart;
                    q.categoryAxis = e;
                    q.periodSpan = m.periodSpan;
                    q.valueField = m.valueField;
                    q.openField = m.openField;
                    q.closeField = m.closeField;
                    q.highField = m.highField;
                    q.lowField = m.lowField;
                    q.lineAlpha = a.selectedGraphLineAlpha;
                    q.lineColorR = a.selectedGraphLineColor;
                    q.fillAlphas = a.selectedGraphFillAlpha;
                    q.fillColorsR = a.selectedGraphFillColor;
                    q.connect = m.connect;
                    q.hidden = m.hidden;
                    q.width = k;
                    q.height = l;
                    q.pointPosition = m.pointPosition;
                    q.stepDirection = m.stepDirection;
                    q.periodSpan = m.periodSpan;
                    b = a.graphType;
                    b || (b = m.type);
                    t.type = b;
                    q.type = b;
                    c = c.length - 1;
                    t.zoom(0, c);
                    q.zoom(0, c);
                    q.set.click(function() {
                        a.handleBackgroundClick()
                    }).mouseover(function() {
                        a.handleMouseOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    });
                    t.set.click(function() {
                        a.handleBackgroundClick()
                    }).mouseover(function() {
                        a.handleMouseOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    });
                    n.push(t.set);
                    n.push(q.set)
                }
                n.push(e.set);
                n.push(e.labelsSet);
                a.bg.toBack();
                a.invisibleBg.toFront();
                a.dragger.toFront();
                a.iconLeft.toFront();
                a.iconRight.toFront()
            }
        },
        timeZoom: function(a, b, c) {
            this.startTime = a;
            this.endTime = b;
            this.timeDifference = b - a;
            this.skipEvent = !d.toBoolean(c);
            this.zoomScrollbar();
            this.skipEvent || this.dispatchScrollbarEvent()
        },
        zoom: function(a, b) {
            this.start = a;
            this.end = b;
            this.skipEvent = !0;
            this.zoomScrollbar()
        },
        dispatchScrollbarEvent: function() {
            if (this.skipEvent) this.skipEvent = !1;
            else {
                var a = this.chart.chartData,
                    b, c, e = this.dragger.getBBox();
                b = e.x;
                var d = e.y,
                    f = e.width,
                    e = e.height,
                    g = this.chart;
                this.rotate ? (b = d, c = e) : c = f;
                f = {
                    type: "zoomed",
                    target: this
                };
                f.chart = g;
                var k = this.categoryAxis,
                    l = this.stepWidth,
                    d = g.minSelectedTime,
                    e = !1;
                if (k.parseDates && !k.equalSpacing) {
                    if (a = g.lastTime, g = g.firstTime, k = Math.round(b / l) + g, b = this.dragging ? k + this.timeDifference : Math.round((b + c) / l) + g, k > b && (k = b), 0 < d && b - k < d && (b = Math.round(k + (b - k) / 2), e = Math.round(d / 2), k = b - e, b += e, e = !0), b > a && (b = a), b - d < k && (k = b - d), k < g && (k = g), k + d > b && (b = k + d), k != this.startTime || b != this.endTime) this.startTime = k, this.endTime = b, f.start = k, f.end = b, f.startDate = new Date(k), f.endDate = new Date(b), this.fire(f.type, f)
                } else if (k.startOnAxis || (b += l / 2), c -= this.stepWidth / 2, d = k.xToIndex(b), b = k.xToIndex(b + c), d != this.start || this.end != b) k.startOnAxis && (this.resizingRight && d == b && b++, this.resizingLeft && d == b && (0 < d ? d-- : b = 1)), this.start = d, this.end = this.dragging ? this.start + this.difference : b, f.start = this.start, f.end = this.end, k.parseDates && (a[this.start] && (f.startDate = new Date(a[this.start].time)), a[this.end] && (f.endDate = new Date(a[this.end].time))), this.fire(f.type, f);
                e && this.zoomScrollbar()
            }
        },
        zoomScrollbar: function() {
            var a, b;
            a = this.chart;
            var c = a.chartData,
                e = this.categoryAxis;
            e.parseDates && !e.equalSpacing ? (c = e.stepWidth, e = a.firstTime, a = c * (this.startTime - e), b = c * (this.endTime - e)) : (a = c[this.start].x[e.id], b = c[this.end].x[e.id], c = e.stepWidth, e.startOnAxis || (e = c / 2, a -= e, b += e));
            this.stepWidth = c;
            this.updateScrollbarSize(a, b)
        },
        maskGraphs: function(a, b, c, e) {
            var d = this.selectedGraph;
            d && d.set.clipRect(a, b, c, e)
        },
        handleDragStart: function() {
            d.ChartScrollbar.base.handleDragStart.call(this);
            this.difference = this.end - this.start;
            this.timeDifference = this.endTime - this.startTime;
            0 > this.timeDifference && (this.timeDifference = 0)
        },
        handleBackgroundClick: function() {
            d.ChartScrollbar.base.handleBackgroundClick.call(this);
            this.dragging || (this.difference = this.end - this.start, this.timeDifference = this.endTime - this.startTime, 0 > this.timeDifference && (this.timeDifference = 0))
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmBalloon = d.Class({
        construct: function(a) {
            this.cname = "AmBalloon";
            this.enabled = !0;
            this.fillColor = "#FFFFFF";
            this.fillAlpha = .8;
            this.borderThickness = 2;
            this.borderColor = "#FFFFFF";
            this.borderAlpha = 1;
            this.cornerRadius = 0;
            this.maxWidth = 220;
            this.horizontalPadding = 8;
            this.verticalPadding = 4;
            this.pointerWidth = 6;
            this.pointerOrientation = "V";
            this.color = "#000000";
            this.adjustBorderColor = !0;
            this.show = this.follow = this.showBullet = !1;
            this.bulletSize = 3;
            this.shadowAlpha = .4;
            this.shadowColor = "#000000";
            this.fadeOutDuration = this.animationDuration = .3;
            this.fixedPosition = !0;
            this.offsetY = 6;
            this.offsetX = 1;
            this.textAlign = "center";
            this.disableMouseEvents = !0;
            this.deltaSignX = this.deltaSignY = 1;
            d.isModern || (this.offsetY *= 1.5);
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this.pointToX,
                b = this.pointToY,
                c = this.chart;
            d.VML && (this.fadeOutDuration = 0);
            this.xAnim && c.stopAnim(this.xAnim);
            this.yAnim && c.stopAnim(this.yAnim);
            if (!isNaN(a)) {
                var e = this.follow,
                    h = c.container,
                    f = this.set;
                d.remove(f);
                this.removeDiv();
                f = h.set();
                f.node.style.pointerEvents = "none";
                this.set = f;
                c.balloonsSet.push(f);
                if (this.show) {
                    var g = this.l,
                        k = this.t,
                        l = this.r,
                        m = this.b,
                        n = this.balloonColor,
                        p = this.fillColor,
                        q = this.borderColor,
                        r = p;
                    void 0 != n && (this.adjustBorderColor ? r = q = n : p = n);
                    var u = this.horizontalPadding,
                        t = this.verticalPadding,
                        z = this.pointerWidth,
                        y = this.pointerOrientation,
                        v = this.cornerRadius,
                        w = c.fontFamily,
                        A = this.fontSize;
                    void 0 == A && (A = c.fontSize);
                    var n = document.createElement("div"),
                        B = c.classNamePrefix;
                    n.className = B + "-balloon-div";
                    this.className && (n.className = n.className + " " + B + "-balloon-div-" + this.className);
                    B = n.style;
                    this.disableMouseEvents && (B.pointerEvents = "none");
                    B.position = "absolute";
                    var C = this.minWidth,
                        D = "";
                    isNaN(C) || (D = "min-width:" + (C - 2 * u) + "px; ");
                    n.innerHTML = "<div style='text-align:" + this.textAlign + "; " + D + "max-width:" + this.maxWidth + "px; font-size:" + A + "px; color:" + this.color + "; font-family:" + w + "'>" + this.text + "</div>";
                    c.chartDiv.appendChild(n);
                    this.textDiv = n;
                    A = n.offsetWidth;
                    w = n.offsetHeight;
                    n.clientHeight && (A = n.clientWidth, w = n.clientHeight);
                    w += 2 * t;
                    D = A + 2 * u;
                    !isNaN(C) && D < C && (D = C);
                    window.opera && (w += 2);
                    var J = !1,
                        A = this.offsetY;
                    c.handDrawn && (A += c.handDrawScatter + 2);
                    "H" != y ? (C = a - D / 2, b < k + w + 10 && "down" != y ? (J = !0, e && (b += A), A = b + z, this.deltaSignY = -1) : (e && (b -= A), A = b - w - z, this.deltaSignY = 1)) : (2 * z > w && (z = w / 2), A = b - w / 2, a < g + (l - g) / 2 ? (C = a + z, this.deltaSignX = -1) : (C = a - D - z, this.deltaSignX = 1));
                    A + w >= m && (A = m - w);
                    A < k && (A = k);
                    C < g && (C = g);
                    C + D > l && (C = l - D);
                    var k = A + t,
                        m = C + u,
                        t = this.shadowAlpha,
                        E = this.shadowColor,
                        u = this.borderThickness,
                        O = this.bulletSize,
                        I;
                    0 < v || 0 === z ? (0 < t && (a = d.rect(h, D, w, p, 0, u + 1, E, t, this.cornerRadius), d.isModern ? a.translate(1, 1) : a.translate(4, 4), f.push(a)), p = d.rect(h, D, w, p, this.fillAlpha, u, q, this.borderAlpha, this.cornerRadius), this.showBullet && (I = d.circle(h, O, r, this.fillAlpha), f.push(I))) : (r = [], v = [], "H" != y ? (g = a - C, g > D - z && (g = D - z), g < z && (g = z), r = [0, g - z, a - C, g + z, D, D, 0, 0], v = J ? [0, 0, b - A, 0, 0, w, w, 0] : [w, w, b - A, w, w, 0, 0, w]) : (r = b - A, r > w - z && (r = w - z), r < z && (r = z), v = [0, r - z, b - A, r + z, w, w, 0, 0], r = a < g + (l - g) / 2 ? [0, 0, C < a ? 0 : a - C, 0, 0, D, D, 0] : [D, D, C + D > a ? D : a - C, D, D, 0, 0, D]), 0 < t && (a = d.polygon(h, r, v, p, 0, u, E, t), a.translate(1, 1), f.push(a)), p = d.polygon(h, r, v, p, this.fillAlpha, u, q, this.borderAlpha));
                    this.bg = p;
                    f.push(p);
                    p.toFront();
                    d.setCN(c, p, "balloon-bg");
                    this.className && d.setCN(c, p, "balloon-bg-" + this.className);
                    h = 1 * this.deltaSignX;
                    B.left = m + "px";
                    B.top = k + "px";
                    f.translate(C - h, A);
                    p = p.getBBox();
                    this.bottom = A + w + 1;
                    this.yPos = p.y + A;
                    I && I.translate(this.pointToX - C + h, b - A);
                    b = this.animationDuration;
                    0 < this.animationDuration && !e && !isNaN(this.prevX) && (f.translate(this.prevX, this.prevY), f.animate({
                        translate: C - h + "," +
                            A
                    }, b, "easeOutSine"), n && (B.left = this.prevTX + "px", B.top = this.prevTY + "px", this.xAnim = c.animate({
                        node: n
                    }, "left", this.prevTX, m, b, "easeOutSine", "px"), this.yAnim = c.animate({
                        node: n
                    }, "top", this.prevTY, k, b, "easeOutSine", "px")));
                    this.prevX = C - h;
                    this.prevY = A;
                    this.prevTX = m;
                    this.prevTY = k
                }
            }
        },
        followMouse: function() {
            if (this.follow && this.show) {
                var a = this.chart.mouseX - this.offsetX * this.deltaSignX,
                    b = this.chart.mouseY;
                this.pointToX = a;
                this.pointToY = b;
                if (a != this.previousX || b != this.previousY)
                    if (this.previousX = a, this.previousY = b, 0 === this.cornerRadius) this.draw();
                    else {
                        var c = this.set;
                        if (c) {
                            var e = c.getBBox(),
                                a = a - e.width / 2,
                                d = b - e.height - 10;
                            a < this.l && (a = this.l);
                            a > this.r - e.width && (a = this.r - e.width);
                            d < this.t && (d = b + 10);
                            c.translate(a, d);
                            b = this.textDiv.style;
                            b.left = a + this.horizontalPadding + "px";
                            b.top = d + this.verticalPadding + "px"
                        }
                    }
            }
        },
        changeColor: function(a) {
            this.balloonColor = a
        },
        setBounds: function(a, b, c, e) {
            this.l = a;
            this.t = b;
            this.r = c;
            this.b = e;
            this.destroyTO && clearTimeout(this.destroyTO)
        },
        showBalloon: function(a) {
            this.text = a;
            this.show = !0;
            this.destroyTO && clearTimeout(this.destroyTO);
            a = this.chart;
            this.fadeAnim1 && a.stopAnim(this.fadeAnim1);
            this.fadeAnim2 && a.stopAnim(this.fadeAnim2);
            this.draw()
        },
        hide: function(a) {
            var b = this;
            isNaN(a) && (a = b.fadeOutDuration);
            var c = b.chart;
            if (0 < a) {
                b.destroyTO && clearTimeout(b.destroyTO);
                b.destroyTO = setTimeout(function() {
                    b.destroy.call(b)
                }, 1E3 * a);
                b.follow = !1;
                b.show = !1;
                var e = b.set;
                e && (e.setAttr("opacity", b.fillAlpha), b.fadeAnim1 = e.animate({
                    opacity: 0
                }, a, "easeInSine"));
                b.textDiv && (b.fadeAnim2 = c.animate({
                    node: b.textDiv
                }, "opacity", 1, 0, a, "easeInSine", ""))
            } else b.show = !1, b.follow = !1, b.destroy()
        },
        setPosition: function(a, b, c) {
            this.pointToX = a;
            this.pointToY = b;
            c && (a == this.previousX && b == this.previousY || this.draw());
            this.previousX = a;
            this.previousY = b
        },
        followCursor: function(a) {
            var b = this;
            (b.follow = a) ? (b.pShowBullet = b.showBullet, b.showBullet = !1) : void 0 !== b.pShowBullet && (b.showBullet = b.pShowBullet);
            clearInterval(b.interval);
            var c = b.chart.mouseX,
                e = b.chart.mouseY;
            !isNaN(c) && a && (b.pointToX = c - b.offsetX * b.deltaSignX, b.pointToY = e, b.followMouse(), b.interval = setInterval(function() {
                b.followMouse.call(b)
            }, 40))
        },
        removeDiv: function() {
            if (this.textDiv) {
                var a = this.textDiv.parentNode;
                a && a.removeChild(this.textDiv)
            }
        },
        destroy: function() {
            clearInterval(this.interval);
            d.remove(this.set);
            this.removeDiv();
            this.set = null
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmCoordinateChart = d.Class({
        inherits: d.AmChart,
        construct: function(a) {
            d.AmCoordinateChart.base.construct.call(this, a);
            this.theme = a;
            this.createEvents("rollOverGraphItem", "rollOutGraphItem", "clickGraphItem", "doubleClickGraphItem", "rightClickGraphItem", "clickGraph", "rollOverGraph", "rollOutGraph");
            this.startAlpha = 1;
            this.startDuration = 0;
            this.startEffect = "elastic";
            this.sequencedAnimation = !0;
            this.colors = "#FF6600 #FCD202 #B0DE09 #0D8ECF #2A0CD0 #CD0D74 #CC0000 #00CC00 #0000CC #DDDDDD #999999 #333333 #990000".split(" ");
            this.balloonDateFormat = "MMM DD, YYYY";
            this.valueAxes = [];
            this.graphs = [];
            this.guides = [];
            this.gridAboveGraphs = !1;
            d.applyTheme(this, a, "AmCoordinateChart")
        },
        initChart: function() {
            d.AmCoordinateChart.base.initChart.call(this);
            var a = this.categoryAxis;
            a && (this.categoryAxis = d.processObject(a, d.CategoryAxis, this.theme));
            this.processValueAxes();
            this.createValueAxes();
            this.processGraphs();
            this.processGuides();
            d.VML && (this.startAlpha = 1);
            this.setLegendData(this.graphs);
            this.gridAboveGraphs && this.gridSet.toFront()
        },
        createValueAxes: function() {
            if (0 === this.valueAxes.length) {
                var a = new d.ValueAxis;
                this.addValueAxis(a)
            }
        },
        parseData: function() {
            this.processValueAxes();
            this.processGraphs()
        },
        parseSerialData: function(a) {
            var b = this.graphs,
                c, e = {},
                h = this.seriesIdField;
            h || (h = this.categoryField);
            this.chartData = [];
            if (a) {
                var f = !1,
                    g, k = this.categoryAxis,
                    l, m, n;
                k && (f = k.parseDates, l = k.forceShowField, n = k.classNameField, m = k.labelColorField, g = k.categoryFunction);
                var p, q, r = {},
                    u;
                f && (c = d.extractPeriod(k.minPeriod), p = c.period, q = c.count, u = d.getPeriodDuration(p, q));
                var t = {};
                this.lookupTable = t;
                var z, y = this.dataDateFormat,
                    v = {};
                for (z = 0; z < a.length; z++) {
                    var w = {},
                        A = a[z];
                    c = A[this.categoryField];
                    w.dataContext = A;
                    w.category = g ? g(c, A, k) : String(c);
                    l && (w.forceShow = A[l]);
                    n && (w.className = A[n]);
                    m && (w.labelColor = A[m]);
                    t[A[h]] = w;
                    if (f && (k.categoryFunction ? c = k.categoryFunction(c, A, k) : (!y || c instanceof Date || (c = c.toString() + " |"), c = d.getDate(c, y, k.minPeriod)), c = d.resetDateToMin(c, p, q, k.firstDayOfWeek), w.category = c, w.time = c.getTime(), isNaN(w.time))) continue;
                    var B = this.valueAxes;
                    w.axes = {};
                    w.x = {};
                    var C;
                    for (C = 0; C < B.length; C++) {
                        var D = B[C].id;
                        w.axes[D] = {};
                        w.axes[D].graphs = {};
                        var J;
                        for (J = 0; J < b.length; J++) {
                            c = b[J];
                            var E = c.id,
                                O = 1.1;
                            isNaN(c.gapPeriod) || (O = c.gapPeriod);
                            var I = c.periodValue;
                            if (c.valueAxis.id == D) {
                                w.axes[D].graphs[E] = {};
                                var W = {};
                                W.index = z;
                                var ea = A;
                                c.dataProvider && (ea = e);
                                W.values = this.processValues(ea, c, I);
                                !c.connect && v && v[E] && 0 < O && w.time - r[E] >= u * O && (v[E].gap = !0);
                                this.processFields(c, W, ea);
                                W.category = w.category;
                                W.serialDataItem = w;
                                W.graph = c;
                                w.axes[D].graphs[E] = W;
                                r[E] = w.time;
                                v[E] = W
                            }
                        }
                    }
                    this.chartData[z] = w
                }
            }
            for (a = 0; a < b.length; a++) c = b[a], c.dataProvider && this.parseGraphData(c)
        },
        processValues: function(a, b, c) {
            var e = {},
                h, f = !1;
            "candlestick" != b.type && "ohlc" != b.type || "" === c || (f = !0);
            for (var g = "value error open close low high".split(" "), k = 0; k < g.length; k++) {
                var l = g[k];
                "value" != l && "error" != l && f && (c = l.charAt(0).toUpperCase() + l.slice(1));
                var m = a[b[l + "Field"] + c];
                null !== m && (h = Number(m), isNaN(h) || (e[l] = h), "date" == b.valueAxis.type && void 0 !== m && (h = d.getDate(m, b.chart.dataDateFormat), e[l] = h.getTime()))
            }
            return e
        },
        parseGraphData: function(a) {
            var b = a.dataProvider,
                c = a.seriesIdField;
            c || (c = this.seriesIdField);
            c || (c = this.categoryField);
            var e;
            for (e = 0; e < b.length; e++) {
                var d = b[e],
                    f = this.lookupTable[String(d[c])],
                    g = a.valueAxis.id;
                f && (g = f.axes[g].graphs[a.id], g.serialDataItem = f, g.values = this.processValues(d, a, a.periodValue), this.processFields(a, g, d))
            }
        },
        addValueAxis: function(a) {
            a.chart = this;
            this.valueAxes.push(a);
            this.validateData()
        },
        removeValueAxesAndGraphs: function() {
            var a = this.valueAxes,
                b;
            for (b = a.length - 1; - 1 < b; b--) this.removeValueAxis(a[b])
        },
        removeValueAxis: function(a) {
            var b = this.graphs,
                c;
            for (c = b.length - 1; 0 <= c; c--) {
                var e = b[c];
                e && e.valueAxis == a && this.removeGraph(e)
            }
            b = this.valueAxes;
            for (c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1);
            this.validateData()
        },
        addGraph: function(a) {
            this.graphs.push(a);
            this.chooseGraphColor(a, this.graphs.length - 1);
            this.validateData()
        },
        removeGraph: function(a) {
            var b = this.graphs,
                c;
            for (c = b.length - 1; 0 <= c; c--) b[c] == a && (b.splice(c, 1), a.destroy());
            this.validateData()
        },
        processValueAxes: function() {
            var a = this.valueAxes,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    c = d.processObject(c, d.ValueAxis, this.theme);
                a[b] = c;
                c.chart = this;
                c.id || (c.id = "valueAxisAuto" + b + "_" + (new Date).getTime());
                void 0 === c.usePrefixes && (c.usePrefixes = this.usePrefixes)
            }
        },
        processGuides: function() {
            var a = this.guides,
                b = this.categoryAxis;
            if (a)
                for (var c = 0; c < a.length; c++) {
                    var e = a[c];
                    (void 0 !== e.category || void 0 !== e.date) && b && b.addGuide(e);
                    e.id || (e.id = "guideAuto" + c + "_" + (new Date).getTime());
                    var h = e.valueAxis;
                    h ? (d.isString(h) && (h = this.getValueAxisById(h)), h ? h.addGuide(e) : this.valueAxes[0].addGuide(e)) : isNaN(e.value) || this.valueAxes[0].addGuide(e)
                }
        },
        processGraphs: function() {
            var a = this.graphs,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    c = d.processObject(c, d.AmGraph, this.theme);
                a[b] = c;
                this.chooseGraphColor(c, b);
                c.chart = this;
                d.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));
                c.valueAxis || (c.valueAxis = this.valueAxes[0]);
                c.id || (c.id = "graphAuto" + b + "_" + (new Date).getTime())
            }
        },
        formatString: function(a, b, c) {
            var e = b.graph,
                h = e.valueAxis;
            h.duration && b.values.value && (h = d.formatDuration(b.values.value, h.duration, "", h.durationUnits, h.maxInterval, h.numberFormatter), a = a.split("[[value]]").join(h));
            a = d.massReplace(a, {
                "[[title]]": e.title,
                "[[description]]": b.description
            });
            a = c ? d.fixNewLines(a) : d.fixBrakes(a);
            return a = d.cleanFromEmpty(a)
        },
        getBalloonColor: function(a, b, c) {
            var e = a.lineColor,
                h = a.balloonColor;
            c && (h = e);
            c = a.fillColorsR;
            "object" == typeof c ? e = c[0] : void 0 !== c && (e = c);
            b.isNegative && (c = a.negativeLineColor, a = a.negativeFillColors, "object" == typeof a ? c = a[0] : void 0 !== a && (c = a), void 0 !== c && (e = c));
            void 0 !== b.color && (e = b.color);
            void 0 !== b.lineColor && (e = b.lineColor);
            b = b.fillColors;
            void 0 !== b && (e = b, d.ifArray(b) && (e = b[0]));
            void 0 === h && (h = e);
            return h
        },
        getGraphById: function(a) {
            return d.getObjById(this.graphs, a)
        },
        getValueAxisById: function(a) {
            return d.getObjById(this.valueAxes, a)
        },
        processFields: function(a, b, c) {
            if (a.itemColors) {
                var e = a.itemColors,
                    h = b.index;
                b.color = h < e.length ? e[h] : d.randomColor()
            }
            e = "lineColor color alpha fillColors description bullet customBullet bulletSize bulletConfig url labelColor dashLength pattern gap className".split(" ");
            for (h = 0; h < e.length; h++) {
                var f = e[h],
                    g = a[f + "Field"];
                g && (g = c[g], d.isDefined(g) && (b[f] = g))
            }
            b.dataContext = c
        },
        chooseGraphColor: function(a, b) {
            if (!a.lineColorR && !a.fillColorsR) {
                if (a.lineColor) a.lineColorR = a.lineColor;
                else {
                    var c;
                    c = this.colors.length > b ? this.colors[b] : d.randomColor();
                    a.lineColorR = c
                }
                a.fillColorsR = a.fillColors ? a.fillColors : a.lineColorR;
                a.bulletBorderColorR = a.bulletBorderColor ? a.bulletBorderColor : a.useLineColorForBulletBorder ? a.lineColorR : a.bulletColor;
                a.bulletColorR = a.bulletColor ? a.bulletColor : a.lineColorR;
                if (c = this.patterns) a.pattern = c[b]
            }
        },
        handleLegendEvent: function(a) {
            var b = a.type;
            a = a.dataItem;
            if (!this.legend.data && a) {
                var c = a.hidden,
                    e = a.showBalloon;
                switch (b) {
                    case "clickMarker":
                        this.textClickEnabled && (e ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a));
                        break;
                    case "clickLabel":
                        e ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a);
                        break;
                    case "rollOverItem":
                        c || this.highlightGraph(a);
                        break;
                    case "rollOutItem":
                        c || this.unhighlightGraph();
                        break;
                    case "hideItem":
                        this.hideGraph(a);
                        break;
                    case "showItem":
                        this.showGraph(a)
                }
            }
        },
        highlightGraph: function(a) {
            var b = this.graphs,
                c, e = .2;
            this.legend && (e = this.legend.rollOverGraphAlpha);
            if (1 != e)
                for (c = 0; c < b.length; c++) {
                    var d = b[c];
                    d != a && d.changeOpacity(e)
                }
        },
        unhighlightGraph: function() {
            var a;
            this.legend && (a = this.legend.rollOverGraphAlpha);
            if (1 != a) {
                a = this.graphs;
                var b;
                for (b = 0; b < a.length; b++) a[b].changeOpacity(1)
            }
        },
        showGraph: function(a) {
            a.switchable && (a.hidden = !1, this.dataChanged = !0, "xy" != this.type && (this.marginsUpdated = !1), this.chartCreated && this.initChart())
        },
        hideGraph: function(a) {
            a.switchable && (this.dataChanged = !0, "xy" != this.type && (this.marginsUpdated = !1), a.hidden = !0, this.chartCreated && this.initChart())
        },
        hideGraphsBalloon: function(a) {
            a.showBalloon = !1;
            this.updateLegend()
        },
        showGraphsBalloon: function(a) {
            a.showBalloon = !0;
            this.updateLegend()
        },
        updateLegend: function() {
            this.legend && this.legend.invalidateSize()
        },
        resetAnimation: function() {
            var a = this.graphs;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) a[b].animationPlayed = !1
            }
        },
        animateAgain: function() {
            this.resetAnimation();
            this.validateNow()
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmSlicedChart = d.Class({
        inherits: d.AmChart,
        construct: function(a) {
            this.createEvents("rollOverSlice", "rollOutSlice", "clickSlice", "pullOutSlice", "pullInSlice", "rightClickSlice");
            d.AmSlicedChart.base.construct.call(this, a);
            this.colors = "#FF0F00 #FF6600 #FF9E01 #FCD202 #F8FF01 #B0DE09 #04D215 #0D8ECF #0D52D1 #2A0CD0 #8A0CCF #CD0D74 #754DEB #DDDDDD #999999 #333333 #000000 #57032A #CA9726 #990000 #4B0C25".split(" ");
            this.alpha = 1;
            this.groupPercent = 0;
            this.groupedTitle = "Other";
            this.groupedPulled = !1;
            this.groupedAlpha = 1;
            this.marginLeft = 0;
            this.marginBottom = this.marginTop = 10;
            this.marginRight = 0;
            this.hoverAlpha = 1;
            this.outlineColor = "#FFFFFF";
            this.outlineAlpha = 0;
            this.outlineThickness = 1;
            this.startAlpha = 0;
            this.startDuration = 1;
            this.startEffect = "bounce";
            this.sequencedAnimation = !0;
            this.pullOutDuration = 1;
            this.pullOutEffect = "bounce";
            this.pullOnHover = this.pullOutOnlyOne = !1;
            this.labelsEnabled = !0;
            this.labelTickColor = "#000000";
            this.labelTickAlpha = .2;
            this.hideLabelsPercent = 0;
            this.urlTarget = "_self";
            this.autoMarginOffset = 10;
            this.gradientRatio = [];
            this.maxLabelWidth = 200;
            d.applyTheme(this, a, "AmSlicedChart")
        },
        initChart: function() {
            d.AmSlicedChart.base.initChart.call(this);
            this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1, this.setLegendData(this.chartData));
            this.drawChart()
        },
        handleLegendEvent: function(a) {
            var b = a.type,
                c = a.dataItem,
                e = this.legend;
            if (!e.data && c) {
                var d = c.hidden;
                a = a.event;
                switch (b) {
                    case "clickMarker":
                        d || e.switchable || this.clickSlice(c, a);
                        break;
                    case "clickLabel":
                        d || this.clickSlice(c, a, !1);
                        break;
                    case "rollOverItem":
                        d || this.rollOverSlice(c, !1, a);
                        break;
                    case "rollOutItem":
                        d || this.rollOutSlice(c, a);
                        break;
                    case "hideItem":
                        this.hideSlice(c, a);
                        break;
                    case "showItem":
                        this.showSlice(c, a)
                }
            }
        },
        invalidateVisibility: function() {
            this.recalculatePercents();
            this.initChart();
            var a = this.legend;
            a && a.invalidateSize()
        },
        addEventListeners: function(a, b) {
            var c = this;
            a.mouseover(function(a) {
                c.rollOverSlice(b, !0, a)
            }).mouseout(function(a) {
                c.rollOutSlice(b, a)
            }).touchend(function(a) {
                c.rollOverSlice(b, a)
            }).touchstart(function(a) {}).mouseup(function(a) {
                c.clickSlice(b, a)
            }).contextmenu(function(a) {
                c.handleRightClick(b, a)
            })
        },
        formatString: function(a, b, c) {
            a = d.formatValue(a, b, ["value"], this.nf, "", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
            var e = this.pf.precision;
            isNaN(this.tempPrec) || (this.pf.precision = this.tempPrec);
            a = d.formatValue(a, b, ["percents"], this.pf);
            a = d.massReplace(a, {
                "[[title]]": b.title,
                "[[description]]": b.description
            });
            this.pf.precision = e; - 1 != a.indexOf("[[") && (a = d.formatDataContextValue(a, b.dataContext));
            a = c ? d.fixNewLines(a) : d.fixBrakes(a);
            return a = d.cleanFromEmpty(a)
        },
        startSlices: function() {
            var a;
            for (a = 0; a < this.chartData.length; a++) 0 < this.startDuration && this.sequencedAnimation ? this.setStartTO(a) : this.startSlice(this.chartData[a])
        },
        setStartTO: function(a) {
            var b = this;
            a = setTimeout(function() {
                b.startSequenced.call(b)
            }, b.startDuration / b.chartData.length * 500 * a);
            b.timeOuts.push(a)
        },
        pullSlices: function(a) {
            var b = this.chartData,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c];
                e.pulled && this.pullSlice(e, 1, a)
            }
        },
        startSequenced: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++)
                if (!a[b].started) {
                    this.startSlice(this.chartData[b]);
                    break
                }
        },
        startSlice: function(a) {
            a.started = !0;
            var b = a.wedge,
                c = this.startDuration,
                e = a.labelSet;
            b && 0 < c && (0 < a.alpha && b.show(), b.translate(a.startX, a.startY), b.animate({
                opacity: 1,
                translate: "0,0"
            }, c, this.startEffect));
            e && 0 < c && (0 < a.alpha && e.show(), e.translate(a.startX, a.startY), e.animate({
                opacity: 1,
                translate: "0,0"
            }, c, this.startEffect))
        },
        showLabels: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                if (0 < c.alpha) {
                    var e = c.label;
                    e && e.show();
                    (c = c.tick) && c.show()
                }
            }
        },
        showSlice: function(a) {
            isNaN(a) ? a.hidden = !1 : this.chartData[a].hidden = !1;
            this.invalidateVisibility()
        },
        hideSlice: function(a) {
            isNaN(a) ? a.hidden = !0 : this.chartData[a].hidden = !0;
            this.hideBalloon();
            this.invalidateVisibility()
        },
        rollOverSlice: function(a, b, c) {
            isNaN(a) || (a = this.chartData[a]);
            clearTimeout(this.hoverInt);
            if (!a.hidden) {
                this.pullOnHover && this.pullSlice(a, 1);
                1 > this.hoverAlpha && a.wedge && a.wedge.attr({
                    opacity: this.hoverAlpha
                });
                var e = a.balloonX,
                    h = a.balloonY;
                a.pulled && (e += a.pullX, h += a.pullY);
                var f = this.formatString(this.balloonText, a, !0),
                    g = this.balloonFunction;
                g && (f = g(a, f));
                g = d.adjustLuminosity(a.color, -.15);
                f ? this.showBalloon(f, g, b, e, h) : this.hideBalloon();
                0 === a.value && this.hideBalloon();
                a = {
                    type: "rollOverSlice",
                    dataItem: a,
                    chart: this,
                    event: c
                };
                this.fire(a.type, a)
            }
        },
        rollOutSlice: function(a, b) {
            isNaN(a) || (a = this.chartData[a]);
            a.wedge && a.wedge.attr({
                opacity: 1
            });
            this.hideBalloon();
            var c = {
                type: "rollOutSlice",
                dataItem: a,
                chart: this,
                event: b
            };
            this.fire(c.type, c)
        },
        clickSlice: function(a, b, c) {
            isNaN(a) || (a = this.chartData[a]);
            a.pulled ? this.pullSlice(a, 0) : this.pullSlice(a, 1);
            d.getURL(a.url, this.urlTarget);
            c || (a = {
                type: "clickSlice",
                dataItem: a,
                chart: this,
                event: b
            }, this.fire(a.type, a))
        },
        handleRightClick: function(a, b) {
            isNaN(a) || (a = this.chartData[a]);
            var c = {
                type: "rightClickSlice",
                dataItem: a,
                chart: this,
                event: b
            };
            this.fire(c.type, c)
        },
        drawTicks: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                if (c.label && !c.skipTick) {
                    var e = c.ty,
                        e = d.line(this.container, [c.tx0, c.tx, c.tx2], [c.ty0, e, e], this.labelTickColor, this.labelTickAlpha);
                    d.setCN(this, e, this.type + "-tick");
                    d.setCN(this, e, c.className, !0);
                    c.tick = e;
                    c.wedge.push(e)
                }
            }
        },
        initialStart: function() {
            var a = this,
                b = a.startDuration,
                c = setTimeout(function() {
                    a.showLabels.call(a)
                }, 1E3 * b);
            a.timeOuts.push(c);
            a.chartCreated ? a.pullSlices(!0) : (a.startSlices(), 0 < b ? (b = setTimeout(function() {
                a.pullSlices.call(a)
            }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices(!0))
        },
        pullSlice: function(a, b, c) {
            var e = this.pullOutDuration;
            !0 === c && (e = 0);
            if (c = a.wedge) 0 < e ? (c.animate({
                translate: b * a.pullX + "," + b * a.pullY
            }, e, this.pullOutEffect), a.labelSet && a.labelSet.animate({
                translate: b * a.pullX + "," + b * a.pullY
            }, e, this.pullOutEffect)) : (a.labelSet && a.labelSet.translate(b * a.pullX, b * a.pullY), c.translate(b * a.pullX, b * a.pullY));
            1 == b ? (a.pulled = !0, this.pullOutOnlyOne && this.pullInAll(a.index), a = {
                type: "pullOutSlice",
                dataItem: a,
                chart: this
            }) : (a.pulled = !1, a = {
                type: "pullInSlice",
                dataItem: a,
                chart: this
            });
            this.fire(a.type, a)
        },
        pullInAll: function(a) {
            var b = this.chartData,
                c;
            for (c = 0; c < this.chartData.length; c++) c != a && b[c].pulled && this.pullSlice(b[c], 0)
        },
        pullOutAll: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++) a[b].pulled || this.pullSlice(a[b], 1)
        },
        parseData: function() {
            var a = [];
            this.chartData = a;
            var b = this.dataProvider;
            isNaN(this.pieAlpha) || (this.alpha = this.pieAlpha);
            if (void 0 !== b) {
                var c = b.length,
                    e = 0,
                    h, f, g;
                for (h = 0; h < c; h++) {
                    f = {};
                    var k = b[h];
                    f.dataContext = k;
                    null !== k[this.valueField] && (f.value = Number(k[this.valueField]));
                    (g = k[this.titleField]) || (g = "");
                    f.title = g;
                    f.pulled = d.toBoolean(k[this.pulledField], !1);
                    (g = k[this.descriptionField]) || (g = "");
                    f.description = g;
                    f.labelRadius = Number(k[this.labelRadiusField]);
                    f.switchable = !0;
                    f.className = k[this.classNameField];
                    f.url = k[this.urlField];
                    g = k[this.patternField];
                    !g && this.patterns && (g = this.patterns[h]);
                    f.pattern = g;
                    f.visibleInLegend = d.toBoolean(k[this.visibleInLegendField], !0);
                    g = k[this.alphaField];
                    f.alpha = void 0 !== g ? Number(g) : this.alpha;
                    g = k[this.colorField];
                    void 0 !== g && (f.color = g);
                    f.labelColor = d.toColor(k[this.labelColorField]);
                    e += f.value;
                    f.hidden = !1;
                    a[h] = f
                }
                for (h = b = 0; h < c; h++) f = a[h], f.percents = f.value / e * 100, f.percents < this.groupPercent && b++;
                1 < b && (this.groupValue = 0, this.removeSmallSlices(), a.push({
                    title: this.groupedTitle,
                    value: this.groupValue,
                    percents: this.groupValue / e * 100,
                    pulled: this.groupedPulled,
                    color: this.groupedColor,
                    url: this.groupedUrl,
                    description: this.groupedDescription,
                    alpha: this.groupedAlpha,
                    pattern: this.groupedPattern,
                    className: this.groupedClassName,
                    dataContext: {}
                }));
                c = this.baseColor;
                c || (c = this.pieBaseColor);
                e = this.brightnessStep;
                e || (e = this.pieBrightnessStep);
                for (h = 0; h < a.length; h++) c ? g = d.adjustLuminosity(c, h * e / 100) : (g = this.colors[h], void 0 === g && (g = d.randomColor())), void 0 === a[h].color && (a[h].color = g);
                this.recalculatePercents()
            }
        },
        recalculatePercents: function() {
            var a = this.chartData,
                b = 0,
                c, e;
            for (c = 0; c < a.length; c++) e = a[c], !e.hidden && 0 < e.value && (b += e.value);
            for (c = 0; c < a.length; c++) e = this.chartData[c], e.percents = !e.hidden && 0 < e.value ? 100 * e.value / b : 0
        },
        removeSmallSlices: function() {
            var a = this.chartData,
                b;
            for (b = a.length - 1; 0 <= b; b--) a[b].percents < this.groupPercent && (this.groupValue += a[b].value, a.splice(b, 1))
        },
        animateAgain: function() {
            var a = this;
            a.startSlices();
            for (var b = 0; b < a.chartData.length; b++) {
                var c = a.chartData[b];
                c.started = !1;
                var e = c.wedge;
                e && e.translate(c.startX, c.startY);
                (e = c.labelSet) && e.translate(c.startX, c.startY)
            }
            b = a.startDuration;
            0 < b ? (b = setTimeout(function() {
                a.pullSlices.call(a)
            }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices()
        },
        measureMaxLabel: function() {
            var a = this.chartData,
                b = 0,
                c;
            for (c = 0; c < a.length; c++) {
                var e = a[c],
                    h = this.formatString(this.labelText, e),
                    f = this.labelFunction;
                f && (h = f(e, h));
                e = d.text(this.container, h, this.color, this.fontFamily, this.fontSize);
                h = e.getBBox().width;
                h > b && (b = h);
                e.remove()
            }
            return b
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmRectangularChart = d.Class({
        inherits: d.AmCoordinateChart,
        construct: function(a) {
            d.AmRectangularChart.base.construct.call(this, a);
            this.theme = a;
            this.createEvents("zoomed");
            this.marginRight = this.marginBottom = this.marginTop = this.marginLeft = 20;
            this.verticalPosition = this.horizontalPosition = this.depth3D = this.angle = 0;
            this.heightMultiplier = this.widthMultiplier = 1;
            this.plotAreaFillColors = "#FFFFFF";
            this.plotAreaFillAlphas = 0;
            this.plotAreaBorderColor = "#000000";
            this.plotAreaBorderAlpha = 0;
            this.zoomOutButtonImageSize = 19;
            this.zoomOutButtonImage = "lens";
            this.zoomOutText = "Show all";
            this.zoomOutButtonColor = "#e5e5e5";
            this.zoomOutButtonAlpha = 0;
            this.zoomOutButtonRollOverAlpha = 1;
            this.zoomOutButtonPadding = 8;
            this.trendLines = [];
            this.autoMargins = !0;
            this.marginsUpdated = !1;
            this.autoMarginOffset = 10;
            d.applyTheme(this, a, "AmRectangularChart")
        },
        initChart: function() {
            d.AmRectangularChart.base.initChart.call(this);
            this.updateDxy();
            var a = !0;
            !this.marginsUpdated && this.autoMargins && (this.resetMargins(), a = !1);
            this.processScrollbars();
            this.updateMargins();
            this.updatePlotArea();
            this.updateScrollbars();
            this.updateTrendLines();
            this.updateChartCursor();
            this.updateValueAxes();
            a && (this.scrollbarOnly || this.updateGraphs())
        },
        drawChart: function() {
            d.AmRectangularChart.base.drawChart.call(this);
            this.drawPlotArea();
            if (d.ifArray(this.chartData)) {
                var a = this.chartCursor;
                a && a.draw()
            }
        },
        resetMargins: function() {
            var a = {},
                b;
            if ("xy" == this.type) {
                var c = this.xAxes,
                    e = this.yAxes;
                for (b = 0; b < c.length; b++) {
                    var d = c[b];
                    d.ignoreAxisWidth || (d.setOrientation(!0), d.fixAxisPosition(), a[d.position] = !0)
                }
                for (b = 0; b < e.length; b++) c = e[b], c.ignoreAxisWidth || (c.setOrientation(!1), c.fixAxisPosition(), a[c.position] = !0)
            } else {
                e = this.valueAxes;
                for (b = 0; b < e.length; b++) c = e[b], c.ignoreAxisWidth || (c.setOrientation(this.rotate), c.fixAxisPosition(), a[c.position] = !0);
                (b = this.categoryAxis) && !b.ignoreAxisWidth && (b.setOrientation(!this.rotate), b.fixAxisPosition(), b.fixAxisPosition(), a[b.position] = !0)
            }
            a.left && (this.marginLeft = 0);
            a.right && (this.marginRight = 0);
            a.top && (this.marginTop = 0);
            a.bottom && (this.marginBottom = 0);
            this.fixMargins = a
        },
        measureMargins: function() {
            var a = this.valueAxes,
                b, c = this.autoMarginOffset,
                e = this.fixMargins,
                d = this.realWidth,
                f = this.realHeight,
                g = c,
                k = c,
                l = d;
            b = f;
            var m;
            for (m = 0; m < a.length; m++) a[m].handleSynchronization(), b = this.getAxisBounds(a[m], g, l, k, b), g = Math.round(b.l), l = Math.round(b.r), k = Math.round(b.t), b = Math.round(b.b);
            if (a = this.categoryAxis) b = this.getAxisBounds(a, g, l, k, b), g = Math.round(b.l), l = Math.round(b.r), k = Math.round(b.t), b = Math.round(b.b);
            e.left && g < c && (this.marginLeft = Math.round(-g + c));
            e.right && l >= d - c && (this.marginRight = Math.round(l - d + c));
            e.top && k < c + this.titleHeight && (this.marginTop = Math.round(this.marginTop - k + c + this.titleHeight));
            e.bottom && b > f - c && (this.marginBottom = Math.round(this.marginBottom + b - f + c));
            this.initChart()
        },
        getAxisBounds: function(a, b, c, e, d) {
            if (!a.ignoreAxisWidth) {
                var f = a.labelsSet,
                    g = a.tickLength;
                a.inside && (g = 0);
                if (f) switch (f = a.getBBox(), a.position) {
                    case "top":
                        a = f.y;
                        e > a && (e = a);
                        break;
                    case "bottom":
                        a = f.y + f.height;
                        d < a && (d = a);
                        break;
                    case "right":
                        a = f.x + f.width + g + 3;
                        c < a && (c = a);
                        break;
                    case "left":
                        a = f.x - g, b > a && (b = a)
                }
            }
            return {
                l: b,
                t: e,
                r: c,
                b: d
            }
        },
        drawZoomOutButton: function() {
            var a = this;
            if (!a.zbSet) {
                var b = a.container.set();
                a.zoomButtonSet.push(b);
                var c = a.color,
                    e = a.fontSize,
                    h = a.zoomOutButtonImageSize,
                    f = a.zoomOutButtonImage.replace(/\.[a-z]*$/i, ""),
                    g = d.lang.zoomOutText || a.zoomOutText,
                    k = a.zoomOutButtonColor,
                    l = a.zoomOutButtonAlpha,
                    m = a.zoomOutButtonFontSize,
                    n = a.zoomOutButtonPadding;
                isNaN(m) || (e = m);
                (m = a.zoomOutButtonFontColor) && (c = m);
                var m = a.zoomOutButton,
                    p;
                m && (m.fontSize && (e = m.fontSize), m.color && (c = m.color), m.backgroundColor && (k = m.backgroundColor), isNaN(m.backgroundAlpha) || (a.zoomOutButtonRollOverAlpha = m.backgroundAlpha));
                var q = m = 0;
                void 0 !== a.pathToImages && f && (p = a.container.image(a.pathToImages + f + a.extension, 0, 0, h, h), d.setCN(a, p, "zoom-out-image"), b.push(p), p = p.getBBox(), m = p.width + 5);
                void 0 !== g && (c = d.text(a.container, g, c, a.fontFamily, e, "start"), d.setCN(a, c, "zoom-out-label"), e = c.getBBox(), q = p ? p.height / 2 - 3 : e.height / 2, c.translate(m, q), b.push(c));
                p = b.getBBox();
                c = 1;
                d.isModern || (c = 0);
                k = d.rect(a.container, p.width + 2 * n + 5, p.height + 2 * n - 2, k, 1, 1, k, c);
                k.setAttr("opacity", l);
                k.translate(-n, -n);
                d.setCN(a, k, "zoom-out-bg");
                b.push(k);
                k.toBack();
                a.zbBG = k;
                p = k.getBBox();
                b.translate(a.marginLeftReal + a.plotAreaWidth - p.width + n, a.marginTopReal + n);
                b.hide();
                b.mouseover(function() {
                    a.rollOverZB()
                }).mouseout(function() {
                    a.rollOutZB()
                }).click(function() {
                    a.clickZB()
                }).touchstart(function() {
                    a.rollOverZB()
                }).touchend(function() {
                    a.rollOutZB();
                    a.clickZB()
                });
                for (l = 0; l < b.length; l++) b[l].attr({
                    cursor: "pointer"
                });
                a.zbSet = b
            }
        },
        rollOverZB: function() {
            this.zbBG.setAttr("opacity", this.zoomOutButtonRollOverAlpha)
        },
        rollOutZB: function() {
            this.zbBG.setAttr("opacity", this.zoomOutButtonAlpha)
        },
        clickZB: function() {
            this.zoomOut()
        },
        zoomOut: function() {
            this.updateScrollbar = !0;
            this.zoom()
        },
        drawPlotArea: function() {
            var a = this.dx,
                b = this.dy,
                c = this.marginLeftReal,
                e = this.marginTopReal,
                h = this.plotAreaWidth - 1,
                f = this.plotAreaHeight - 1,
                g = this.plotAreaFillColors,
                k = this.plotAreaFillAlphas,
                l = this.plotAreaBorderColor,
                m = this.plotAreaBorderAlpha;
            "object" == typeof k && (k = k[0]);
            g = d.polygon(this.container, [0, h, h, 0, 0], [0, 0, f, f, 0], g, k, 1, l, m, this.plotAreaGradientAngle);
            d.setCN(this, g, "plot-area");
            g.translate(c + a, e + b);
            this.set.push(g);
            0 !== a && 0 !== b && (g = this.plotAreaFillColors, "object" == typeof g && (g = g[0]), g = d.adjustLuminosity(g, -.15), h = d.polygon(this.container, [0, a, h + a, h, 0], [0, b, b, 0, 0], g, k, 1, l, m), d.setCN(this, h, "plot-area-bottom"), h.translate(c, e + f), this.set.push(h), a = d.polygon(this.container, [0, 0, a, a, 0], [0, f, f + b, b, 0], g, k, 1, l, m), d.setCN(this, a, "plot-area-left"), a.translate(c, e), this.set.push(a));
            (c = this.bbset) && this.scrollbarOnly && c.remove()
        },
        updatePlotArea: function() {
            var a = this.updateWidth(),
                b = this.updateHeight(),
                c = this.container;
            this.realWidth = a;
            this.realWidth = b;
            c && this.container.setSize(a, b);
            a = a - this.marginLeftReal - this.marginRightReal - this.dx;
            b = b - this.marginTopReal - this.marginBottomReal;
            1 > a && (a = 1);
            1 > b && (b = 1);
            this.plotAreaWidth = Math.round(a);
            this.plotAreaHeight = Math.round(b)
        },
        updateDxy: function() {
            this.dx = Math.round(this.depth3D * Math.cos(this.angle * Math.PI / 180));
            this.dy = Math.round(-this.depth3D * Math.sin(this.angle * Math.PI / 180));
            this.d3x = Math.round(this.columnSpacing3D * Math.cos(this.angle * Math.PI / 180));
            this.d3y = Math.round(-this.columnSpacing3D * Math.sin(this.angle * Math.PI / 180))
        },
        updateMargins: function() {
            var a = this.getTitleHeight();
            this.titleHeight = a;
            this.marginTopReal = this.marginTop - this.dy;
            this.fixMargins && !this.fixMargins.top && (this.marginTopReal += a);
            this.marginBottomReal = this.marginBottom;
            this.marginLeftReal = this.marginLeft;
            this.marginRightReal = this.marginRight
        },
        updateValueAxes: function() {
            var a = this.valueAxes,
                b = this.marginLeftReal,
                c = this.marginTopReal,
                e = this.plotAreaHeight,
                h = this.plotAreaWidth,
                f;
            for (f = 0; f < a.length; f++) {
                var g = a[f];
                g.axisRenderer = d.RecAxis;
                g.guideFillRenderer = d.RecFill;
                g.axisItemRenderer = d.RecItem;
                g.dx = this.dx;
                g.dy = this.dy;
                g.viW = h - 1;
                g.viH = e - 1;
                g.marginsChanged = !0;
                g.viX = b;
                g.viY = c;
                this.updateObjectSize(g)
            }
        },
        updateObjectSize: function(a) {
            a.width = (this.plotAreaWidth - 1) * this.widthMultiplier;
            a.height = (this.plotAreaHeight - 1) * this.heightMultiplier;
            a.x = this.marginLeftReal + this.horizontalPosition;
            a.y = this.marginTopReal + this.verticalPosition
        },
        updateGraphs: function() {
            var a = this.graphs,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.x = this.marginLeftReal + this.horizontalPosition;
                c.y = this.marginTopReal + this.verticalPosition;
                c.width = this.plotAreaWidth * this.widthMultiplier;
                c.height = this.plotAreaHeight * this.heightMultiplier;
                c.index = b;
                c.dx = this.dx;
                c.dy = this.dy;
                c.rotate = this.rotate
            }
        },
        updateChartCursor: function() {
            var a = this.chartCursor;
            a && (a = d.processObject(a, d.ChartCursor, this.theme), this.addChartCursor(a), a.x = this.marginLeftReal, a.y = this.marginTopReal, a.width = this.plotAreaWidth - 1, a.height = this.plotAreaHeight - 1, a.chart = this)
        },
        processScrollbars: function() {
            var a = this.chartScrollbar;
            a && (a = d.processObject(a, d.ChartScrollbar, this.theme), this.addChartScrollbar(a))
        },
        updateScrollbars: function() {},
        addChartCursor: function(a) {
            d.callMethod("destroy", [this.chartCursor]);
            a && (this.listenTo(a, "changed", this.handleCursorChange), this.listenTo(a, "zoomed", this.handleCursorZoom));
            this.chartCursor = a
        },
        removeChartCursor: function() {
            d.callMethod("destroy", [this.chartCursor]);
            this.chartCursor = null
        },
        zoomTrendLines: function() {
            var a = this.trendLines,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.valueAxis.recalculateToPercents ? c.set && c.set.hide() : (c.x = this.marginLeftReal + this.horizontalPosition, c.y = this.marginTopReal + this.verticalPosition, c.draw())
            }
        },
        addTrendLine: function(a) {
            this.trendLines.push(a)
        },
        removeTrendLine: function(a) {
            var b = this.trendLines,
                c;
            for (c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1)
        },
        adjustMargins: function(a, b) {
            var c = a.position,
                e = a.scrollbarHeight + a.offset;
            a.enabled && ("top" == c ? b ? this.marginLeftReal += e : this.marginTopReal += e : b ? this.marginRightReal += e : this.marginBottomReal += e)
        },
        getScrollbarPosition: function(a, b, c) {
            var e = "bottom",
                d = "top";
            a.oppositeAxis || (d = e, e = "top");
            a.position = b ? "bottom" == c || "left" == c ? e : d : "top" == c || "right" == c ? e : d
        },
        updateChartScrollbar: function(a, b) {
            if (a) {
                a.rotate = b;
                var c = this.marginTopReal,
                    e = this.marginLeftReal,
                    d = a.scrollbarHeight,
                    f = this.dx,
                    g = this.dy,
                    k = a.offset;
                "top" == a.position ? b ? (a.y = c, a.x = e - d - k) : (a.y = c - d + g - k, a.x = e + f) : b ? (a.y = c + g, a.x = e + this.plotAreaWidth + f + k) : (a.y = c + this.plotAreaHeight + k, a.x = this.marginLeftReal)
            }
        },
        showZB: function(a) {
            var b = this.zbSet;
            a && (b = this.zoomOutText, "" !== b && b && this.drawZoomOutButton());
            if (b = this.zbSet) this.zoomButtonSet.push(b), a ? b.show() : b.hide(), this.rollOutZB()
        },
        handleReleaseOutside: function(a) {
            d.AmRectangularChart.base.handleReleaseOutside.call(this, a);
            (a = this.chartCursor) && a.handleReleaseOutside && a.handleReleaseOutside()
        },
        handleMouseDown: function(a) {
            d.AmRectangularChart.base.handleMouseDown.call(this, a);
            var b = this.chartCursor;
            b && b.handleMouseDown && b.handleMouseDown(a)
        },
        handleCursorChange: function() {},
        update: function() {
            d.AmRectangularChart.base.update.call(this);
            this.chartCursor && this.chartCursor.update && this.chartCursor.update()
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.TrendLine = d.Class({
        construct: function(a) {
            this.cname = "TrendLine";
            this.createEvents("click");
            this.isProtected = !1;
            this.dashLength = 0;
            this.lineColor = "#00CC00";
            this.lineThickness = this.lineAlpha = 1;
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this;
            a.destroy();
            var b = a.chart,
                c = b.container,
                e, h, f, g, k = a.categoryAxis,
                l = a.initialDate,
                m = a.initialCategory,
                n = a.finalDate,
                p = a.finalCategory,
                q = a.valueAxis,
                r = a.valueAxisX,
                u = a.initialXValue,
                t = a.finalXValue,
                z = a.initialValue,
                y = a.finalValue,
                v = q.recalculateToPercents,
                w = b.dataDateFormat;
            k && (l && (l = d.getDate(l, w, "fff"), a.initialDate = l, e = k.dateToCoordinate(l)), m && (e = k.categoryToCoordinate(m)), n && (n = d.getDate(n, w, "fff"), a.finalDate = n, h = k.dateToCoordinate(n)), p && (h = k.categoryToCoordinate(p)));
            r && !v && (isNaN(u) || (e = r.getCoordinate(u)), isNaN(t) || (h = r.getCoordinate(t)));
            q && !v && (isNaN(z) || (f = q.getCoordinate(z)), isNaN(y) || (g = q.getCoordinate(y)));
            if (!(isNaN(e) || isNaN(h) || isNaN(f) || isNaN(f))) {
                b.rotate ? (k = [f, g], g = [e, h]) : (k = [e, h], g = [f, g]);
                l = a.lineColor;
                f = d.line(c, k, g, l, a.lineAlpha, a.lineThickness, a.dashLength);
                e = k;
                h = g;
                p = k[1] - k[0];
                q = g[1] - g[0];
                0 === p && (p = .01);
                0 === q && (q = .01);
                m = p / Math.abs(p);
                n = q / Math.abs(q);
                q = p * q / Math.abs(p * q) * Math.sqrt(Math.pow(p, 2) + Math.pow(q, 2));
                p = Math.asin(p / q);
                q = 90 * Math.PI / 180 - p;
                p = Math.abs(5 * Math.cos(q));
                q = Math.abs(5 * Math.sin(q));
                e.push(k[1] - m * q, k[0] - m * q);
                h.push(g[1] + n * p, g[0] + n * p);
                k = d.polygon(c, e, h, l, .005, 0);
                c = c.set([k, f]);
                c.translate(b.marginLeftReal, b.marginTopReal);
                b.trendLinesSet.push(c);
                d.setCN(b, f, "trend-line");
                d.setCN(b, f, "trend-line-" + a.id);
                a.line = f;
                a.set = c;
                if (f = a.initialImage) f = d.processObject(f, d.Image, a.theme), f.chart = b, f.draw(), f.translate(e[0] + f.offsetX, h[0] + f.offsetY), c.push(f.set);
                if (f = a.finalImage) f = d.processObject(f, d.Image, a.theme), f.chart = b, f.draw(), f.translate(e[1] + f.offsetX, h[1] + f.offsetY), c.push(f.set);
                k.mouseup(function() {
                    a.handleLineClick()
                }).mouseover(function() {
                    a.handleLineOver()
                }).mouseout(function() {
                    a.handleLineOut()
                });
                k.touchend && k.touchend(function() {
                    a.handleLineClick()
                });
                c.clipRect(0, 0, b.plotAreaWidth, b.plotAreaHeight)
            }
        },
        handleLineClick: function() {
            var a = {
                type: "click",
                trendLine: this,
                chart: this.chart
            };
            this.fire(a.type, a)
        },
        handleLineOver: function() {
            var a = this.rollOverColor;
            void 0 !== a && this.line.attr({
                stroke: a
            })
        },
        handleLineOut: function() {
            this.line.attr({
                stroke: this.lineColor
            })
        },
        destroy: function() {
            d.remove(this.set)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.Image = d.Class({
        construct: function(a) {
            this.cname = "Image";
            this.height = this.width = 20;
            this.rotation = this.offsetY = this.offsetX = 0;
            this.balloonColor = this.color = "#000000";
            this.opacity = 1;
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this;
            a.set && a.set.remove();
            var b = a.chart.container;
            a.set = b.set();
            var c, e;
            a.url ? (c = b.image(a.url, 0, 0, a.width, a.height), e = 1) : a.svgPath && (c = b.path(a.svgPath), c.setAttr("fill", a.color), c.setAttr("stroke", a.outlineColor), b = c.getBBox(), e = Math.min(a.width / b.width, a.height / b.height));
            c && (c.setAttr("opacity", a.opacity), a.set.rotate(a.rotation), c.translate(-a.width / 2, -a.height / 2, e), a.balloonText && c.mouseover(function(b) {
                a.chart.showBalloon(a.balloonText, a.balloonColor, !0)
            }).mouseout(function(b) {
                a.chart.hideBalloon()
            }).touchend(function(b) {
                a.chart.hideBalloon()
            }).touchstart(function(b) {
                a.chart.showBalloon(a.balloonText, a.balloonColor, !0)
            }), a.set.push(c))
        },
        translate: function(a, b) {
            this.set && this.set.translate(a, b)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.circle = function(a, b, c, e, h, f, g, k, l) {
        0 >= b && (b = .001);
        if (void 0 == h || 0 === h) h = .01;
        void 0 === f && (f = "#000000");
        void 0 === g && (g = 0);
        e = {
            fill: c,
            stroke: f,
            "fill-opacity": e,
            "stroke-width": h,
            "stroke-opacity": g
        };
        a = isNaN(l) ? a.circle(0, 0, b).attr(e) : a.ellipse(0, 0, b, l).attr(e);
        k && a.gradient("radialGradient", [c, d.adjustLuminosity(c, -.6)]);
        return a
    };
    d.text = function(a, b, c, e, h, f, g, k) {
        f || (f = "middle");
        "right" == f && (f = "end");
        "left" == f && (f = "start");
        isNaN(k) && (k = 1);
        void 0 !== b && (b = String(b), d.isIE && !d.isModern && (b = b.replace("&amp;", "&"), b = b.replace("&", "&amp;")));
        c = {
            fill: c,
            "font-family": e,
            "font-size": h + "px",
            opacity: k
        };
        !0 === g && (c["font-weight"] = "bold");
        c["text-anchor"] = f;
        return a.text(b, c)
    };
    d.polygon = function(a, b, c, e, h, f, g, k, l, m, n) {
        isNaN(f) && (f = .01);
        isNaN(k) && (k = h);
        var p = e,
            q = !1;
        "object" == typeof p && 1 < p.length && (q = !0, p = p[0]);
        void 0 === g && (g = p);
        h = {
            fill: p,
            stroke: g,
            "fill-opacity": h,
            "stroke-width": f,
            "stroke-opacity": k
        };
        void 0 !== n && 0 < n && (h["stroke-dasharray"] = n);
        n = d.dx;
        f = d.dy;
        a.handDrawn && (c = d.makeHD(b, c, a.handDrawScatter), b = c[0], c = c[1]);
        g = Math.round;
        m && (g = d.doNothing);
        m = "M" + (g(b[0]) + n) + "," + (g(c[0]) + f);
        for (k = 1; k < b.length; k++) m += " L" + (g(b[k]) + n) + "," + (g(c[k]) + f);
        a = a.path(m + " Z").attr(h);
        q && a.gradient("linearGradient", e, l);
        return a
    };
    d.rect = function(a, b, c, e, h, f, g, k, l, m, n) {
        if (isNaN(b) || isNaN(c)) return a.set();
        isNaN(f) && (f = 0);
        void 0 === l && (l = 0);
        void 0 === m && (m = 270);
        isNaN(h) && (h = 0);
        var p = e,
            q = !1;
        "object" == typeof p && (p = p[0], q = !0);
        void 0 === g && (g = p);
        void 0 === k && (k = h);
        b = Math.round(b);
        c = Math.round(c);
        var r = 0,
            u = 0;
        0 > b && (b = Math.abs(b), r = -b);
        0 > c && (c = Math.abs(c), u = -c);
        r += d.dx;
        u += d.dy;
        h = {
            fill: p,
            stroke: g,
            "fill-opacity": h,
            "stroke-opacity": k
        };
        void 0 !== n && 0 < n && (h["stroke-dasharray"] = n);
        a = a.rect(r, u, b, c, l, f).attr(h);
        q && a.gradient("linearGradient", e, m);
        return a
    };
    d.bullet = function(a, b, c, e, h, f, g, k, l, m, n, p) {
        var q;
        "circle" == b && (b = "round");
        switch (b) {
            case "round":
                q = d.circle(a, c / 2, e, h, f, g, k);
                break;
            case "square":
                q = d.polygon(a, [-c / 2, c / 2, c / 2, -c / 2], [c / 2, c / 2, -c / 2, -c / 2], e, h, f, g, k, m - 180);
                break;
            case "rectangle":
                q = d.polygon(a, [-c, c, c, -c], [c / 2, c / 2, -c / 2, -c / 2], e, h, f, g, k, m - 180);
                break;
            case "diamond":
                q = d.polygon(a, [-c / 2, 0, c / 2, 0], [0, -c / 2, 0, c / 2], e, h, f, g, k);
                break;
            case "triangleUp":
                q = d.triangle(a, c, 0, e, h, f, g, k);
                break;
            case "triangleDown":
                q = d.triangle(a, c, 180, e, h, f, g, k);
                break;
            case "triangleLeft":
                q = d.triangle(a, c, 270, e, h, f, g, k);
                break;
            case "triangleRight":
                q = d.triangle(a, c, 90, e, h, f, g, k);
                break;
            case "bubble":
                q = d.circle(a, c / 2, e, h, f, g, k, !0);
                break;
            case "line":
                q = d.line(a, [-c / 2, c / 2], [0, 0], e, h, f, g, k);
                break;
            case "yError":
                q = a.set();
                q.push(d.line(a, [0, 0], [-c / 2, c / 2], e, h, f));
                q.push(d.line(a, [-l, l], [-c / 2, -c / 2], e, h, f));
                q.push(d.line(a, [-l, l], [c / 2, c / 2], e, h, f));
                break;
            case "xError":
                q = a.set(), q.push(d.line(a, [-c / 2, c / 2], [0, 0], e, h, f)), q.push(d.line(a, [-c / 2, -c / 2], [-l, l], e, h, f)), q.push(d.line(a, [c / 2, c / 2], [-l, l], e, h, f))
        }
        q && q.pattern(n, NaN, p);
        return q
    };
    d.triangle = function(a, b, c, e, d, f, g, k) {
        if (void 0 === f || 0 === f) f = 1;
        void 0 === g && (g = "#000");
        void 0 === k && (k = 0);
        e = {
            fill: e,
            stroke: g,
            "fill-opacity": d,
            "stroke-width": f,
            "stroke-opacity": k
        };
        b /= 2;
        var l;
        0 === c && (l = " M" + -b + "," + b + " L0," + -b + " L" + b + "," + b + " Z");
        180 == c && (l = " M" + -b + "," + -b + " L0," + b + " L" + b + "," + -b + " Z");
        90 == c && (l = " M" + -b + "," + -b + " L" + b + ",0 L" + -b + "," + b + " Z");
        270 == c && (l = " M" + -b + ",0 L" + b + "," + b + " L" + b + "," + -b + " Z");
        return a.path(l).attr(e)
    };
    d.line = function(a, b, c, e, h, f, g, k, l, m, n) {
        if (a.handDrawn && !n) return d.handDrawnLine(a, b, c, e, h, f, g, k, l, m, n);
        f = {
            fill: "none",
            "stroke-width": f
        };
        void 0 !== g && 0 < g && (f["stroke-dasharray"] = g);
        isNaN(h) || (f["stroke-opacity"] = h);
        e && (f.stroke = e);
        e = Math.round;
        m && (e = d.doNothing);
        m = d.dx;
        h = d.dy;
        g = "M" + (e(b[0]) + m) + "," + (e(c[0]) + h);
        for (k = 1; k < b.length; k++) g += " L" + (e(b[k]) + m) + "," + (e(c[k]) + h);
        if (d.VML) return a.path(g, void 0, !0).attr(f);
        l && (g += " M0,0 L0,0");
        return a.path(g).attr(f)
    };
    d.makeHD = function(a, b, c) {
        for (var e = [], d = [], f = 1; f < a.length; f++)
            for (var g = Number(a[f - 1]), k = Number(b[f - 1]), l = Number(a[f]), m = Number(b[f]), n = Math.sqrt(Math.pow(l - g, 2) + Math.pow(m - k, 2)), n = Math.round(n / 50) + 1, l = (l - g) / n, m = (m - k) / n, p = 0; p <= n; p++) {
                var q = g + p * l + Math.random() * c,
                    r = k + p * m + Math.random() * c;
                e.push(q);
                d.push(r)
            }
        return [e, d]
    };
    d.handDrawnLine = function(a, b, c, e, h, f, g, k, l, m) {
        var n, p = a.set();
        for (n = 1; n < b.length; n++)
            for (var q = [b[n - 1], b[n]], r = [c[n - 1], c[n]], r = d.makeHD(q, r, a.handDrawScatter), q = r[0], r = r[1], u = 1; u < q.length; u++) p.push(d.line(a, [q[u - 1], q[u]], [r[u - 1], r[u]], e, h, f + Math.random() * a.handDrawThickness - a.handDrawThickness / 2, g, k, l, m, !0));
        return p
    };
    d.doNothing = function(a) {
        return a
    };
    d.wedge = function(a, b, c, e, h, f, g, k, l, m, n, p, q) {
        var r = Math.round;
        f = r(f);
        g = r(g);
        k = r(k);
        var u = r(g / f * k),
            t = d.VML,
            z = 359.5 + f / 100;
        359.94 < z && (z = 359.94);
        h >= z && (h = z);
        var y = 1 / 180 * Math.PI,
            z = b + Math.sin(e * y) * k,
            v = c - Math.cos(e * y) * u,
            w = b + Math.sin(e * y) * f,
            A = c - Math.cos(e * y) * g,
            B = b + Math.sin((e + h) * y) * f,
            C = c - Math.cos((e + h) * y) * g,
            D = b + Math.sin((e + h) * y) * k,
            y = c - Math.cos((e + h) * y) * u,
            J = {
                fill: d.adjustLuminosity(m.fill, -.2),
                "stroke-opacity": 0,
                "fill-opacity": m["fill-opacity"]
            },
            E = 0;
        180 < Math.abs(h) && (E = 1);
        e = a.set();
        var O;
        t && (z = r(10 * z), w = r(10 * w), B = r(10 * B), D = r(10 * D), v = r(10 * v), A = r(10 * A), C = r(10 * C), y = r(10 * y), b = r(10 * b), l = r(10 * l), c = r(10 * c), f *= 10, g *= 10, k *= 10, u *= 10, 1 > Math.abs(h) && 1 >= Math.abs(B -
            w) && 1 >= Math.abs(C - A) && (O = !0));
        h = "";
        var I;
        p && (J["fill-opacity"] = 0, J["stroke-opacity"] = m["stroke-opacity"] / 2, J.stroke = m.stroke);
        if (0 < l) {
            I = " M" + z + "," + (v + l) + " L" + w + "," + (A + l);
            t ? (O || (I += " A" + (b - f) + "," + (l + c - g) + "," + (b + f) + "," + (l + c + g) + "," + w + "," + (A + l) + "," + B + "," + (C + l)), I += " L" + D + "," + (y + l), 0 < k && (O || (I += " B" + (b - k) + "," + (l + c - u) + "," + (b + k) + "," + (l + c + u) + "," + D + "," + (l + y) + "," + z + "," + (l + v)))) : (I += " A" + f + "," + g + ",0," + E + ",1," + B + "," + (C + l) + " L" + D + "," + (y + l), 0 < k && (I += " A" + k + "," + u + ",0," + E + ",0," + z + "," + (v + l)));
            I += " Z";
            var W = l;
            t && (W /= 10);
            for (var ea = 0; ea < W; ea += 10) {
                var P = a.path(I, void 0, void 0, "1000,1000").attr(J);
                e.push(P);
                P.translate(0, -ea)
            }
            I = a.path(" M" + z + "," + v + " L" + z + "," + (v + l) + " L" + w + "," + (A + l) + " L" + w + "," + A + " L" + z + "," + v + " Z", void 0, void 0, "1000,1000").attr(J);
            l = a.path(" M" + B + "," + C + " L" + B + "," + (C + l) + " L" + D + "," + (y + l) + " L" + D + "," + y + " L" + B + "," + C + " Z", void 0, void 0, "1000,1000").attr(J);
            e.push(I);
            e.push(l)
        }
        t ? (O || (h = " A" + r(b - f) + "," + r(c - g) + "," + r(b + f) + "," + r(c + g) + "," + r(w) + "," + r(A) + "," + r(B) + "," + r(C)), f = " M" + r(z) + "," + r(v) + " L" + r(w) + "," + r(A) +
            h + " L" + r(D) + "," + r(y)) : f = " M" + z + "," + v + " L" + w + "," + A + (" A" + f + "," + g + ",0," + E + ",1," + B + "," + C) + " L" + D + "," + y;
        0 < k && (t ? O || (f += " B" + (b - k) + "," + (c - u) + "," + (b + k) + "," + (c + u) + "," + D + "," + y + "," + z + "," + v) : f += " A" + k + "," + u + ",0," + E + ",0," + z + "," + v);
        a.handDrawn && (b = d.line(a, [z, w], [v, A], m.stroke, m.thickness * Math.random() * a.handDrawThickness, m["stroke-opacity"]), e.push(b));
        a = a.path(f + " Z", void 0, void 0, "1000,1000").attr(m);
        if (n) {
            b = [];
            for (c = 0; c < n.length; c++) b.push(d.adjustLuminosity(m.fill, n[c]));
            0 < b.length && a.gradient("linearGradient", b)
        }
        a.pattern(p, NaN, q);
        e.wedge = a;
        e.push(a);
        return e
    };
    d.rgb2hex = function(a) {
        return (a = a.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === a.length ? "#" + ("0" + parseInt(a[1], 10).toString(16)).slice(-2) + ("0" + parseInt(a[2], 10).toString(16)).slice(-2) + ("0" + parseInt(a[3], 10).toString(16)).slice(-2) : ""
    };
    d.adjustLuminosity = function(a, b) {
        a && -1 != a.indexOf("rgb") && (a = d.rgb2hex(a));
        a = String(a).replace(/[^0-9a-f]/gi, "");
        6 > a.length && (a = String(a[0]) + String(a[0]) + String(a[1]) + String(a[1]) +
            String(a[2]) + String(a[2]));
        b = b || 0;
        var c = "#",
            e, h;
        for (h = 0; 3 > h; h++) e = parseInt(a.substr(2 * h, 2), 16), e = Math.round(Math.min(Math.max(0, e + e * b), 255)).toString(16), c += ("00" + e).substr(e.length);
        return c
    }
})();
(function() {
    var d = window.AmCharts;
    d.Bezier = d.Class({
        construct: function(a, b, c, e, h, f, g, k, l, m) {
            "object" == typeof g && (g = g[0]);
            "object" == typeof k && (k = k[0]);
            0 === k && (g = "none");
            f = {
                fill: g,
                "fill-opacity": k,
                "stroke-width": f
            };
            void 0 !== l && 0 < l && (f["stroke-dasharray"] = l);
            isNaN(h) || (f["stroke-opacity"] = h);
            e && (f.stroke = e);
            e = "M" + Math.round(b[0]) + "," + Math.round(c[0]);
            h = [];
            for (l = 0; l < b.length; l++) h.push({
                x: Number(b[l]),
                y: Number(c[l])
            });
            1 < h.length && (b = this.interpolate(h), e += this.drawBeziers(b));
            m ? e += m : d.VML || (e += "M0,0 L0,0");
            this.path = a.path(e).attr(f);
            this.node = this.path.node
        },
        interpolate: function(a) {
            var b = [];
            b.push({
                x: a[0].x,
                y: a[0].y
            });
            var c = a[1].x - a[0].x,
                e = a[1].y - a[0].y,
                h = d.bezierX,
                f = d.bezierY;
            b.push({
                x: a[0].x + c / h,
                y: a[0].y + e / f
            });
            var g;
            for (g = 1; g < a.length - 1; g++) {
                var k = a[g - 1],
                    l = a[g],
                    e = a[g + 1];
                isNaN(e.x) && (e = l);
                isNaN(l.x) && (l = k);
                isNaN(k.x) && (k = l);
                c = e.x - l.x;
                e = e.y - k.y;
                k = l.x - k.x;
                k > c && (k = c);
                b.push({
                    x: l.x - k / h,
                    y: l.y - e / f
                });
                b.push({
                    x: l.x,
                    y: l.y
                });
                b.push({
                    x: l.x + k / h,
                    y: l.y + e / f
                })
            }
            e = a[a.length - 1].y - a[a.length - 2].y;
            c = a[a.length - 1].x -
                a[a.length - 2].x;
            b.push({
                x: a[a.length - 1].x - c / h,
                y: a[a.length - 1].y - e / f
            });
            b.push({
                x: a[a.length - 1].x,
                y: a[a.length - 1].y
            });
            return b
        },
        drawBeziers: function(a) {
            var b = "",
                c;
            for (c = 0; c < (a.length - 1) / 3; c++) b += this.drawBezierMidpoint(a[3 * c], a[3 * c + 1], a[3 * c + 2], a[3 * c + 3]);
            return b
        },
        drawBezierMidpoint: function(a, b, c, e) {
            var d = Math.round,
                f = this.getPointOnSegment(a, b, .75),
                g = this.getPointOnSegment(e, c, .75),
                k = (e.x - a.x) / 16,
                l = (e.y - a.y) / 16,
                m = this.getPointOnSegment(a, b, .375);
            a = this.getPointOnSegment(f, g, .375);
            a.x -= k;
            a.y -= l;
            b = this.getPointOnSegment(g, f, .375);
            b.x += k;
            b.y += l;
            c = this.getPointOnSegment(e, c, .375);
            k = this.getMiddle(m, a);
            f = this.getMiddle(f, g);
            g = this.getMiddle(b, c);
            m = " Q" + d(m.x) + "," + d(m.y) + "," + d(k.x) + "," + d(k.y);
            m += " Q" + d(a.x) + "," + d(a.y) + "," + d(f.x) + "," + d(f.y);
            m += " Q" + d(b.x) + "," + d(b.y) + "," + d(g.x) + "," + d(g.y);
            return m += " Q" + d(c.x) + "," + d(c.y) + "," + d(e.x) + "," + d(e.y)
        },
        getMiddle: function(a, b) {
            return {
                x: (a.x + b.x) / 2,
                y: (a.y + b.y) / 2
            }
        },
        getPointOnSegment: function(a, b, c) {
            return {
                x: a.x + (b.x - a.x) * c,
                y: a.y + (b.y - a.y) * c
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmDraw = d.Class({
        construct: function(a, b, c, e) {
            d.SVG_NS = "http://www.w3.org/2000/svg";
            d.SVG_XLINK = "http://www.w3.org/1999/xlink";
            d.hasSVG = !!document.createElementNS && !!document.createElementNS(d.SVG_NS, "svg").createSVGRect;
            1 > b && (b = 10);
            1 > c && (c = 10);
            this.div = a;
            this.width = b;
            this.height = c;
            this.rBin = document.createElement("div");
            d.hasSVG ? (d.SVG = !0, b = this.createSvgElement("svg"), a.appendChild(b), this.container = b, this.addDefs(e), this.R = new d.SVGRenderer(this)) : d.isIE && d.VMLRenderer && (d.VML = !0, d.vmlStyleSheet || (document.namespaces.add("amvml", "urn:schemas-microsoft-com:vml"), 31 > document.styleSheets.length ? (b = document.createStyleSheet(), b.addRule(".amvml", "behavior:url(#default#VML); display:inline-block; antialias:true"), d.vmlStyleSheet = b) : document.styleSheets[0].addRule(".amvml", "behavior:url(#default#VML); display:inline-block; antialias:true")), this.container = a, this.R = new d.VMLRenderer(this, e), this.R.disableSelection(a))
        },
        createSvgElement: function(a) {
            return document.createElementNS(d.SVG_NS, a)
        },
        circle: function(a, b, c, e) {
            var h = new d.AmDObject("circle", this);
            h.attr({
                r: c,
                cx: a,
                cy: b
            });
            this.addToContainer(h.node, e);
            return h
        },
        ellipse: function(a, b, c, e, h) {
            var f = new d.AmDObject("ellipse", this);
            f.attr({
                rx: c,
                ry: e,
                cx: a,
                cy: b
            });
            this.addToContainer(f.node, h);
            return f
        },
        setSize: function(a, b) {
            0 < a && 0 < b && (this.container.style.width = a + "px", this.container.style.height = b + "px")
        },
        rect: function(a, b, c, e, h, f, g) {
            var k = new d.AmDObject("rect", this);
            d.VML && (h = Math.round(100 * h / Math.min(c, e)), c += 2 * f, e += 2 * f, k.bw = f, k.node.style.marginLeft = -f, k.node.style.marginTop = -f);
            1 > c && (c = 1);
            1 > e && (e = 1);
            k.attr({
                x: a,
                y: b,
                width: c,
                height: e,
                rx: h,
                ry: h,
                "stroke-width": f
            });
            this.addToContainer(k.node, g);
            return k
        },
        image: function(a, b, c, e, h, f) {
            var g = new d.AmDObject("image", this);
            g.attr({
                x: b,
                y: c,
                width: e,
                height: h
            });
            this.R.path(g, a);
            this.addToContainer(g.node, f);
            return g
        },
        addToContainer: function(a, b) {
            b || (b = this.container);
            b.appendChild(a)
        },
        text: function(a, b, c) {
            return this.R.text(a, b, c)
        },
        path: function(a, b, c, e) {
            var h = new d.AmDObject("path", this);
            e || (e = "100,100");
            h.attr({
                cs: e
            });
            c ? h.attr({
                dd: a
            }) : h.attr({
                d: a
            });
            this.addToContainer(h.node, b);
            return h
        },
        set: function(a) {
            return this.R.set(a)
        },
        remove: function(a) {
            if (a) {
                var b = this.rBin;
                b.appendChild(a);
                b.innerHTML = ""
            }
        },
        renderFix: function() {
            var a = this.container,
                b = a.style;
            b.top = "0px";
            b.left = "0px";
            var c = a.getBoundingClientRect(),
                a = c.left - Math.round(c.left),
                c = c.top - Math.round(c.top);
            a && (b.left = a + "px");
            c && (b.top = c + "px")
        },
        update: function() {
            this.R.update()
        },
        addDefs: function(a) {
            if (d.hasSVG) {
                var b = this.createSvgElement("desc"),
                    c = this.container;
                c.setAttribute("version", "1.1");
                c.style.position = "absolute";
                this.setSize(this.width, this.height);
                d.rtl && (c.setAttribute("direction", "rtl"), c.style.left = "auto", c.style.right = "0px");
                a.addCodeCredits && b.appendChild(document.createTextNode("JavaScript chart by amCharts " + a.version));
                c.appendChild(b);
                a.defs && (b = this.createSvgElement("defs"), c.appendChild(b), d.parseDefs(a.defs, b), this.defs = b)
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmDObject = d.Class({
        construct: function(a, b) {
            this.D = b;
            this.R = b.R;
            this.node = this.R.create(this, a);
            this.y = this.x = 0;
            this.scale = 1
        },
        attr: function(a) {
            this.R.attr(this, a);
            return this
        },
        getAttr: function(a) {
            return this.node.getAttribute(a)
        },
        setAttr: function(a, b) {
            this.R.setAttr(this, a, b);
            return this
        },
        clipRect: function(a, b, c, d) {
            this.R.clipRect(this, a, b, c, d)
        },
        translate: function(a, b, c, d) {
            d || (a = Math.round(a), b = Math.round(b));
            this.R.move(this, a, b, c);
            this.x = a;
            this.y = b;
            this.scale = c;
            this.angle && this.rotate(this.angle)
        },
        rotate: function(a, b) {
            this.R.rotate(this, a, b);
            this.angle = a
        },
        animate: function(a, b, c) {
            for (var e in a)
                if (a.hasOwnProperty(e)) {
                    var h = e,
                        f = a[e];
                    c = d.getEffect(c);
                    this.R.animate(this, h, f, b, c)
                }
        },
        push: function(a) {
            if (a) {
                var b = this.node;
                b.appendChild(a.node);
                var c = a.clipPath;
                c && b.appendChild(c);
                (a = a.grad) && b.appendChild(a)
            }
        },
        text: function(a) {
            this.R.setText(this, a)
        },
        remove: function() {
            this.R.remove(this)
        },
        clear: function() {
            var a = this.node;
            if (a.hasChildNodes())
                for (; 1 <= a.childNodes.length;) a.removeChild(a.firstChild)
        },
        hide: function() {
            this.setAttr("visibility", "hidden")
        },
        show: function() {
            this.setAttr("visibility", "visible")
        },
        getBBox: function() {
            return this.R.getBBox(this)
        },
        toFront: function() {
            var a = this.node;
            if (a) {
                this.prevNextNode = a.nextSibling;
                var b = a.parentNode;
                b && b.appendChild(a)
            }
        },
        toPrevious: function() {
            var a = this.node;
            a && this.prevNextNode && (a = a.parentNode) && a.insertBefore(this.prevNextNode, null)
        },
        toBack: function() {
            var a = this.node;
            if (a) {
                this.prevNextNode = a.nextSibling;
                var b = a.parentNode;
                if (b) {
                    var c = b.firstChild;
                    c && b.insertBefore(a, c)
                }
            }
        },
        mouseover: function(a) {
            this.R.addListener(this, "mouseover", a);
            return this
        },
        mouseout: function(a) {
            this.R.addListener(this, "mouseout", a);
            return this
        },
        click: function(a) {
            this.R.addListener(this, "click", a);
            return this
        },
        dblclick: function(a) {
            this.R.addListener(this, "dblclick", a);
            return this
        },
        mousedown: function(a) {
            this.R.addListener(this, "mousedown", a);
            return this
        },
        mouseup: function(a) {
            this.R.addListener(this, "mouseup", a);
            return this
        },
        touchstart: function(a) {
            this.R.addListener(this, "touchstart", a);
            return this
        },
        touchend: function(a) {
            this.R.addListener(this, "touchend", a);
            return this
        },
        contextmenu: function(a) {
            this.node.addEventListener ? this.node.addEventListener("contextmenu", a, !0) : this.R.addListener(this, "contextmenu", a);
            return this
        },
        stop: function() {
            d.removeFromArray(this.R.animations, this.an_x);
            d.removeFromArray(this.R.animations, this.an_y)
        },
        length: function() {
            return this.node.childNodes.length
        },
        gradient: function(a, b, c) {
            this.R.gradient(this, a, b, c)
        },
        pattern: function(a, b, c) {
            a && this.R.pattern(this, a, b, c)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.VMLRenderer = d.Class({
        construct: function(a, b) {
            this.chart = b;
            this.D = a;
            this.cNames = {
                circle: "oval",
                ellipse: "oval",
                rect: "roundrect",
                path: "shape"
            };
            this.styleMap = {
                x: "left",
                y: "top",
                width: "width",
                height: "height",
                "font-family": "fontFamily",
                "font-size": "fontSize",
                visibility: "visibility"
            }
        },
        create: function(a, b) {
            var c;
            if ("group" == b) c = document.createElement("div"), a.type = "div";
            else if ("text" == b) c = document.createElement("div"), a.type = "text";
            else if ("image" == b) c = document.createElement("img"), a.type = "image";
            else {
                a.type = "shape";
                a.shapeType = this.cNames[b];
                c = document.createElement("amvml:" + this.cNames[b]);
                var d = document.createElement("amvml:stroke");
                c.appendChild(d);
                a.stroke = d;
                var h = document.createElement("amvml:fill");
                c.appendChild(h);
                a.fill = h;
                h.className = "amvml";
                d.className = "amvml";
                c.className = "amvml"
            }
            c.style.position = "absolute";
            c.style.top = 0;
            c.style.left = 0;
            return c
        },
        path: function(a, b) {
            a.node.setAttribute("src", b)
        },
        setAttr: function(a, b, c) {
            if (void 0 !== c) {
                var e;
                8 === document.documentMode && (e = !0);
                var h = a.node,
                    f = a.type,
                    g = h.style;
                "r" == b && (g.width = 2 * c, g.height = 2 * c);
                "oval" == a.shapeType && ("rx" == b && (g.width = 2 * c), "ry" == b && (g.height = 2 * c));
                "roundrect" == a.shapeType && ("width" != b && "height" != b || --c);
                "cursor" == b && (g.cursor = c);
                "cx" == b && (g.left = c - d.removePx(g.width) / 2);
                "cy" == b && (g.top = c - d.removePx(g.height) / 2);
                var k = this.styleMap[b];
                void 0 !== k && (g[k] = c);
                "text" == f && ("text-anchor" == b && (a.anchor = c, k = h.clientWidth, "end" == c && (g.marginLeft = -k + "px"), "middle" == c && (g.marginLeft = -(k / 2) + "px", g.textAlign = "center"), "start" == c && (g.marginLeft = "0px")), "fill" == b && (g.color = c), "font-weight" == b && (g.fontWeight = c));
                if (g = a.children)
                    for (k = 0; k < g.length; k++) g[k].setAttr(b, c);
                if ("shape" == f) {
                    "cs" == b && (h.style.width = "100px", h.style.height = "100px", h.setAttribute("coordsize", c));
                    "d" == b && h.setAttribute("path", this.svgPathToVml(c));
                    "dd" == b && h.setAttribute("path", c);
                    f = a.stroke;
                    a = a.fill;
                    "stroke" == b && (e ? f.color = c : f.setAttribute("color", c));
                    "stroke-width" == b && (e ? f.weight = c : f.setAttribute("weight", c));
                    "stroke-opacity" == b && (e ? f.opacity = c : f.setAttribute("opacity", c));
                    "stroke-dasharray" == b && (g = "solid", 0 < c && 3 > c && (g = "dot"), 3 <= c && 6 >= c && (g = "dash"), 6 < c && (g = "longdash"), e ? f.dashstyle = g : f.setAttribute("dashstyle", g));
                    if ("fill-opacity" == b || "opacity" == b) 0 === c ? e ? a.on = !1 : a.setAttribute("on", !1) : e ? a.opacity = c : a.setAttribute("opacity", c);
                    "fill" == b && (e ? a.color = c : a.setAttribute("color", c));
                    "rx" == b && (e ? h.arcSize = c + "%" : h.setAttribute("arcsize", c + "%"))
                }
            }
        },
        attr: function(a, b) {
            for (var c in b) b.hasOwnProperty(c) && this.setAttr(a, c, b[c])
        },
        text: function(a, b, c) {
            var e = new d.AmDObject("text", this.D),
                h = e.node;
            h.style.whiteSpace = "pre";
            h.innerHTML = a;
            this.D.addToContainer(h, c);
            this.attr(e, b);
            return e
        },
        getBBox: function(a) {
            return this.getBox(a.node)
        },
        getBox: function(a) {
            var b = a.offsetLeft,
                c = a.offsetTop,
                d = a.offsetWidth,
                h = a.offsetHeight,
                f;
            if (a.hasChildNodes()) {
                var g, k, l;
                for (l = 0; l < a.childNodes.length; l++) {
                    f = this.getBox(a.childNodes[l]);
                    var m = f.x;
                    isNaN(m) || (isNaN(g) ? g = m : m < g && (g = m));
                    var n = f.y;
                    isNaN(n) || (isNaN(k) ? k = n : n < k && (k = n));
                    m = f.width + m;
                    isNaN(m) || (d = Math.max(d, m));
                    f = f.height + n;
                    isNaN(f) || (h = Math.max(h, f))
                }
                0 > g && (b += g);
                0 > k && (c += k)
            }
            return {
                x: b,
                y: c,
                width: d,
                height: h
            }
        },
        setText: function(a, b) {
            var c = a.node;
            c && (c.innerHTML = b);
            this.setAttr(a, "text-anchor", a.anchor)
        },
        addListener: function(a, b, c) {
            a.node["on" + b] = c
        },
        move: function(a, b, c) {
            var e = a.node,
                h = e.style;
            "text" == a.type && (c -= d.removePx(h.fontSize) / 2 - 1);
            "oval" == a.shapeType && (b -= d.removePx(h.width) / 2, c -= d.removePx(h.height) / 2);
            a = a.bw;
            isNaN(a) || (b -= a, c -= a);
            isNaN(b) || isNaN(c) || (e.style.left = b + "px", e.style.top = c + "px")
        },
        svgPathToVml: function(a) {
            var b = a.split(" ");
            a = "";
            var c, d = Math.round,
                h;
            for (h = 0; h < b.length; h++) {
                var f = b[h],
                    g = f.substring(0, 1),
                    f = f.substring(1),
                    k = f.split(","),
                    l = d(k[0]) + "," + d(k[1]);
                "M" == g && (a += " m " + l);
                "L" == g && (a += " l " + l);
                "Z" == g && (a += " x e");
                if ("Q" == g) {
                    var m = c.length,
                        n = c[m - 1],
                        p = k[0],
                        q = k[1],
                        l = k[2],
                        r = k[3];
                    c = d(c[m - 2] / 3 + 2 / 3 * p);
                    n = d(n / 3 + 2 / 3 * q);
                    p = d(2 / 3 * p + l / 3);
                    q = d(2 / 3 * q + r / 3);
                    a += " c " + c + "," + n + "," + p + "," + q + "," + l + "," + r
                }
                "A" == g && (a += " wa " + f);
                "B" == g && (a += " at " + f);
                c = k
            }
            return a
        },
        animate: function(a, b, c, d, h) {
            var f = a.node,
                g = this.chart;
            if ("translate" == b) {
                b = c.split(",");
                c = b[1];
                var k = f.offsetTop;
                g.animate(a, "left", f.offsetLeft, b[0], d, h, "px");
                g.animate(a, "top", k, c, d, h, "px")
            }
        },
        clipRect: function(a, b, c, d, h) {
            a = a.node;
            0 === b && 0 === c ? (a.style.width = d + "px", a.style.height = h + "px", a.style.overflow = "hidden") : a.style.clip = "rect(" + c + "px " + (b + d) + "px " + (c + h) + "px " + b + "px)"
        },
        rotate: function(a, b, c) {
            if (0 !== Number(b)) {
                var e = a.node;
                a = e.style;
                c || (c = this.getBGColor(e.parentNode));
                a.backgroundColor = c;
                a.paddingLeft = 1;
                c = b * Math.PI / 180;
                var h = Math.cos(c),
                    f = Math.sin(c),
                    g = d.removePx(a.left),
                    k = d.removePx(a.top),
                    l = e.offsetWidth,
                    e = e.offsetHeight;
                b /= Math.abs(b);
                a.left = g + l / 2 - l / 2 * Math.cos(c) - b * e / 2 * Math.sin(c) + 3;
                a.top = k - b * l / 2 * Math.sin(c) + b * e / 2 * Math.sin(c);
                a.cssText = a.cssText + "; filter:progid:DXImageTransform.Microsoft.Matrix(M11='" + h + "', M12='" + -f + "', M21='" + f + "', M22='" + h + "', sizingmethod='auto expand');"
            }
        },
        getBGColor: function(a) {
            var b = "#FFFFFF";
            if (a.style) {
                var c = a.style.backgroundColor;
                "" !== c ? b = c : a.parentNode && (b = this.getBGColor(a.parentNode))
            }
            return b
        },
        set: function(a) {
            var b = new d.AmDObject("group", this.D);
            this.D.container.appendChild(b.node);
            if (a) {
                var c;
                for (c = 0; c < a.length; c++) b.push(a[c])
            }
            return b
        },
        gradient: function(a, b, c, d) {
            var h = "";
            "radialGradient" == b && (b = "gradientradial", c.reverse());
            "linearGradient" == b && (b = "gradient");
            var f;
            for (f = 0; f < c.length; f++) {
                var g = Math.round(100 * f / (c.length - 1)),
                    h = h + (g + "% " + c[f]);
                f < c.length - 1 && (h += ",")
            }
            a = a.fill;
            90 == d ? d = 0 : 270 == d ? d = 180 : 180 == d ? d = 90 : 0 === d && (d = 270);
            8 === document.documentMode ? (a.type = b, a.angle = d) : (a.setAttribute("type", b), a.setAttribute("angle", d));
            h && (a.colors.value = h)
        },
        remove: function(a) {
            a.clipPath && this.D.remove(a.clipPath);
            this.D.remove(a.node)
        },
        disableSelection: function(a) {
            void 0 !== typeof a.onselectstart && (a.onselectstart = function() {
                return !1
            });
            a.style.cursor = "default"
        },
        pattern: function(a, b, c, e) {
            c = a.node;
            a = a.fill;
            var h = "none";
            b.color && (h = b.color);
            c.fillColor = h;
            b = b.url;
            d.isAbsolute(b) || (b = e + b);
            8 === document.documentMode ? (a.type = "tile", a.src = b) : (a.setAttribute("type", "tile"), a.setAttribute("src", b))
        },
        update: function() {}
    })
})();
(function() {
    var d = window.AmCharts;
    d.SVGRenderer = d.Class({
        construct: function(a) {
            this.D = a;
            this.animations = []
        },
        create: function(a, b) {
            return document.createElementNS(d.SVG_NS, b)
        },
        attr: function(a, b) {
            for (var c in b) b.hasOwnProperty(c) && this.setAttr(a, c, b[c])
        },
        setAttr: function(a, b, c) {
            void 0 !== c && a.node.setAttribute(b, c)
        },
        animate: function(a, b, c, e, h) {
            var f = a.node;
            a["an_" + b] && d.removeFromArray(this.animations, a["an_" + b]);
            "translate" == b ? (f = (f = f.getAttribute("transform")) ? String(f).substring(10, f.length - 1) : "0,0", f = f.split(", ").join(" "), f = f.split(" ").join(","), 0 === f && (f = "0,0")) : f = Number(f.getAttribute(b));
            c = {
                obj: a,
                frame: 0,
                attribute: b,
                from: f,
                to: c,
                time: e,
                effect: h
            };
            this.animations.push(c);
            a["an_" + b] = c
        },
        update: function() {
            var a, b = this.animations;
            for (a = b.length - 1; 0 <= a; a--) {
                var c = b[a],
                    e = 1E3 * c.time / d.updateRate,
                    h = c.frame + 1,
                    f = c.obj,
                    g = c.attribute,
                    k, l, m;
                h <= e ? (c.frame++, "translate" == g ? (k = c.from.split(","), g = Number(k[0]), k = Number(k[1]), isNaN(k) && (k = 0), l = c.to.split(","), m = Number(l[0]), l = Number(l[1]), m = 0 === m - g ? m : Math.round(d[c.effect](0, h, g, m - g, e)), c = 0 === l - k ? l : Math.round(d[c.effect](0, h, k, l - k, e)), g = "transform", c = "translate(" + m + "," + c + ")") : (l = Number(c.from), k = Number(c.to), m = k - l, c = d[c.effect](0, h, l, m, e), isNaN(c) && (c = k), 0 === m && this.animations.splice(a, 1)), this.setAttr(f, g, c)) : ("translate" == g ? (l = c.to.split(","), m = Number(l[0]), l = Number(l[1]), f.translate(m, l)) : (k = Number(c.to), this.setAttr(f, g, k)), this.animations.splice(a, 1))
            }
        },
        getBBox: function(a) {
            if (a = a.node) try {
                return a.getBBox()
            } catch (b) {}
            return {
                width: 0,
                height: 0,
                x: 0,
                y: 0
            }
        },
        path: function(a, b) {
            a.node.setAttributeNS(d.SVG_XLINK, "xlink:href", b)
        },
        clipRect: function(a, b, c, e, h) {
            var f = a.node,
                g = a.clipPath;
            g && this.D.remove(g);
            var k = f.parentNode;
            k && (f = document.createElementNS(d.SVG_NS, "clipPath"), g = d.getUniqueId(), f.setAttribute("id", g), this.D.rect(b, c, e, h, 0, 0, f), k.appendChild(f), b = "#", d.baseHref && !d.isIE && (b = this.removeTarget(window.location.href) + b), this.setAttr(a, "clip-path", "url(" + b + g + ")"), this.clipPathC++, a.clipPath = f)
        },
        text: function(a, b, c) {
            var e = new d.AmDObject("text", this.D);
            a = String(a).split("\n");
            var h = d.removePx(b["font-size"]),
                f;
            for (f = 0; f < a.length; f++) {
                var g = this.create(null, "tspan");
                g.appendChild(document.createTextNode(a[f]));
                g.setAttribute("y", (h + 2) * f + Math.round(h / 2));
                g.setAttribute("x", 0);
                e.node.appendChild(g)
            }
            e.node.setAttribute("y", Math.round(h / 2));
            this.attr(e, b);
            this.D.addToContainer(e.node, c);
            return e
        },
        setText: function(a, b) {
            var c = a.node;
            c && (c.removeChild(c.firstChild), c.appendChild(document.createTextNode(b)))
        },
        move: function(a, b, c, d) {
            isNaN(b) && (b = 0);
            isNaN(c) && (c = 0);
            b = "translate(" +
                b + "," + c + ")";
            d && (b = b + " scale(" + d + ")");
            this.setAttr(a, "transform", b)
        },
        rotate: function(a, b) {
            var c = a.node.getAttribute("transform"),
                d = "rotate(" + b + ")";
            c && (d = c + " " + d);
            this.setAttr(a, "transform", d)
        },
        set: function(a) {
            var b = new d.AmDObject("g", this.D);
            this.D.container.appendChild(b.node);
            if (a) {
                var c;
                for (c = 0; c < a.length; c++) b.push(a[c])
            }
            return b
        },
        addListener: function(a, b, c) {
            a.node["on" + b] = c
        },
        gradient: function(a, b, c, e) {
            var h = a.node,
                f = a.grad;
            f && this.D.remove(f);
            b = document.createElementNS(d.SVG_NS, b);
            f = d.getUniqueId();
            b.setAttribute("id", f);
            if (!isNaN(e)) {
                var g = 0,
                    k = 0,
                    l = 0,
                    m = 0;
                90 == e ? l = 100 : 270 == e ? m = 100 : 180 == e ? g = 100 : 0 === e && (k = 100);
                b.setAttribute("x1", g + "%");
                b.setAttribute("x2", k + "%");
                b.setAttribute("y1", l + "%");
                b.setAttribute("y2", m + "%")
            }
            for (e = 0; e < c.length; e++) g = document.createElementNS(d.SVG_NS, "stop"), k = 100 * e / (c.length - 1), 0 === e && (k = 0), g.setAttribute("offset", k + "%"), g.setAttribute("stop-color", c[e]), b.appendChild(g);
            h.parentNode.appendChild(b);
            c = "#";
            d.baseHref && !d.isIE && (c = this.removeTarget(window.location.href) + c);
            h.setAttribute("fill", "url(" + c + f + ")");
            a.grad = b
        },
        removeTarget: function(a) {
            return a.split("#")[0]
        },
        pattern: function(a, b, c, e) {
            var h = a.node;
            isNaN(c) && (c = 1);
            var f = a.patternNode;
            f && this.D.remove(f);
            var f = document.createElementNS(d.SVG_NS, "pattern"),
                g = d.getUniqueId(),
                k = b;
            b.url && (k = b.url);
            d.isAbsolute(k) || (k = e + k);
            e = Number(b.width);
            isNaN(e) && (e = 4);
            var l = Number(b.height);
            isNaN(l) && (l = 4);
            e /= c;
            l /= c;
            c = b.x;
            isNaN(c) && (c = 0);
            var m = -Math.random() * Number(b.randomX);
            isNaN(m) || (c = m);
            m = b.y;
            isNaN(m) && (m = 0);
            var n = -Math.random() * Number(b.randomY);
            isNaN(n) || (m = n);
            f.setAttribute("id", g);
            f.setAttribute("width", e);
            f.setAttribute("height", l);
            f.setAttribute("patternUnits", "userSpaceOnUse");
            f.setAttribute("xlink:href", k);
            b.color && (n = document.createElementNS(d.SVG_NS, "rect"), n.setAttributeNS(null, "height", e), n.setAttributeNS(null, "width", l), n.setAttributeNS(null, "fill", b.color), f.appendChild(n));
            this.D.image(k, 0, 0, e, l, f).translate(c, m);
            k = "#";
            d.baseHref && !d.isIE && (k = this.removeTarget(window.location.href) + k);
            h.setAttribute("fill", "url(" + k + g + ")");
            a.patternNode = f;
            h.parentNode.appendChild(f)
        },
        remove: function(a) {
            a.clipPath && this.D.remove(a.clipPath);
            a.grad && this.D.remove(a.grad);
            a.patternNode && this.D.remove(a.patternNode);
            this.D.remove(a.node)
        }
    })
})();
AmCharts.AmDSet = AmCharts.Class({
    construct: function(d) {
        this.create("g")
    },
    attr: function(d) {
        this.R.attr(this.node, d)
    },
    move: function(d, a) {
        this.R.move(this.node, d, a)
    }
});
(function() {
    var d = window.AmCharts;
    d.AmLegend = d.Class({
        construct: function(a) {
            this.enabled = !0;
            this.cname = "AmLegend";
            this.createEvents("rollOverMarker", "rollOverItem", "rollOutMarker", "rollOutItem", "showItem", "hideItem", "clickMarker", "rollOverItem", "rollOutItem", "clickLabel");
            this.position = "bottom";
            this.borderColor = this.color = "#000000";
            this.borderAlpha = 0;
            this.markerLabelGap = 5;
            this.verticalGap = 10;
            this.align = "left";
            this.horizontalGap = 0;
            this.spacing = 10;
            this.markerDisabledColor = "#AAB3B3";
            this.markerType = "square";
            this.markerSize = 16;
            this.markerBorderThickness = this.markerBorderAlpha = 1;
            this.marginBottom = this.marginTop = 0;
            this.marginLeft = this.marginRight = 20;
            this.autoMargins = !0;
            this.valueWidth = 50;
            this.switchable = !0;
            this.switchType = "x";
            this.switchColor = "#FFFFFF";
            this.rollOverColor = "#CC0000";
            this.reversedOrder = !1;
            this.labelText = "[[title]]";
            this.valueText = "[[value]]";
            this.useMarkerColorForLabels = !1;
            this.rollOverGraphAlpha = 1;
            this.textClickEnabled = !1;
            this.equalWidths = !0;
            this.backgroundColor = "#FFFFFF";
            this.backgroundAlpha = 0;
            this.useGraphSettings = !1;
            this.showEntries = !0;
            d.applyTheme(this, a, this.cname)
        },
        setData: function(a) {
            this.legendData = a;
            this.invalidateSize()
        },
        invalidateSize: function() {
            this.destroy();
            this.entries = [];
            this.valueLabels = [];
            var a = this.legendData;
            this.enabled && (d.ifArray(a) || d.ifArray(this.data)) && this.drawLegend()
        },
        drawLegend: function() {
            var a = this.chart,
                b = this.position,
                c = this.width,
                e = a.divRealWidth,
                h = a.divRealHeight,
                f = this.div,
                g = this.legendData;
            this.data && (g = this.data);
            isNaN(this.fontSize) && (this.fontSize = a.fontSize);
            if ("right" == b || "left" == b) this.maxColumns = 1, this.autoMargins && (this.marginLeft = this.marginRight = 10);
            else if (this.autoMargins) {
                this.marginRight = a.marginRight;
                this.marginLeft = a.marginLeft;
                var k = a.autoMarginOffset;
                "bottom" == b ? (this.marginBottom = k, this.marginTop = 0) : (this.marginTop = k, this.marginBottom = 0)
            }
            c = void 0 !== c ? d.toCoordinate(c, e) : "right" != b && "left" != b ? a.realWidth : 0 < this.ieW ? this.ieW : a.realWidth;
            "outside" == b ? (c = f.offsetWidth, h = f.offsetHeight, f.clientHeight && (c = f.clientWidth, h = f.clientHeight)) : (isNaN(c) || (f.style.width = c + "px"), f.className = "amChartsLegend " + a.classNamePrefix + "-legend-div");
            this.divWidth = c;
            (b = this.container) ? (b.container.innerHTML = "", f.appendChild(b.container), b.width = c, b.height = h, b.setSize(c, h), b.addDefs(a)) : b = new d.AmDraw(f, c, h, a);
            this.container = b;
            this.lx = 0;
            this.ly = 8;
            h = this.markerSize;
            h > this.fontSize && (this.ly = h / 2 - 1);
            0 < h && (this.lx += h + this.markerLabelGap);
            this.titleWidth = 0;
            if (h = this.title) h = d.text(this.container, h, this.color, a.fontFamily, this.fontSize, "start", !0), d.setCN(a, h, "legend-title"), h.translate(this.marginLeft, this.marginTop + this.verticalGap + this.ly + 1), a = h.getBBox(), this.titleWidth = a.width + 15, this.titleHeight = a.height + 6;
            this.index = this.maxLabelWidth = 0;
            if (this.showEntries) {
                for (a = 0; a < g.length; a++) this.createEntry(g[a]);
                for (a = this.index = 0; a < g.length; a++) this.createValue(g[a])
            }
            this.arrangeEntries();
            this.updateValues()
        },
        arrangeEntries: function() {
            var a = this.position,
                b = this.marginLeft + this.titleWidth,
                c = this.marginRight,
                e = this.marginTop,
                h = this.marginBottom,
                f = this.horizontalGap,
                g = this.div,
                k = this.divWidth,
                l = this.maxColumns,
                m = this.verticalGap,
                n = this.spacing,
                p = k - c - b,
                q = 0,
                r = 0,
                u = this.container;
            this.set && this.set.remove();
            var t = u.set();
            this.set = t;
            var z = u.set();
            t.push(z);
            var y = this.entries,
                v, w;
            for (w = 0; w < y.length; w++) {
                v = y[w].getBBox();
                var A = v.width;
                A > q && (q = A);
                v = v.height;
                v > r && (r = v)
            }
            var A = r = 0,
                B = f,
                C = 0,
                D = 0;
            for (w = 0; w < y.length; w++) {
                var J = y[w];
                this.reversedOrder && (J = y[y.length - w - 1]);
                v = J.getBBox();
                var E;
                this.equalWidths ? E = A * (q + n + this.markerLabelGap) : (E = B, B = B + v.width + f + n);
                v.height > D && (D = v.height);
                E + v.width > p && 0 < w && 0 !== A && (r++, E = A = 0, B = E + v.width + f + n, C = C + D + m, D = 0);
                J.translate(E, C);
                A++;
                !isNaN(l) && A >= l && (A = 0, r++, C = C + D + m, B = f, D = 0);
                z.push(J)
            }
            v = z.getBBox();
            l = v.height + 2 * m - 1;
            "left" == a || "right" == a ? (n = v.width + 2 * f, k = n + b + c, g.style.width = k + "px", this.ieW = k) : n = k - b - c - 1;
            c = d.polygon(this.container, [0, n, n, 0], [0, 0, l, l], this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
            d.setCN(this.chart, c, "legend-bg");
            t.push(c);
            t.translate(b, e);
            c.toBack();
            b = f;
            if ("top" == a || "bottom" == a || "absolute" == a || "outside" == a) "center" == this.align ? b = f + (n - v.width) / 2 : "right" == this.align && (b = f + n - v.width);
            z.translate(b, m + 1);
            this.titleHeight > l && (l = this.titleHeight);
            a = l + e + h + 1;
            0 > a && (a = 0);
            a > this.chart.divRealHeight && (g.style.top = "0px");
            g.style.height = Math.round(a) + "px";
            u.setSize(this.divWidth, a)
        },
        createEntry: function(a) {
            if (!1 !== a.visibleInLegend) {
                var b = this.chart,
                    c = a.markerType;
                a.legendEntryWidth = this.markerSize;
                c || (c = this.markerType);
                var e = a.color,
                    h = a.alpha;
                a.legendKeyColor && (e = a.legendKeyColor());
                a.legendKeyAlpha && (h = a.legendKeyAlpha());
                var f;
                !0 === a.hidden && (f = e = this.markerDisabledColor);
                var g = a.pattern,
                    k = a.customMarker;
                k || (k = this.customMarker);
                var l = this.container,
                    m = this.markerSize,
                    n = 0,
                    p = 0,
                    q = m / 2;
                if (this.useGraphSettings) {
                    c = a.type;
                    this.switchType = void 0;
                    if ("line" == c || "step" == c || "smoothedLine" == c || "ohlc" == c) g = l.set(), a.hidden || (e = a.lineColorR, f = a.bulletBorderColorR), n = d.line(l, [0, 2 * m], [m / 2, m / 2], e, a.lineAlpha, a.lineThickness, a.dashLength), d.setCN(b, n, "graph-stroke"), g.push(n), a.bullet && (a.hidden || (e = a.bulletColorR), n = d.bullet(l, a.bullet, a.bulletSize, e, a.bulletAlpha, a.bulletBorderThickness, f, a.bulletBorderAlpha)) && (d.setCN(b, n, "graph-bullet"), n.translate(m + 1, m / 2), g.push(n)), q = 0, n = m, p = m / 3;
                    else {
                        var r;
                        a.getGradRotation && (r = a.getGradRotation());
                        n = a.fillColorsR;
                        !0 === a.hidden && (n = e);
                        if (g = this.createMarker("rectangle", n, a.fillAlphas, a.lineThickness, e, a.lineAlpha, r, g)) q = m, g.translate(q, m / 2);
                        n = m
                    }
                    d.setCN(b, g, "graph-" + c);
                    d.setCN(b, g, "graph-" + a.id)
                } else k ? g = l.image(k, 0, 0, m, m) : (g = this.createMarker(c, e, h, void 0, void 0, void 0, void 0, g)) && g.translate(m / 2, m / 2);
                d.setCN(b, g, "legend-marker");
                this.addListeners(g, a);
                l = l.set([g]);
                this.switchable && a.switchable && l.setAttr("cursor", "pointer");
                void 0 !== a.id && d.setCN(b, l, "legend-item-" + a.id);
                d.setCN(b, l, a.className, !0);
                (f = this.switchType) && "none" != f && 0 < m && ("x" == f ? (c = this.createX(), c.translate(m / 2, m / 2)) : c = this.createV(), c.dItem = a, !0 !== a.hidden ? "x" == f ? c.hide() : c.show() : "x" != f && c.hide(), this.switchable || c.hide(), this.addListeners(c, a), a.legendSwitch = c, l.push(c), d.setCN(b, c, "legend-switch"));
                f = this.color;
                a.showBalloon && this.textClickEnabled && void 0 !== this.selectedColor && (f = this.selectedColor);
                this.useMarkerColorForLabels && (f = e);
                !0 === a.hidden && (f = this.markerDisabledColor);
                e = d.massReplace(this.labelText, {
                    "[[title]]": a.title
                });
                c = this.fontSize;
                g && (m <= c && g.translate(q, m / 2 + this.ly - c / 2 + (c + 2 - m) / 2 - p), a.legendEntryWidth = g.getBBox().width);
                var u;
                e && (e = d.fixBrakes(e), a.legendTextReal = e, u = this.labelWidth, u = isNaN(u) ? d.text(this.container, e, f, b.fontFamily, c, "start") : d.wrappedText(this.container, e, f, b.fontFamily, c, "start", !1, u, 0), d.setCN(b, u, "legend-label"), u.translate(this.lx + n, this.ly), l.push(u), b = u.getBBox().width, this.maxLabelWidth < b && (this.maxLabelWidth = b));
                this.entries[this.index] = l;
                a.legendEntry = this.entries[this.index];
                a.legendLabel = u;
                this.index++
            }
        },
        addListeners: function(a, b) {
            var c = this;
            a && a.mouseover(function(a) {
                c.rollOverMarker(b, a)
            }).mouseout(function(a) {
                c.rollOutMarker(b, a)
            }).click(function(a) {
                c.clickMarker(b, a)
            })
        },
        rollOverMarker: function(a, b) {
            this.switchable && this.dispatch("rollOverMarker", a, b);
            this.dispatch("rollOverItem", a, b)
        },
        rollOutMarker: function(a, b) {
            this.switchable && this.dispatch("rollOutMarker", a, b);
            this.dispatch("rollOutItem", a, b)
        },
        clickMarker: function(a, b) {
            this.switchable && (!0 === a.hidden ? this.dispatch("showItem", a, b) : this.dispatch("hideItem", a, b));
            this.dispatch("clickMarker", a, b)
        },
        rollOverLabel: function(a, b) {
            a.hidden || (this.textClickEnabled && a.legendLabel && a.legendLabel.attr({
                fill: this.rollOverColor
            }), this.dispatch("rollOverItem", a, b))
        },
        rollOutLabel: function(a, b) {
            if (!a.hidden) {
                if (this.textClickEnabled && a.legendLabel) {
                    var c = this.color;
                    void 0 !== this.selectedColor && a.showBalloon && (c = this.selectedColor);
                    this.useMarkerColorForLabels && (c = a.lineColor, void 0 === c && (c = a.color));
                    a.legendLabel.attr({
                        fill: c
                    })
                }
                this.dispatch("rollOutItem", a, b)
            }
        },
        clickLabel: function(a, b) {
            this.textClickEnabled ? a.hidden || this.dispatch("clickLabel", a, b) : this.switchable && (!0 === a.hidden ? this.dispatch("showItem", a, b) : this.dispatch("hideItem", a, b))
        },
        dispatch: function(a, b, c) {
            b = {
                type: a,
                dataItem: b,
                target: this,
                event: c,
                chart: this.chart
            };
            this.chart && this.chart.handleLegendEvent(b);
            this.fire(a, b)
        },
        createValue: function(a) {
            var b = this,
                c = b.fontSize,
                e = b.chart;
            if (!1 !== a.visibleInLegend) {
                var h = b.maxLabelWidth;
                b.forceWidth && (h = b.labelWidth);
                b.equalWidths || (b.valueAlign = "left");
                "left" == b.valueAlign && (h = a.legendEntry.getBBox().width);
                var f = h;
                if (b.valueText && 0 < b.valueWidth) {
                    var g = b.color;
                    b.useMarkerColorForValues && (g = a.color, a.legendKeyColor && (g = a.legendKeyColor()));
                    !0 === a.hidden && (g = b.markerDisabledColor);
                    var k = b.valueText,
                        h = h + b.lx + b.markerLabelGap + b.valueWidth,
                        l = "end";
                    "left" == b.valueAlign && (h -= b.valueWidth, l = "start");
                    g = d.text(b.container, k, g, b.chart.fontFamily, c, l);
                    d.setCN(e, g, "legend-value");
                    g.translate(h, b.ly);
                    b.entries[b.index].push(g);
                    f += b.valueWidth + 2 * b.markerLabelGap;
                    g.dItem = a;
                    b.valueLabels.push(g)
                }
                b.index++;
                e = b.markerSize;
                e < c + 7 && (e = c + 7, d.VML && (e += 3));
                c = b.container.rect(a.legendEntryWidth, 0, f, e, 0, 0).attr({
                    stroke: "none",
                    fill: "#fff",
                    "fill-opacity": .005
                });
                c.dItem = a;
                b.entries[b.index - 1].push(c);
                c.mouseover(function(c) {
                    b.rollOverLabel(a, c)
                }).mouseout(function(c) {
                    b.rollOutLabel(a, c)
                }).click(function(c) {
                    b.clickLabel(a, c)
                })
            }
        },
        createV: function() {
            var a = this.markerSize;
            return d.polygon(this.container, [a / 5, a / 2, a - a / 5, a / 2], [a / 3, a - a / 5, a / 5, a / 1.7], this.switchColor)
        },
        createX: function() {
            var a = (this.markerSize - 4) / 2,
                b = {
                    stroke: this.switchColor,
                    "stroke-width": 3
                },
                c = this.container,
                e = d.line(c, [-a, a], [-a, a]).attr(b),
                a = d.line(c, [-a, a], [a, -a]).attr(b);
            return this.container.set([e, a])
        },
        createMarker: function(a, b, c, e, h, f, g, k) {
            var l = this.markerSize,
                m = this.container;
            h || (h = this.markerBorderColor);
            h || (h = b);
            isNaN(e) && (e = this.markerBorderThickness);
            isNaN(f) && (f = this.markerBorderAlpha);
            return d.bullet(m, a, l, b, c, e, h, f, l, g, k, this.chart.path)
        },
        validateNow: function() {
            this.invalidateSize()
        },
        updateValues: function() {
            var a = this.valueLabels,
                b = this.chart,
                c, e = this.data;
            for (c = 0; c < a.length; c++) {
                var h = a[c],
                    f = h.dItem,
                    g = " ";
                if (e) f.value ? h.text(f.value) : h.text("");
                else {
                    var k;
                    if (void 0 !== f.type) {
                        k = f.currentDataItem;
                        var l = this.periodValueText;
                        f.legendPeriodValueText && (l = f.legendPeriodValueText);
                        k ? (g = this.valueText, f.legendValueText && (g = f.legendValueText), g = b.formatString(g, k)) : l && b.formatPeriodString && (l = d.massReplace(l, {
                            "[[title]]": f.title
                        }), g = b.formatPeriodString(l, f))
                    } else g = b.formatString(this.valueText, f);
                    if (l = this.valueFunction) k && (f = k), g = l(f, g);
                    h.text(g)
                }
            }
        },
        renderFix: function() {
            if (!d.VML) {
                var a = this.container;
                a && a.renderFix()
            }
        },
        destroy: function() {
            this.div.innerHTML = "";
            d.remove(this.set)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.formatMilliseconds = function(a, b) {
        if (-1 != a.indexOf("fff")) {
            var c = b.getMilliseconds(),
                d = String(c);
            10 > c && (d = "00" + c);
            10 <= c && 100 > c && (d = "0" + c);
            a = a.replace(/fff/g, d)
        }
        return a
    };
    d.extractPeriod = function(a) {
        var b = d.stripNumbers(a),
            c = 1;
        b != a && (c = Number(a.slice(0, a.indexOf(b))));
        return {
            period: b,
            count: c
        }
    };
    d.getDate = function(a, b, c) {
        return a instanceof Date ? d.newDate(a, c) : b && isNaN(a) ? d.stringToDate(a, b) : new Date(a)
    };
    d.newDate = function(a, b) {
        return b && -1 == b.indexOf("fff") ? new Date(a) : d.useUTC ? new Date(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate(), a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds(), a.getUTCMilliseconds()) : new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes(), a.getSeconds(), a.getMilliseconds())
    };
    d.resetDateToMin = function(a, b, c, e) {
        void 0 === e && (e = 1);
        var h, f, g, k, l, m, n;
        d.useUTC ? (h = a.getUTCFullYear(), f = a.getUTCMonth(), g = a.getUTCDate(), k = a.getUTCHours(), l = a.getUTCMinutes(), m = a.getUTCSeconds(), n = a.getUTCMilliseconds(), a = a.getUTCDay()) : (h = a.getFullYear(), f = a.getMonth(), g = a.getDate(), k = a.getHours(), l = a.getMinutes(), m = a.getSeconds(), n = a.getMilliseconds(), a = a.getDay());
        switch (b) {
            case "YYYY":
                h = Math.floor(h / c) * c;
                f = 0;
                g = 1;
                n = m = l = k = 0;
                break;
            case "MM":
                f = Math.floor(f / c) * c;
                g = 1;
                n = m = l = k = 0;
                break;
            case "WW":
                g = a >= e ? g - a + e : g - (7 + a) + e;
                n = m = l = k = 0;
                break;
            case "DD":
                n = m = l = k = 0;
                break;
            case "hh":
                k = Math.floor(k / c) * c;
                n = m = l = 0;
                break;
            case "mm":
                l = Math.floor(l / c) * c;
                n = m = 0;
                break;
            case "ss":
                m = Math.floor(m / c) * c;
                n = 0;
                break;
            case "fff":
                n = Math.floor(n / c) * c
        }
        d.useUTC ? (a = new Date, a.setUTCFullYear(h, f, g), a.setUTCHours(k, l, m, n)) : a = new Date(h, f, g, k, l, m, n);
        return a
    };
    d.getPeriodDuration = function(a, b) {
        void 0 === b && (b = 1);
        var c;
        switch (a) {
            case "YYYY":
                c = 316224E5;
                break;
            case "MM":
                c = 26784E5;
                break;
            case "WW":
                c = 6048E5;
                break;
            case "DD":
                c = 864E5;
                break;
            case "hh":
                c = 36E5;
                break;
            case "mm":
                c = 6E4;
                break;
            case "ss":
                c = 1E3;
                break;
            case "fff":
                c = 1
        }
        return c * b
    };
    d.intervals = {
        s: {
            nextInterval: "ss",
            contains: 1E3
        },
        ss: {
            nextInterval: "mm",
            contains: 60,
            count: 0
        },
        mm: {
            nextInterval: "hh",
            contains: 60,
            count: 1
        },
        hh: {
            nextInterval: "DD",
            contains: 24,
            count: 2
        },
        DD: {
            nextInterval: "",
            contains: Infinity,
            count: 3
        }
    };
    d.getMaxInterval = function(a, b) {
        var c = d.intervals;
        return a >= c[b].contains ? (a = Math.round(a / c[b].contains), b = c[b].nextInterval, d.getMaxInterval(a, b)) : "ss" == b ? c[b].nextInterval : b
    };
    d.dayNames = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ");
    d.shortDayNames = "Sun Mon Tue Wed Thu Fri Sat".split(" ");
    d.monthNames = "January February March April May June July August September October November December".split(" ");
    d.shortMonthNames = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ");
    d.getWeekNumber = function(a) {
        a = new Date(a);
        a.setHours(0, 0, 0);
        a.setDate(a.getDate() + 4 - (a.getDay() || 7));
        var b = new Date(a.getFullYear(), 0, 1);
        return Math.ceil(((a - b) / 864E5 + 1) / 7)
    };
    d.stringToDate = function(a, b) {
        var c = {},
            e = [{
                pattern: "YYYY",
                period: "year"
            }, {
                pattern: "YY",
                period: "year"
            }, {
                pattern: "MM",
                period: "month"
            }, {
                pattern: "M",
                period: "month"
            }, {
                pattern: "DD",
                period: "date"
            }, {
                pattern: "D",
                period: "date"
            }, {
                pattern: "JJ",
                period: "hours"
            }, {
                pattern: "J",
                period: "hours"
            }, {
                pattern: "HH",
                period: "hours"
            }, {
                pattern: "H",
                period: "hours"
            }, {
                pattern: "KK",
                period: "hours"
            }, {
                pattern: "K",
                period: "hours"
            }, {
                pattern: "LL",
                period: "hours"
            }, {
                pattern: "L",
                period: "hours"
            }, {
                pattern: "NN",
                period: "minutes"
            }, {
                pattern: "N",
                period: "minutes"
            }, {
                pattern: "SS",
                period: "seconds"
            }, {
                pattern: "S",
                period: "seconds"
            }, {
                pattern: "QQQ",
                period: "milliseconds"
            }, {
                pattern: "QQ",
                period: "milliseconds"
            }, {
                pattern: "Q",
                period: "milliseconds"
            }],
            h = !0,
            f = b.indexOf("AA"); - 1 != f && (a.substr(f, 2), "pm" == a.toLowerCase && (h = !1));
        var f = b,
            g, k, l;
        for (l = 0; l < e.length; l++) k = e[l].period, c[k] = 0, "date" == k && (c[k] = 1);
        for (l = 0; l < e.length; l++)
            if (g = e[l].pattern, k = e[l].period, -1 != b.indexOf(g)) {
                var m = d.getFromDateString(g, a, f);
                b = b.replace(g, "");
                if ("KK" == g || "K" == g || "LL" == g || "L" == g) h || (m += 12);
                c[k] = m
            }
        d.useUTC ? (e = new Date, e.setUTCFullYear(c.year, c.month, c.date), e.setUTCHours(c.hours, c.minutes, c.seconds, c.milliseconds)) : e = new Date(c.year, c.month, c.date, c.hours, c.minutes, c.seconds, c.milliseconds);
        return e
    };
    d.getFromDateString = function(a, b, c) {
        if (void 0 !== b) return c = c.indexOf(a), b = String(b), b = b.substr(c, a.length), "0" == b.charAt(0) && (b = b.substr(1, b.length - 1)), b = Number(b), isNaN(b) && (b = 0), -1 != a.indexOf("M") && b--, b
    };
    d.formatDate = function(a, b, c) {
        c || (c = d);
        var e, h, f, g, k, l, m, n = d.getWeekNumber(a);
        d.useUTC ? (e = a.getUTCFullYear(), h = a.getUTCMonth(), f = a.getUTCDate(), g = a.getUTCDay(), k = a.getUTCHours(), l = a.getUTCMinutes(), m = a.getUTCSeconds(), a = a.getUTCMilliseconds()) : (e = a.getFullYear(), h = a.getMonth(), f = a.getDate(), g = a.getDay(), k = a.getHours(), l = a.getMinutes(), m = a.getSeconds(), a = a.getMilliseconds());
        var p = String(e).substr(2, 2),
            q = h + 1;
        9 > h && (q = "0" +
            q);
        var r = "0" + g;
        b = b.replace(/W/g, n);
        n = k;
        24 == n && (n = 0);
        var u = n;
        10 > u && (u = "0" + u);
        b = b.replace(/JJ/g, u);
        b = b.replace(/J/g, n);
        u = k;
        0 === u && (u = 24, -1 != b.indexOf("H") && f--);
        n = f;
        10 > f && (n = "0" + f);
        var t = u;
        10 > t && (t = "0" + t);
        b = b.replace(/HH/g, t);
        b = b.replace(/H/g, u);
        u = k;
        11 < u && (u -= 12);
        t = u;
        10 > t && (t = "0" + t);
        b = b.replace(/KK/g, t);
        b = b.replace(/K/g, u);
        u = k;
        0 === u && (u = 12);
        12 < u && (u -= 12);
        t = u;
        10 > t && (t = "0" + t);
        b = b.replace(/LL/g, t);
        b = b.replace(/L/g, u);
        u = l;
        10 > u && (u = "0" + u);
        b = b.replace(/NN/g, u);
        b = b.replace(/N/g, l);
        l = m;
        10 > l && (l = "0" + l);
        b = b.replace(/SS/g, l);
        b = b.replace(/S/g, m);
        m = a;
        10 > m && (m = "00" + m);
        100 > m && (m = "0" + m);
        l = a;
        10 > l && (l = "00" + l);
        b = b.replace(/QQQ/g, m);
        b = b.replace(/QQ/g, l);
        b = b.replace(/Q/g, a);
        b = 12 > k ? b.replace(/A/g, "am") : b.replace(/A/g, "pm");
        b = b.replace(/YYYY/g, "@IIII@");
        b = b.replace(/YY/g, "@II@");
        b = b.replace(/MMMM/g, "@XXXX@");
        b = b.replace(/MMM/g, "@XXX@");
        b = b.replace(/MM/g, "@XX@");
        b = b.replace(/M/g, "@X@");
        b = b.replace(/DD/g, "@RR@");
        b = b.replace(/D/g, "@R@");
        b = b.replace(/EEEE/g, "@PPPP@");
        b = b.replace(/EEE/g, "@PPP@");
        b = b.replace(/EE/g, "@PP@");
        b = b.replace(/E/g, "@P@");
        b = b.replace(/@IIII@/g, e);
        b = b.replace(/@II@/g, p);
        b = b.replace(/@XXXX@/g, c.monthNames[h]);
        b = b.replace(/@XXX@/g, c.shortMonthNames[h]);
        b = b.replace(/@XX@/g, q);
        b = b.replace(/@X@/g, h + 1);
        b = b.replace(/@RR@/g, n);
        b = b.replace(/@R@/g, f);
        b = b.replace(/@PPPP@/g, c.dayNames[g]);
        b = b.replace(/@PPP@/g, c.shortDayNames[g]);
        b = b.replace(/@PP@/g, r);
        return b = b.replace(/@P@/g, g)
    };
    d.changeDate = function(a, b, c, e, h) {
        if (d.useUTC) return d.changeUTCDate(a, b, c, e, h);
        var f = -1;
        void 0 === e && (e = !0);
        void 0 === h && (h = !1);
        !0 === e && (f = 1);
        switch (b) {
            case "YYYY":
                a.setFullYear(a.getFullYear() +
                    c * f);
                e || h || a.setDate(a.getDate() + 1);
                break;
            case "MM":
                b = a.getMonth();
                a.setMonth(a.getMonth() + c * f);
                a.getMonth() > b + c * f && a.setDate(a.getDate() - 1);
                e || h || a.setDate(a.getDate() + 1);
                break;
            case "DD":
                a.setDate(a.getDate() + c * f);
                break;
            case "WW":
                a.setDate(a.getDate() + c * f * 7);
                break;
            case "hh":
                a.setHours(a.getHours() + c * f);
                break;
            case "mm":
                a.setMinutes(a.getMinutes() + c * f);
                break;
            case "ss":
                a.setSeconds(a.getSeconds() + c * f);
                break;
            case "fff":
                a.setMilliseconds(a.getMilliseconds() + c * f)
        }
        return a
    };
    d.changeUTCDate = function(a, b, c, d, h) {
        var f = -1;
        void 0 === d && (d = !0);
        void 0 === h && (h = !1);
        !0 === d && (f = 1);
        switch (b) {
            case "YYYY":
                a.setUTCFullYear(a.getUTCFullYear() + c * f);
                d || h || a.setUTCDate(a.getUTCDate() + 1);
                break;
            case "MM":
                b = a.getUTCMonth();
                a.setUTCMonth(a.getUTCMonth() + c * f);
                a.getUTCMonth() > b + c * f && a.setUTCDate(a.getUTCDate() - 1);
                d || h || a.setUTCDate(a.getUTCDate() + 1);
                break;
            case "DD":
                a.setUTCDate(a.getUTCDate() + c * f);
                break;
            case "WW":
                a.setUTCDate(a.getUTCDate() + c * f * 7);
                break;
            case "hh":
                a.setUTCHours(a.getUTCHours() + c * f);
                break;
            case "mm":
                a.setUTCMinutes(a.getUTCMinutes() +
                    c * f);
                break;
            case "ss":
                a.setUTCSeconds(a.getUTCSeconds() + c * f);
                break;
            case "fff":
                a.setUTCMilliseconds(a.getUTCMilliseconds() + c * f)
        }
        return a
    }
})();;;;
(function() {
    var e = window.AmCharts;
    e.AmSerialChart = e.Class({
        inherits: e.AmRectangularChart,
        construct: function(a) {
            this.type = "serial";
            e.AmSerialChart.base.construct.call(this, a);
            this.cname = "AmSerialChart";
            this.theme = a;
            this.createEvents("changed");
            this.columnSpacing = 5;
            this.columnSpacing3D = 0;
            this.columnWidth = .8;
            this.updateScrollbar = !0;
            var b = new e.CategoryAxis(a);
            b.chart = this;
            this.categoryAxis = b;
            this.zoomOutOnDataUpdate = !0;
            this.mouseWheelZoomEnabled = this.mouseWheelScrollEnabled = this.rotate = this.skipZoom = !1;
            this.minSelectedTime = 0;
            e.applyTheme(this, a, this.cname)
        },
        initChart: function() {
            e.AmSerialChart.base.initChart.call(this);
            this.updateCategoryAxis(this.categoryAxis, this.rotate, "categoryAxis");
            this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);
            var a = this.chartCursor;
            a && a.updateData && (a.updateData(), a.fullWidth && (a.fullRectSet = this.cursorLineSet));
            var a = this.countColumns(),
                b = this.graphs,
                c;
            for (c = 0; c < b.length; c++) b[c].columnCount = a;
            this.updateScrollbar = !0;
            this.drawChart();
            this.autoMargins && !this.marginsUpdated && (this.marginsUpdated = !0, this.measureMargins())
        },
        handleWheelReal: function(a, b) {
            if (!this.wheelBusy) {
                var c = this.categoryAxis,
                    d = c.parseDates,
                    g = c.minDuration(),
                    e = c = 1;
                this.mouseWheelZoomEnabled ? b || (c = -1) : b && (c = -1);
                var f = this.chartData.length,
                    k = this.lastTime,
                    m = this.firstTime;
                0 > a ? d ? (f = this.endTime - this.startTime, d = this.startTime + c * g, g = this.endTime + e * g, 0 < e && 0 < c && g >= k && (g = k, d = k - f), this.zoomToDates(new Date(d), new Date(g))) : (0 < e && 0 < c && this.end >= f - 1 && (c = e = 0), d = this.start +
                    c, g = this.end + e, this.zoomToIndexes(d, g)) : d ? (f = this.endTime - this.startTime, d = this.startTime - c * g, g = this.endTime - e * g, 0 < e && 0 < c && d <= m && (d = m, g = m + f), this.zoomToDates(new Date(d), new Date(g))) : (0 < e && 0 < c && 1 > this.start && (c = e = 0), d = this.start - c, g = this.end - e, this.zoomToIndexes(d, g))
            }
        },
        validateData: function(a) {
            this.marginsUpdated = !1;
            this.zoomOutOnDataUpdate && !a && (this.endTime = this.end = this.startTime = this.start = NaN);
            e.AmSerialChart.base.validateData.call(this)
        },
        drawChart: function() {
            if (0 < this.realWidth && 0 < this.realHeight) {
                e.AmSerialChart.base.drawChart.call(this);
                var a = this.chartData;
                if (e.ifArray(a)) {
                    var b = this.chartScrollbar;
                    b && b.draw();
                    var a = a.length - 1,
                        c, b = this.categoryAxis;
                    if (b.parseDates && !b.equalSpacing) {
                        if (b = this.startTime, c = this.endTime, isNaN(b) || isNaN(c)) b = this.firstTime, c = this.lastTime
                    } else if (b = this.start, c = this.end, isNaN(b) || isNaN(c)) b = 0, c = a;
                    this.endTime = this.startTime = this.end = this.start = void 0;
                    this.zoom(b, c)
                }
            } else this.cleanChart();
            this.dispDUpd()
        },
        cleanChart: function() {
            e.callMethod("destroy", [this.valueAxes, this.graphs, this.categoryAxis, this.chartScrollbar, this.chartCursor])
        },
        updateCategoryAxis: function(a, b, c) {
            a.chart = this;
            a.id = c;
            a.rotate = b;
            a.axisRenderer = e.RecAxis;
            a.guideFillRenderer = e.RecFill;
            a.axisItemRenderer = e.RecItem;
            a.setOrientation(!this.rotate);
            a.x = this.marginLeftReal;
            a.y = this.marginTopReal;
            a.dx = this.dx;
            a.dy = this.dy;
            a.width = this.plotAreaWidth - 1;
            a.height = this.plotAreaHeight - 1;
            a.viW = this.plotAreaWidth - 1;
            a.viH = this.plotAreaHeight - 1;
            a.viX = this.marginLeftReal;
            a.viY = this.marginTopReal;
            a.marginsChanged = !0
        },
        updateValueAxes: function() {
            e.AmSerialChart.base.updateValueAxes.call(this);
            var a = this.valueAxes,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    d = this.rotate;
                c.rotate = d;
                c.setOrientation(d);
                d = this.categoryAxis;
                if (!d.startOnAxis || d.parseDates) c.expandMinMax = !0
            }
        },
        updateData: function() {
            this.parseData();
            var a = this.graphs,
                b, c = this.chartData;
            for (b = 0; b < a.length; b++) a[b].data = c;
            0 < c.length && (this.firstTime = this.getStartTime(c[0].time), this.lastTime = this.getEndTime(c[c.length - 1].time))
        },
        getStartTime: function(a) {
            var b = this.categoryAxis;
            return e.resetDateToMin(new Date(a), b.minPeriod, 1, b.firstDayOfWeek).getTime()
        },
        getEndTime: function(a) {
            var b = e.extractPeriod(this.categoryAxis.minPeriod);
            return e.changeDate(new Date(a), b.period, b.count, !0).getTime() - 1
        },
        updateMargins: function() {
            e.AmSerialChart.base.updateMargins.call(this);
            var a = this.chartScrollbar;
            a && (this.getScrollbarPosition(a, this.rotate, this.categoryAxis.position), this.adjustMargins(a, this.rotate))
        },
        updateScrollbars: function() {
            e.AmSerialChart.base.updateScrollbars.call(this);
            this.updateChartScrollbar(this.chartScrollbar, this.rotate)
        },
        zoom: function(a, b) {
            var c = this.categoryAxis;
            c.parseDates && !c.equalSpacing ? this.timeZoom(a, b) : this.indexZoom(a, b);
            this.updateLegendValues()
        },
        timeZoom: function(a, b) {
            var c = this.maxSelectedTime;
            isNaN(c) || (b != this.endTime && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.startTime && b - a > c && (b = a + c, this.updateScrollbar = !0));
            var d = this.minSelectedTime;
            if (0 < d && b - a < d) {
                var g = Math.round(a + (b - a) / 2),
                    d = Math.round(d / 2);
                a = g - d;
                b = g + d
            }
            var h = this.chartData,
                g = this.categoryAxis;
            if (e.ifArray(h) && (a != this.startTime || b != this.endTime)) {
                var f = g.minDuration(),
                    d = this.firstTime,
                    k = this.lastTime;
                a || (a = d, isNaN(c) || (a = k - c));
                b || (b = k);
                a > k && (a = k);
                b < d && (b = d);
                a < d && (a = d);
                b > k && (b = k);
                b < a && (b = a + f);
                b - a < f / 5 && (b < k ? b = a + f / 5 : a = b - f / 5);
                this.startTime = a;
                this.endTime = b;
                c = h.length - 1;
                f = this.getClosestIndex(h, "time", a, !0, 0, c);
                h = this.getClosestIndex(h, "time", b, !1, f, c);
                g.timeZoom(a, b);
                g.zoom(f, h);
                this.start = e.fitToBounds(f, 0, c);
                this.end = e.fitToBounds(h, 0, c);
                this.zoomAxesAndGraphs();
                this.zoomScrollbar();
                a != d || b != k ? this.showZB(!0) : this.showZB(!1);
                this.updateColumnsDepth();
                this.dispatchTimeZoomEvent()
            }
        },
        updateAfterValueZoom: function() {
            this.zoomAxesAndGraphs();
            this.zoomScrollbar();
            this.updateColumnsDepth()
        },
        indexZoom: function(a, b) {
            var c = this.maxSelectedSeries;
            isNaN(c) || (b != this.end && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.start && b - a > c && (b = a + c, this.updateScrollbar = !0));
            if (a != this.start || b != this.end) {
                var d = this.chartData.length - 1;
                isNaN(a) && (a = 0, isNaN(c) || (a = d - c));
                isNaN(b) && (b = d);
                b < a && (b = a);
                b > d && (b = d);
                a > d && (a = d - 1);
                0 > a && (a = 0);
                this.start = a;
                this.end = b;
                this.categoryAxis.zoom(a, b);
                this.zoomAxesAndGraphs();
                this.zoomScrollbar();
                0 !== a || b != this.chartData.length - 1 ? this.showZB(!0) : this.showZB(!1);
                this.updateColumnsDepth();
                this.dispatchIndexZoomEvent()
            }
        },
        updateGraphs: function() {
            e.AmSerialChart.base.updateGraphs.call(this);
            var a = this.graphs,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.columnWidthReal = this.columnWidth;
                c.categoryAxis = this.categoryAxis;
                e.isString(c.fillToGraph) && (c.fillToGraph = this.getGraphById(c.fillToGraph))
            }
        },
        updateColumnsDepth: function() {
            var a, b = this.graphs,
                c;
            e.remove(this.columnsSet);
            this.columnsArray = [];
            for (a = 0; a < b.length; a++) {
                c = b[a];
                var d = c.columnsArray;
                if (d) {
                    var g;
                    for (g = 0; g < d.length; g++) this.columnsArray.push(d[g])
                }
            }
            this.columnsArray.sort(this.compareDepth);
            if (0 < this.columnsArray.length) {
                b = this.container.set();
                this.columnSet.push(b);
                for (a = 0; a < this.columnsArray.length; a++) b.push(this.columnsArray[a].column.set);
                c && b.translate(c.x, c.y);
                this.columnsSet = b
            }
        },
        compareDepth: function(a, b) {
            return a.depth > b.depth ? 1 : -1
        },
        zoomScrollbar: function() {
            var a = this.chartScrollbar,
                b = this.categoryAxis;
            a && this.updateScrollbar && a.enabled && a.dragger && (a.dragger.stop(), b.parseDates && !b.equalSpacing ? a.timeZoom(this.startTime, this.endTime) : a.zoom(this.start, this.end), this.updateScrollbar = !0)
        },
        updateTrendLines: function() {
            var a = this.trendLines,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    c = e.processObject(c, e.TrendLine, this.theme);
                a[b] = c;
                c.chart = this;
                c.id || (c.id = "trendLineAuto" + b + "_" + (new Date).getTime());
                e.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));
                c.valueAxis || (c.valueAxis = this.valueAxes[0]);
                c.categoryAxis = this.categoryAxis
            }
        },
        zoomAxesAndGraphs: function() {
            if (!this.scrollbarOnly) {
                var a = this.valueAxes,
                    b;
                for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);
                a = this.graphs;
                for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);
                this.zoomTrendLines();
                (b = this.chartCursor) && b.zoom && b.zoom(this.start, this.end, this.startTime, this.endTime)
            }
        },
        countColumns: function() {
            var a = 0,
                b = this.valueAxes.length,
                c = this.graphs.length,
                d, e, h = !1,
                f, k;
            for (k = 0; k < b; k++) {
                e = this.valueAxes[k];
                var m = e.stackType;
                if ("100%" == m || "regular" == m)
                    for (h = !1, f = 0; f < c; f++) d = this.graphs[f], d.tcc = 1, d.valueAxis == e && "column" == d.type && (!h && d.stackable && (a++, h = !0), (!d.stackable && d.clustered || d.newStack) && a++, d.columnIndex = a - 1, d.clustered || (d.columnIndex = 0));
                if ("none" == m || "3d" == m) {
                    h = !1;
                    for (f = 0; f < c; f++) d = this.graphs[f], d.valueAxis == e && "column" == d.type && (d.clustered ? (d.tcc = 1, d.newStack && (a = 0), d.hidden || (d.columnIndex = a, a++)) : d.hidden || (h = !0, d.tcc = 1, d.columnIndex = 0));
                    h && 0 === a && (a = 1)
                }
                if ("3d" == m) {
                    e = 1;
                    for (k = 0; k < c; k++) d = this.graphs[k], d.newStack && e++, d.depthCount = e, d.tcc = a;
                    a = e
                }
            }
            return a
        },
        parseData: function() {
            e.AmSerialChart.base.parseData.call(this);
            this.parseSerialData(this.dataProvider)
        },
        getCategoryIndexByValue: function(a) {
            var b = this.chartData,
                c, d;
            for (d = 0; d < b.length; d++) b[d].category == a && (c = d);
            return c
        },
        handleCursorChange: function(a) {
            this.updateLegendValues(a.index)
        },
        handleCursorZoom: function(a) {
            this.updateScrollbar = !0;
            this.zoom(a.start, a.end)
        },
        handleScrollbarZoom: function(a) {
            this.updateScrollbar = !1;
            this.zoom(a.start, a.end)
        },
        dispatchTimeZoomEvent: function() {
            if (this.prevStartTime != this.startTime || this.prevEndTime != this.endTime) {
                var a = {
                    type: "zoomed"
                };
                a.startDate = new Date(this.startTime);
                a.endDate = new Date(this.endTime);
                a.startIndex = this.start;
                a.endIndex = this.end;
                this.startIndex = this.start;
                this.endIndex = this.end;
                this.startDate = a.startDate;
                this.endDate = a.endDate;
                this.prevStartTime = this.startTime;
                this.prevEndTime = this.endTime;
                var b = this.categoryAxis,
                    c = e.extractPeriod(b.minPeriod).period,
                    b = b.dateFormatsObject[c];
                a.startValue = e.formatDate(a.startDate, b, this);
                a.endValue = e.formatDate(a.endDate, b, this);
                a.chart = this;
                a.target = this;
                this.fire(a.type, a)
            }
        },
        dispatchIndexZoomEvent: function() {
            if (this.prevStartIndex != this.start || this.prevEndIndex != this.end) {
                this.startIndex = this.start;
                this.endIndex = this.end;
                var a = this.chartData;
                if (e.ifArray(a) && !isNaN(this.start) && !isNaN(this.end)) {
                    var b = {
                        chart: this,
                        target: this,
                        type: "zoomed"
                    };
                    b.startIndex = this.start;
                    b.endIndex = this.end;
                    b.startValue = a[this.start].category;
                    b.endValue = a[this.end].category;
                    this.categoryAxis.parseDates && (this.startTime = a[this.start].time, this.endTime = a[this.end].time, b.startDate = new Date(this.startTime), b.endDate = new Date(this.endTime));
                    this.prevStartIndex = this.start;
                    this.prevEndIndex = this.end;
                    this.fire(b.type, b)
                }
            }
        },
        updateLegendValues: function(a) {
            var b = this.graphs,
                c;
            for (c = 0; c < b.length; c++) {
                var d = b[c];
                isNaN(a) ? d.currentDataItem = void 0 : d.currentDataItem = this.chartData[a].axes[d.valueAxis.id].graphs[d.id]
            }
            this.legend && this.legend.updateValues()
        },
        getClosestIndex: function(a, b, c, d, e, h) {
            0 > e && (e = 0);
            h > a.length - 1 && (h = a.length - 1);
            var f = e + Math.round((h -
                    e) / 2),
                k = a[f][b];
            if (c == k) return f;
            if (1 >= h - e) {
                if (d) return e;
                d = a[h][b];
                return Math.abs(a[e][b] - c) < Math.abs(d - c) ? e : h
            }
            return c == k ? f : c < k ? this.getClosestIndex(a, b, c, d, e, f) : this.getClosestIndex(a, b, c, d, f, h)
        },
        zoomToIndexes: function(a, b) {
            this.updateScrollbar = !0;
            var c = this.chartData;
            if (c) {
                var d = c.length;
                0 < d && (0 > a && (a = 0), b > d - 1 && (b = d - 1), d = this.categoryAxis, d.parseDates && !d.equalSpacing ? this.zoom(c[a].time, this.getEndTime(c[b].time)) : this.zoom(a, b))
            }
        },
        zoomToDates: function(a, b) {
            this.updateScrollbar = !0;
            var c = this.chartData;
            if (this.categoryAxis.equalSpacing) {
                var d = this.getClosestIndex(c, "time", a.getTime(), !0, 0, c.length);
                b = e.resetDateToMin(b, this.categoryAxis.minPeriod, 1);
                c = this.getClosestIndex(c, "time", b.getTime(), !1, 0, c.length);
                this.zoom(d, c)
            } else this.zoom(a.getTime(), b.getTime())
        },
        zoomToCategoryValues: function(a, b) {
            this.updateScrollbar = !0;
            this.zoom(this.getCategoryIndexByValue(a), this.getCategoryIndexByValue(b))
        },
        formatPeriodString: function(a, b) {
            if (b) {
                var c = ["value", "open", "low", "high", "close"],
                    d = "value open low high close average sum count".split(" "),
                    g = b.valueAxis,
                    h = this.chartData,
                    f = b.numberFormatter;
                f || (f = this.nf);
                for (var k = 0; k < c.length; k++) {
                    for (var m = c[k], l = 0, p = 0, q, t, x, u, r, n = 0, A = 0, y, z, v, E, H, I = this.start; I <= this.end; I++) {
                        var w = h[I];
                        if (w && (w = w.axes[g.id].graphs[b.id])) {
                            if (w.values) {
                                var B = w.values[m];
                                if (this.rotate) {
                                    if (0 > w.x || w.x > w.graph.height) B = NaN
                                } else if (0 > w.x || w.x > w.graph.width) B = NaN;
                                if (!isNaN(B)) {
                                    isNaN(q) && (q = B);
                                    t = B;
                                    if (isNaN(x) || x > B) x = B;
                                    if (isNaN(u) || u < B) u = B;
                                    r = e.getDecimals(l);
                                    var D = e.getDecimals(B),
                                        l = l + B,
                                        l = e.roundTo(l, Math.max(r, D));
                                    p++;
                                    r = l / p
                                }
                            }
                            if (w.percents && (w = w.percents[m], !isNaN(w))) {
                                isNaN(y) && (y = w);
                                z = w;
                                if (isNaN(v) || v > w) v = w;
                                if (isNaN(E) || E < w) E = w;
                                H = e.getDecimals(n);
                                B = e.getDecimals(w);
                                n += w;
                                n = e.roundTo(n, Math.max(H, B));
                                A++;
                                H = n / A
                            }
                        }
                    }
                    n = {
                        open: y,
                        close: z,
                        high: E,
                        low: v,
                        average: H,
                        sum: n,
                        count: A
                    };
                    a = e.formatValue(a, {
                        open: q,
                        close: t,
                        high: u,
                        low: x,
                        average: r,
                        sum: l,
                        count: p
                    }, d, f, m + "\\.", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
                    a = e.formatValue(a, n, d, this.pf, "percents\\." + m + "\\.")
                }
            }
            return a = e.cleanFromEmpty(a)
        },
        formatString: function(a, b, c) {
            var d = b.graph;
            if (-1 != a.indexOf("[[category]]")) {
                var g = b.serialDataItem.category;
                if (this.categoryAxis.parseDates) {
                    var h = this.balloonDateFormat,
                        f = this.chartCursor;
                    f && (h = f.categoryBalloonDateFormat); - 1 != a.indexOf("[[category]]") && (h = e.formatDate(g, h, this), -1 != h.indexOf("fff") && (h = e.formatMilliseconds(h, g)), g = h)
                }
                a = a.replace(/\[\[category\]\]/g, String(g))
            }
            g = d.numberFormatter;
            g || (g = this.nf);
            h = b.graph.valueAxis;
            (f = h.duration) && !isNaN(b.values.value) && (f = e.formatDuration(b.values.value, f, "", h.durationUnits, h.maxInterval, g), a = a.replace(RegExp("\\[\\[value\\]\\]", "g"), f));
            "date" == h.type && (h = e.formatDate(new Date(b.values.value), d.dateFormat, this), f = RegExp("\\[\\[value\\]\\]", "g"), a = a.replace(f, h), h = e.formatDate(new Date(b.values.open), d.dateFormat, this), f = RegExp("\\[\\[open\\]\\]", "g"), a = a.replace(f, h));
            d = "value open low high close total".split(" ");
            h = this.pf;
            a = e.formatValue(a, b.percents, d, h, "percents\\.");
            a = e.formatValue(a, b.values, d, g, "", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
            a = e.formatValue(a, b.values, ["percents"], h); - 1 != a.indexOf("[[") && (a = e.formatDataContextValue(a, b.dataContext)); - 1 != a.indexOf("[[") && b.graph.customData && (a = e.formatDataContextValue(a, b.graph.customData));
            return a = e.AmSerialChart.base.formatString.call(this, a, b, c)
        },
        addChartScrollbar: function(a) {
            e.callMethod("destroy", [this.chartScrollbar]);
            a && (a.chart = this, this.listenTo(a, "zoomed", this.handleScrollbarZoom));
            this.rotate ? void 0 === a.width && (a.width = a.scrollbarHeight) : void 0 === a.height && (a.height = a.scrollbarHeight);
            this.chartScrollbar = a
        },
        removeChartScrollbar: function() {
            e.callMethod("destroy", [this.chartScrollbar]);
            this.chartScrollbar = null
        },
        handleReleaseOutside: function(a) {
            e.AmSerialChart.base.handleReleaseOutside.call(this, a);
            e.callMethod("handleReleaseOutside", [this.chartScrollbar])
        },
        update: function() {
            e.AmSerialChart.base.update.call(this);
            this.chartScrollbar && this.chartScrollbar.update && this.chartScrollbar.update()
        }
    })
})();
(function() {
    var e = window.AmCharts;
    e.Cuboid = e.Class({
        construct: function(a, b, c, d, e, h, f, k, m, l, p, q, t, x, u, r, n) {
            this.set = a.set();
            this.container = a;
            this.h = Math.round(c);
            this.w = Math.round(b);
            this.dx = d;
            this.dy = e;
            this.colors = h;
            this.alpha = f;
            this.bwidth = k;
            this.bcolor = m;
            this.balpha = l;
            this.dashLength = x;
            this.topRadius = r;
            this.pattern = u;
            this.rotate = t;
            this.bcn = n;
            t ? 0 > b && 0 === p && (p = 180) : 0 > c && 270 == p && (p = 90);
            this.gradientRotation = p;
            0 === d && 0 === e && (this.cornerRadius = q);
            this.draw()
        },
        draw: function() {
            var a = this.set;
            a.clear();
            var b = this.container,
                c = b.chart,
                d = this.w,
                g = this.h,
                h = this.dx,
                f = this.dy,
                k = this.colors,
                m = this.alpha,
                l = this.bwidth,
                p = this.bcolor,
                q = this.balpha,
                t = this.gradientRotation,
                x = this.cornerRadius,
                u = this.dashLength,
                r = this.pattern,
                n = this.topRadius,
                A = this.bcn,
                y = k,
                z = k;
            "object" == typeof k && (y = k[0], z = k[k.length - 1]);
            var v, E, H, I, w, B, D, L, M, Q = m;
            r && (m = 0);
            var C, F, G, J, K = this.rotate;
            if (0 < Math.abs(h) || 0 < Math.abs(f))
                if (isNaN(n)) D = z, z = e.adjustLuminosity(y, -.2), z = e.adjustLuminosity(y, -.2), v = e.polygon(b, [0, h, d + h, d, 0], [0, f, f, 0, 0], z, m, 1, p, 0, t), 0 < q && (M = e.line(b, [0, h, d + h], [0, f, f], p, q, l, u)), E = e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], z, m, 1, p, 0, t), E.translate(h, f), 0 < q && (H = e.line(b, [h, h], [f, f + g], p, q, l, u)), I = e.polygon(b, [0, 0, h, h, 0], [0, g, g + f, f, 0], z, m, 1, p, 0, t), w = e.polygon(b, [d, d, d + h, d + h, d], [0, g, g + f, f, 0], z, m, 1, p, 0, t), 0 < q && (B = e.line(b, [d, d + h, d + h, d], [0, f, g + f, g], p, q, l, u)), z = e.adjustLuminosity(D, .2), D = e.polygon(b, [0, h, d + h, d, 0], [g, g + f, g + f, g, g], z, m, 1, p, 0, t), 0 < q && (L = e.line(b, [0, h, d + h], [g, g + f, g + f], p, q, l, u));
                else {
                    var N, O, P;
                    K ? (N = g / 2, z = h / 2, P = g / 2, O = d + h / 2, F = Math.abs(g / 2), C = Math.abs(h / 2)) : (z = d / 2, N = f / 2, O = d / 2, P = g + f / 2 + 1, C = Math.abs(d / 2), F = Math.abs(f / 2));
                    G = C * n;
                    J = F * n;
                    .1 < C && .1 < C && (v = e.circle(b, C, y, m, l, p, q, !1, F), v.translate(z, N));
                    .1 < G && .1 < G && (D = e.circle(b, G, e.adjustLuminosity(y, .5), m, l, p, q, !1, J), D.translate(O, P))
                }
            m = Q;
            1 > Math.abs(g) && (g = 0);
            1 > Math.abs(d) && (d = 0);
            !isNaN(n) && (0 < Math.abs(h) || 0 < Math.abs(f)) ? (k = [y], k = {
                fill: k,
                stroke: p,
                "stroke-width": l,
                "stroke-opacity": q,
                "fill-opacity": m
            }, K ? (m = "M0,0 L" + d + "," + (g / 2 - g / 2 * n), l = " B", 0 < d && (l = " A"), e.VML ? (m += l + Math.round(d -
                G) + "," + Math.round(g / 2 - J) + "," + Math.round(d + G) + "," + Math.round(g / 2 + J) + "," + d + ",0," + d + "," + g, m = m + (" L0," + g) + (l + Math.round(-C) + "," + Math.round(g / 2 - F) + "," + Math.round(C) + "," + Math.round(g / 2 + F) + ",0," + g + ",0,0")) : (m += "A" + G + "," + J + ",0,0,0," + d + "," + (g - g / 2 * (1 - n)) + "L0," + g, m += "A" + C + "," + F + ",0,0,1,0,0"), C = 90) : (l = d / 2 - d / 2 * n, m = "M0,0 L" + l + "," + g, e.VML ? (m = "M0,0 L" + l + "," + g, l = " B", 0 > g && (l = " A"), m += l + Math.round(d / 2 - G) + "," + Math.round(g - J) + "," + Math.round(d / 2 + G) + "," + Math.round(g + J) + ",0," + g + "," + d + "," + g, m += " L" + d + ",0", m += l + Math.round(d / 2 + C) + "," + Math.round(F) + "," + Math.round(d / 2 - C) + "," + Math.round(-F) + "," + d + ",0,0,0") : (m += "A" + G + "," + J + ",0,0,0," + (d - d / 2 * (1 - n)) + "," + g + "L" + d + ",0", m += "A" + C + "," + F + ",0,0,1,0,0"), C = 180), b = b.path(m).attr(k), b.gradient("linearGradient", [y, e.adjustLuminosity(y, -.3), e.adjustLuminosity(y, -.3), y], C), K ? b.translate(h / 2, 0) : b.translate(0, f / 2)) : b = 0 === g ? e.line(b, [0, d], [0, 0], p, q, l, u) : 0 === d ? e.line(b, [0, 0], [0, g], p, q, l, u) : 0 < x ? e.rect(b, d, g, k, m, l, p, q, x, t, u) : e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], k, m, l, p, q, t, !1, u);
            d = isNaN(n) ? 0 > g ? [v, M, E, H, I, w, B, D, L, b] : [D, L, E, H, I, w, v, M, B, b] : K ? 0 < d ? [v, b, D] : [D, b, v] : 0 > g ? [v, b, D] : [D, b, v];
            e.setCN(c, b, A + "front");
            e.setCN(c, E, A + "back");
            e.setCN(c, D, A + "top");
            e.setCN(c, v, A + "bottom");
            e.setCN(c, I, A + "left");
            e.setCN(c, w, A + "right");
            for (v = 0; v < d.length; v++)
                if (E = d[v]) a.push(E), e.setCN(c, E, A + "element");
            r && b.pattern(r, NaN, c.path)
        },
        width: function(a) {
            isNaN(a) && (a = 0);
            this.w = Math.round(a);
            this.draw()
        },
        height: function(a) {
            isNaN(a) && (a = 0);
            this.h = Math.round(a);
            this.draw()
        },
        animateHeight: function(a, b) {
            var c = this;
            c.easing = b;
            c.totalFrames = Math.round(1E3 * a / e.updateRate);
            c.rh = c.h;
            c.frame = 0;
            c.height(1);
            setTimeout(function() {
                c.updateHeight.call(c)
            }, e.updateRate)
        },
        updateHeight: function() {
            var a = this;
            a.frame++;
            var b = a.totalFrames;
            a.frame <= b && (b = a.easing(0, a.frame, 1, a.rh - 1, b), a.height(b), setTimeout(function() {
                a.updateHeight.call(a)
            }, e.updateRate))
        },
        animateWidth: function(a, b) {
            var c = this;
            c.easing = b;
            c.totalFrames = Math.round(1E3 * a / e.updateRate);
            c.rw = c.w;
            c.frame = 0;
            c.width(1);
            setTimeout(function() {
                c.updateWidth.call(c)
            }, e.updateRate)
        },
        updateWidth: function() {
            var a = this;
            a.frame++;
            var b = a.totalFrames;
            a.frame <= b && (b = a.easing(0, a.frame, 1, a.rw - 1, b), a.width(b), setTimeout(function() {
                a.updateWidth.call(a)
            }, e.updateRate))
        }
    })
})();
(function() {
    var e = window.AmCharts;
    e.CategoryAxis = e.Class({
        inherits: e.AxisBase,
        construct: function(a) {
            this.cname = "CategoryAxis";
            e.CategoryAxis.base.construct.call(this, a);
            this.minPeriod = "DD";
            this.equalSpacing = this.parseDates = !1;
            this.position = "bottom";
            this.startOnAxis = !1;
            this.firstDayOfWeek = 1;
            this.gridPosition = "middle";
            this.markPeriodChange = this.boldPeriodBeginning = !0;
            this.safeDistance = 30;
            this.centerLabelOnFullPeriod = !0;
            e.applyTheme(this, a, this.cname)
        },
        draw: function() {
            e.CategoryAxis.base.draw.call(this);
            this.generateDFObject();
            var a = this.chart.chartData;
            this.data = a;
            this.labelRotationR = this.labelRotation;
            if (e.ifArray(a)) {
                var b, c = this.chart;
                "scrollbar" != this.id ? (e.setCN(c, this.set, "category-axis"), e.setCN(c, this.labelsSet, "category-axis"), e.setCN(c, this.axisLine.axisSet, "category-axis")) : this.bcn = this.id + "-";
                var d = this.start,
                    g = this.labelFrequency,
                    h = 0,
                    f = this.end - d + 1,
                    k = this.gridCountR,
                    m = this.showFirstLabel,
                    l = this.showLastLabel,
                    p, q = "",
                    q = e.extractPeriod(this.minPeriod),
                    t = e.getPeriodDuration(q.period, q.count),
                    x, u, r, n;
                x = this.rotate;
                b = this.firstDayOfWeek;
                p = this.boldPeriodBeginning;
                n = e.resetDateToMin(new Date(a[a.length - 1].time + 1.05 * t), this.minPeriod, 1, b).getTime();
                this.firstTime = c.firstTime;
                this.endTime > n && (this.endTime = n);
                n = this.minorGridEnabled;
                var A = this.gridAlpha;
                if (this.parseDates && !this.equalSpacing) this.lastTime = a[a.length - 1].time, this.maxTime = e.resetDateToMin(new Date(this.lastTime + 1.05 * t), this.minPeriod, 1, b).getTime(), this.timeDifference = this.endTime - this.startTime, this.parseDatesDraw();
                else if (!this.parseDates) {
                    if (this.cellWidth = this.getStepWidth(f), f < k && (k = f), h += this.start, this.stepWidth = this.getStepWidth(f), 0 < k) {
                        k = Math.floor(f / k);
                        t = this.chooseMinorFrequency(k);
                        f = h;
                        f / 2 == Math.round(f / 2) && f--;
                        0 > f && (f = 0);
                        var y = 0;
                        this.end - f + 1 >= this.autoRotateCount && (this.labelRotationR = this.autoRotateAngle);
                        for (b = f; b <= this.end + 2; b++) {
                            p = !1;
                            0 <= b && b < this.data.length ? (u = this.data[b], q = u.category, p = u.forceShow) : q = "";
                            if (n && !isNaN(t))
                                if (b / t == Math.round(b / t) || p) b / k == Math.round(b / k) || p || (this.gridAlpha = this.minorGridAlpha, q = void 0);
                                else continue;
                            else if (b / k != Math.round(b / k) && !p) continue;
                            f = this.getCoordinate(b - h);
                            r = 0;
                            "start" == this.gridPosition && (f -= this.cellWidth / 2, r = this.cellWidth / 2);
                            p = !0;
                            var z = r;
                            "start" == this.tickPosition && (z = 0, p = !1, r = 0);
                            if (b == d && !m || b == this.end && !l) q = void 0;
                            Math.round(y / g) != y / g && (q = void 0);
                            y++;
                            var v = this.cellWidth;
                            x && (v = NaN, this.ignoreAxisWidth || !c.autoMargins) && (v = "right" == this.position ? c.marginRight : c.marginLeft, v -= this.tickLength + 10);
                            this.labelFunction && u && (q = this.labelFunction(q, u, this));
                            q = e.fixBrakes(q);
                            a = !1;
                            this.boldLabels && (a = !0);
                            b > this.end && "start" == this.tickPosition && (q = " ");
                            this.rotate && this.inside && (r = -2);
                            r = new this.axisItemRenderer(this, f, q, p, v, r, void 0, a, z, !1, u.labelColor, u.className);
                            r.serialDataItem = u;
                            this.pushAxisItem(r);
                            this.gridAlpha = A
                        }
                    }
                } else if (this.parseDates && this.equalSpacing) {
                    h = this.start;
                    this.startTime = this.data[this.start].time;
                    this.endTime = this.data[this.end].time;
                    this.timeDifference = this.endTime - this.startTime;
                    d = this.choosePeriod(0);
                    g = d.period;
                    x = d.count;
                    a = e.getPeriodDuration(g, x);
                    a < t && (g = q.period, x = q.count, a = t);
                    u = g;
                    "WW" == u && (u = "DD");
                    this.stepWidth = this.getStepWidth(f);
                    k = Math.ceil(this.timeDifference / a) + 1;
                    q = e.resetDateToMin(new Date(this.startTime - a), g, x, b).getTime();
                    this.cellWidth = this.getStepWidth(f);
                    f = Math.round(q / a);
                    d = -1;
                    f / 2 == Math.round(f / 2) && (d = -2, q -= a);
                    f = this.start;
                    f / 2 == Math.round(f / 2) && f--;
                    0 > f && (f = 0);
                    A = this.end + 2;
                    A >= this.data.length && (A = this.data.length);
                    y = !1;
                    y = !m;
                    this.previousPos = -1E3;
                    20 < this.labelRotationR && (this.safeDistance = 5);
                    z = f;
                    if (this.data[f].time != e.resetDateToMin(new Date(this.data[f].time), g, x, b).getTime())
                        for (a = 0, v = q, b = f; b < A; b++) t = this.data[b].time, this.checkPeriodChange(g, x, t, v) && (a++, 2 <= a && (z = b, b = A), v = t);
                    n && 1 < x && (t = this.chooseMinorFrequency(x), e.getPeriodDuration(g, t));
                    if (0 < this.gridCountR)
                        for (b = f; b < A; b++)
                            if (t = this.data[b].time, this.checkPeriodChange(g, x, t, q) && b >= z) {
                                f = this.getCoordinate(b - this.start);
                                n = !1;
                                this.nextPeriod[u] && (n = this.checkPeriodChange(this.nextPeriod[u], 1, t, q, u));
                                a = !1;
                                n && this.markPeriodChange ? (n = this.dateFormatsObject[this.nextPeriod[u]], a = !0) : n = this.dateFormatsObject[u];
                                q = e.formatDate(new Date(t), n, c);
                                if (b == d && !m || b == k && !l) q = " ";
                                y ? y = !1 : (p || (a = !1), f - this.previousPos > this.safeDistance * Math.cos(this.labelRotationR * Math.PI / 180) && (this.labelFunction && (q = this.labelFunction(q, new Date(t), this, g, x, r)), this.boldLabels && (a = !0), r = new this.axisItemRenderer(this, f, q, void 0, void 0, void 0, void 0, a), n = r.graphics(), this.pushAxisItem(r), n = n.getBBox().width, e.isModern || (n -= f), this.previousPos = f + n));
                                r = q = t
                            }
                }
                for (b = 0; b < this.data.length; b++)
                    if (m = this.data[b]) l = this.parseDates && !this.equalSpacing ? Math.round((m.time - this.startTime) * this.stepWidth + this.cellWidth / 2) : this.getCoordinate(b - h), m.x[this.id] = l;
                m = this.guides.length;
                for (b = 0; b < m; b++) l = this.guides[b], p = r = r = k = n = NaN, d = l.above, l.toCategory && (r = c.getCategoryIndexByValue(l.toCategory), isNaN(r) || (n = this.getCoordinate(r - h), l.expand && (n += this.cellWidth / 2), r = new this.axisItemRenderer(this, n, "", !0, NaN, NaN, l), this.pushAxisItem(r, d))), l.category && (p = c.getCategoryIndexByValue(l.category), isNaN(p) || (k = this.getCoordinate(p - h), l.expand && (k -= this.cellWidth / 2), r = (n - k) / 2, r = new this.axisItemRenderer(this, k, l.label, !0, NaN, r, l), this.pushAxisItem(r, d))), p = c.dataDateFormat, l.toDate && (l.toDate = e.getDate(l.toDate, p, this.minPeriod), this.equalSpacing ? (r = c.getClosestIndex(this.data, "time", l.toDate.getTime(), !1, 0, this.data.length - 1), isNaN(r) || (n = this.getCoordinate(r - h))) : n = (l.toDate.getTime() - this.startTime) * this.stepWidth, r = new this.axisItemRenderer(this, n, "", !0, NaN, NaN, l), this.pushAxisItem(r, d)), l.date && (l.date = e.getDate(l.date, p, this.minPeriod), this.equalSpacing ? (p = c.getClosestIndex(this.data, "time", l.date.getTime(), !1, 0, this.data.length - 1), isNaN(p) || (k = this.getCoordinate(p - h))) : k = (l.date.getTime() - this.startTime) * this.stepWidth, r = (n - k) / 2, p = !0, l.toDate && (p = !1), r = "H" == this.orientation ? new this.axisItemRenderer(this, k, l.label, p, 2 * r, NaN, l) : new this.axisItemRenderer(this, k, l.label, !1, NaN, r, l), this.pushAxisItem(r, d)), (0 < n || 0 < k) && (n < this.width || k < this.width) && (n = new this.guideFillRenderer(this, k, n, l), p = n.graphics(), this.pushAxisItem(n, d), l.graphics = p, p.index = b, l.balloonText && this.addEventListeners(p, l))
            }
            this.axisCreated = !0;
            c = this.x;
            h = this.y;
            this.set.translate(c, h);
            this.labelsSet.translate(c, h);
            this.labelsSet.show();
            this.positionTitle();
            (c = this.axisLine.set) && c.toFront();
            c = this.getBBox().height;
            2 < c - this.previousHeight && this.autoWrap && !this.parseDates && (this.axisCreated = this.chart.marginsUpdated = !1);
            this.previousHeight = c
        },
        xToIndex: function(a) {
            var b = this.data,
                c = this.chart,
                d = c.rotate,
                g = this.stepWidth;
            this.parseDates && !this.equalSpacing ? (a = this.startTime + Math.round(a / g) - this.minDuration() / 2, c = c.getClosestIndex(b, "time", a, !1, this.start, this.end + 1)) : (this.startOnAxis || (a -= g / 2), c = this.start + Math.round(a / g));
            var c = e.fitToBounds(c, 0, b.length - 1),
                h;
            b[c] && (h = b[c].x[this.id]);
            d ? h > this.height + 1 && c-- : h > this.width + 1 && c--;
            0 > h && c++;
            return c = e.fitToBounds(c, 0, b.length - 1)
        },
        dateToCoordinate: function(a) {
            return this.parseDates && !this.equalSpacing ? (a.getTime() - this.startTime) * this.stepWidth : this.parseDates && this.equalSpacing ? (a = this.chart.getClosestIndex(this.data, "time", a.getTime(), !1, 0, this.data.length - 1), this.getCoordinate(a - this.start)) : NaN
        },
        categoryToCoordinate: function(a) {
            return this.chart ? (a = this.chart.getCategoryIndexByValue(a), this.getCoordinate(a - this.start)) : NaN
        },
        coordinateToDate: function(a) {
            return this.equalSpacing ? (a = this.xToIndex(a), new Date(this.data[a].time)) : new Date(this.startTime + a / this.stepWidth)
        },
        getCoordinate: function(a) {
            a *= this.stepWidth;
            this.startOnAxis || (a += this.stepWidth / 2);
            return Math.round(a)
        }
    })
})();;;;
(function() {
    var d = window.AmCharts;
    d.AmStockChart = d.Class({
        construct: function(a) {
            this.type = "stock";
            this.cname = "AmStockChart";
            d.addChart(this);
            this.version = "3.16.0";
            this.theme = a;
            this.createEvents("zoomed", "rollOverStockEvent", "rollOutStockEvent", "clickStockEvent", "panelRemoved", "dataUpdated", "init", "rendered", "drawn", "resized");
            this.colors = "#FF6600 #FCD202 #B0DE09 #0D8ECF #2A0CD0 #CD0D74 #CC0000 #00CC00 #0000CC #DDDDDD #999999 #333333 #990000".split(" ");
            this.firstDayOfWeek = 1;
            this.glueToTheEnd = !1;
            this.dataSetCounter = -1;
            this.zoomOutOnDataSetChange = !1;
            this.panels = [];
            this.dataSets = [];
            this.chartCursors = [];
            this.comparedDataSets = [];
            this.classNamePrefix = "amcharts";
            this.categoryAxesSettings = new d.CategoryAxesSettings(a);
            this.valueAxesSettings = new d.ValueAxesSettings(a);
            this.panelsSettings = new d.PanelsSettings(a);
            this.chartScrollbarSettings = new d.ChartScrollbarSettings(a);
            this.chartCursorSettings = new d.ChartCursorSettings(a);
            this.stockEventsSettings = new d.StockEventsSettings(a);
            this.legendSettings = new d.LegendSettings(a);
            this.balloon = new d.AmBalloon(a);
            this.previousEndDate = new Date(0);
            this.previousStartDate = new Date(0);
            this.dataSetCount = this.graphCount = 0;
            this.chartCreated = !1;
            this.autoResize = this.extendToFullPeriod = !0;
            d.applyTheme(this, a, this.cname)
        },
        write: function(a) {
            var b = this.theme;
            window.AmCharts_path && (this.path = window.AmCharts_path);
            void 0 === this.path && (this.path = d.getPath());
            void 0 === this.path && (this.path = "amcharts/");
            this.path = d.normalizeUrl(this.path);
            void 0 === this.pathToImages && (this.pathToImages = this.path + "images/");
            this.initHC || (d.callInitHandler(this), this.initHC = !0);
            d.applyLang(this.language, this);
            this.chartCursors = [];
            var c = this.exportConfig;
            c && d.AmExport && !this.AmExport && (this.AmExport = new d.AmExport(this, c));
            this.amExport && d.AmExport && (this.AmExport = d.extend(this.amExport, new d.AmExport(this), !0));
            this.AmExport && this.AmExport.init();
            this.chartRendered = !1;
            a = "object" != typeof a ? document.getElementById(a) : a;
            this.zoomOutOnDataSetChange && (this.endDate = this.startDate = void 0);
            this.categoryAxesSettings = d.processObject(this.categoryAxesSettings, d.CategoryAxesSettings, b);
            this.valueAxesSettings = d.processObject(this.valueAxesSettings, d.ValueAxesSettings, b);
            this.chartCursorSettings = d.processObject(this.chartCursorSettings, d.ChartCursorSettings, b);
            this.chartScrollbarSettings = d.processObject(this.chartScrollbarSettings, d.ChartScrollbarSettings, b);
            this.legendSettings = d.processObject(this.legendSettings, d.LegendSettings, b);
            this.panelsSettings = d.processObject(this.panelsSettings, d.PanelsSettings, b);
            this.stockEventsSettings = d.processObject(this.stockEventsSettings, d.StockEventsSettings, b);
            this.dataSetSelector && (this.dataSetSelector = d.processObject(this.dataSetSelector, d.DataSetSelector, b));
            this.periodSelector && (this.periodSelector = d.processObject(this.periodSelector, d.PeriodSelector, b));
            a.innerHTML = "";
            this.div = a;
            this.measure();
            this.createLayout();
            this.updateDataSets();
            this.addDataSetSelector();
            this.addPeriodSelector();
            this.addPanels();
            this.updatePanels();
            this.addChartScrollbar();
            this.updateData();
            this.skipDefault || this.setDefaultPeriod()
        },
        setDefaultPeriod: function(a) {
            var b = this.periodSelector;
            b && (this.animationPlayed = !1, b.setDefaultPeriod(a))
        },
        validateSize: function() {
            this.measurePanels()
        },
        updateDataSets: function() {
            var a = this.mainDataSet,
                b = this.dataSets,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c],
                    e = d.processObject(e, d.DataSet);
                b[c] = e;
                e.id || (this.dataSetCount++, e.id = "ds" + this.dataSetCount);
                void 0 === e.color && (e.color = this.colors.length - 1 > c ? this.colors[c] : d.randomColor())
            }!a && d.ifArray(b) && (this.mainDataSet = this.dataSets[0])
        },
        updateEvents: function(a) {
            d.ifArray(a.stockEvents) && d.parseEvents(a, this.panels, this.stockEventsSettings, this.firstDayOfWeek, this, this.dataDateFormat)
        },
        getLastDate: function(a) {
            a = d.getDate(a, this.dataDateFormat, "fff");
            return new Date(d.changeDate(a, this.categoryAxesSettings.minPeriod, 1, !0).getTime() - 1)
        },
        getFirstDate: function(a) {
            a = d.getDate(a, this.dataDateFormat, "fff");
            return new Date(d.resetDateToMin(a, this.categoryAxesSettings.minPeriod, 1, this.firstDayOfWeek))
        },
        updateData: function() {
            var a = this.mainDataSet;
            if (a) {
                var b = this.categoryAxesSettings; - 1 == d.getItemIndex(b.minPeriod, b.groupToPeriods) && b.groupToPeriods.unshift(b.minPeriod);
                var c = a.dataProvider;
                if (d.ifArray(c)) {
                    var e = a.categoryField;
                    this.firstDate = this.getFirstDate(c[0][e]);
                    this.lastDate = this.getLastDate(c[c.length - 1][e]);
                    this.periodSelector && this.periodSelector.setRanges(this.firstDate, this.lastDate);
                    a.dataParsed || (d.parseStockData(a, b.minPeriod, b.groupToPeriods, this.firstDayOfWeek, this.dataDateFormat), a.dataParsed = !0);
                    this.updateComparingData();
                    this.updateEvents(a)
                } else this.lastDate = this.firstDate = void 0;
                this.glueToTheEnd && this.startDate && this.endDate && this.lastDate && (this.startDate = new Date(this.startDate.getTime() + (this.lastDate.getTime() - this.endDate.getTime())), this.endDate = this.lastDate, this.updateScrollbar = !0);
                this.updatePanelsWithNewData()
            }
            a = {
                type: "dataUpdated",
                chart: this
            };
            this.fire(a.type, a)
        },
        updateComparingData: function() {
            var a = this.comparedDataSets,
                b = this.categoryAxesSettings,
                c;
            for (c = 0; c < a.length; c++) {
                var e = a[c];
                e.dataParsed || (d.parseStockData(e, b.minPeriod, b.groupToPeriods, this.firstDayOfWeek, this.dataDateFormat), e.dataParsed = !0);
                this.updateEvents(e)
            }
        },
        createLayout: function() {
            var a = this.div,
                b, c, e = this.classNamePrefix,
                d = document.createElement("div");
            d.style.position = "relative";
            this.containerDiv = d;
            d.className = e + "-stock-div";
            a.appendChild(d);
            if (a = this.periodSelector) b = a.position;
            if (a = this.dataSetSelector) c = a.position;
            if ("left" == b || "left" == c) a = document.createElement("div"), a.className = e + "-left-div", a.style.cssFloat = "left", a.style.styleFloat = "left", a.style.width = "0px", a.style.position = "absolute", d.appendChild(a), this.leftContainer = a;
            if ("right" == b || "right" == c) b = document.createElement("div"), b.className = e + "-right-div", b.style.cssFloat = "right", b.style.styleFloat = "right", b.style.width = "0px", d.appendChild(b), this.rightContainer = b;
            b = document.createElement("div");
            b.className = e + "-center-div";
            d.appendChild(b);
            this.centerContainer = b;
            d = document.createElement("div");
            d.className = e + "-panels-div";
            b.appendChild(d);
            this.panelsContainer = d
        },
        addPanels: function() {
            this.measurePanels(!0);
            for (var a = this.panels, b = 0; b < a.length; b++) {
                var c = a[b],
                    c = d.processObject(c, d.StockPanel, this.theme, !0);
                a[b] = c;
                this.addStockPanel(c, b)
            }
            this.panelsAdded = !0
        },
        measurePanels: function(a) {
            this.measure();
            var b = this.chartScrollbarSettings,
                c = this.divRealHeight,
                e = this.divRealWidth;
            if (this.div) {
                var d = this.panelsSettings.panelSpacing;
                b.enabled && (c -= b.height);
                (b = this.periodSelector) && !b.vertical && (b = b.offsetHeight, c -= b + d);
                (b = this.dataSetSelector) && !b.vertical && (b = b.offsetHeight, c -= b + d);
                a || c == this.prevPH && this.prevPW == e || this.fire("resized", {
                    type: "resized",
                    chart: this
                });
                this.prevPW != e && (this.prevPW = e);
                if (c != this.prevPH) {
                    a = this.panels;
                    0 < c && (this.panelsContainer.style.height = c + "px");
                    for (var e = 0, l, b = 0; b < a.length; b++)
                        if (l = a[b]) {
                            var k = l.percentHeight;
                            isNaN(k) && (k = 100 / a.length, l.percentHeight = k);
                            e += k
                        }
                    this.panelsHeight = Math.max(c - d * (a.length - 1), 0);
                    for (b = 0; b < a.length; b++)
                        if (l = a[b]) l.percentHeight = l.percentHeight / e * 100, l.panelBox && (l.panelBox.style.height = Math.round(l.percentHeight * this.panelsHeight / 100) + "px");
                    this.prevPH = c
                }
            }
        },
        addStockPanel: function(a, b) {
            var c = this.panelsSettings,
                e = document.createElement("div");
            0 < b && !this.panels[b - 1].showCategoryAxis && (e.style.marginTop = c.panelSpacing + "px");
            a.hideBalloonReal();
            a.panelBox = e;
            a.stockChart = this;
            a.id || (a.id = "stockPanel" + b);
            e.className = "amChartsPanel " + this.classNamePrefix + "-stock-panel-div " + this.classNamePrefix + "-stock-panel-div-" + a.id;
            a.pathToImages = this.pathToImages;
            a.path = this.path;
            e.style.height = Math.round(a.percentHeight * this.panelsHeight / 100) + "px";
            e.style.width = "100%";
            this.panelsContainer.appendChild(e);
            0 < c.backgroundAlpha && (e.style.backgroundColor = c.backgroundColor);
            if (e = a.stockLegend) e = d.processObject(e, d.StockLegend, this.theme), e.container = void 0, e.title = a.title, e.marginLeft = c.marginLeft, e.marginRight = c.marginRight, e.verticalGap = 3, e.position = "top", d.copyProperties(this.legendSettings, e), a.addLegend(e, e.divId);
            a.zoomOutText = "";
            this.addCursor(a)
        },
        enableCursors: function(a) {
            var b = this.chartCursors,
                c;
            for (c = 0; c < b.length; c++) b[c].enabled = a
        },
        updatePanels: function() {
            var a = this.panels,
                b;
            for (b = 0; b < a.length; b++) this.updatePanel(a[b]);
            this.mainDataSet && this.updateGraphs();
            this.currentPeriod = void 0
        },
        updatePanel: function(a) {
            a.seriesIdField = "amCategoryIdField";
            a.dataProvider = [];
            a.chartData = [];
            a.graphs = [];
            var b = a.categoryAxis,
                c = this.categoryAxesSettings;
            d.copyProperties(this.panelsSettings, a);
            d.copyProperties(c, b);
            b.parseDates = !0;
            a.addClassNames = this.addClassNames;
            a.classNamePrefix = this.classNamePrefix;
            a.zoomOutOnDataUpdate = !1;
            a.mouseWheelScrollEnabled = this.mouseWheelScrollEnabled;
            a.dataDateFormat = this.dataDateFormat;
            a.language = this.language;
            a.showCategoryAxis ? "top" == b.position ? a.marginTop = c.axisHeight : a.marginBottom = c.axisHeight : (a.categoryAxis.labelsEnabled = !1, a.chartCursor && (a.chartCursor.categoryBalloonEnabled = !1));
            var c = a.valueAxes,
                e = c.length,
                h;
            0 === e && (h = new d.ValueAxis(this.theme), a.addValueAxis(h));
            b = new d.AmBalloon(this.theme);
            d.copyProperties(this.balloon, b);
            a.balloon = b;
            c = a.valueAxes;
            e = c.length;
            for (b = 0; b < e; b++) h = c[b], d.copyProperties(this.valueAxesSettings, h);
            a.listenersAdded = !1;
            a.write(a.panelBox)
        },
        zoom: function(a, b) {
            this.zoomChart(a, b)
        },
        zoomOut: function() {
            this.zoomChart(this.firstDate, this.lastDate)
        },
        updatePanelsWithNewData: function() {
            var a = this.mainDataSet,
                b = this.scrollbarChart;
            if (a) {
                var c = this.panels;
                this.currentPeriod = void 0;
                var e;
                for (e = 0; e < c.length; e++) {
                    var d = c[e];
                    d.categoryField = a.categoryField;
                    0 === a.dataProvider.length && (d.dataProvider = []);
                    d.scrollbarChart = b
                }
                b && (c = this.categoryAxesSettings, e = c.minPeriod, b.categoryField = a.categoryField, 0 < a.dataProvider.length ? (d = this.chartScrollbarSettings.usePeriod, b.dataProvider = d ? a.agregatedDataProviders[d] : a.agregatedDataProviders[e]) : b.dataProvider = [], d = b.categoryAxis, d.minPeriod = e, d.firstDayOfWeek = this.firstDayOfWeek, d.equalSpacing = c.equalSpacing, d.axisAlpha = 0, d.markPeriodChange = c.markPeriodChange, b.bbsetr = !0, b.validateData(), c = this.panelsSettings, b.maxSelectedTime = c.maxSelectedTime, b.minSelectedTime = c.minSelectedTime);
                0 < a.dataProvider.length && this.zoomChart(this.startDate, this.endDate)
            }
            this.panelDataInvalidated = !1
        },
        addChartScrollbar: function() {
            var a = this.chartScrollbarSettings,
                b = this.scrollbarChart;
            b && (b.clear(), b.destroy());
            if (a.enabled) {
                var c = this.panelsSettings,
                    e = this.categoryAxesSettings,
                    b = new d.AmSerialChart(this.theme);
                b.language = this.language;
                b.pathToImages = this.pathToImages;
                b.autoMargins = !1;
                this.scrollbarChart = b;
                b.id = "scrollbarChart";
                b.scrollbarOnly = !0;
                b.zoomOutText = "";
                b.marginLeft = c.marginLeft;
                b.marginRight = c.marginRight;
                b.marginTop = 0;
                b.marginBottom = 0;
                var c = e.dateFormats,
                    h = b.categoryAxis;
                h.boldPeriodBeginning = e.boldPeriodBeginning;
                c && (h.dateFormats = e.dateFormats);
                h.labelsEnabled = !1;
                h.parseDates = !0;
                e = a.graph;
                if (d.isString(e)) {
                    c = this.panels;
                    for (h = 0; h < c.length; h++) {
                        var l = d.getObjById(c[h].stockGraphs, a.graph);
                        l && (e = l)
                    }
                    a.graph = e
                }
                var k;
                e && (k = new d.AmGraph(this.theme), k.valueField = e.valueField, k.periodValue = e.periodValue, k.type = e.type, k.connect = e.connect, k.minDistance = a.minDistance, b.addGraph(k));
                e = new d.ChartScrollbar(this.theme);
                b.addChartScrollbar(e);
                d.copyProperties(a, e);
                e.scrollbarHeight = a.height;
                e.graph = k;
                this.listenTo(e, "zoomed", this.handleScrollbarZoom);
                k = document.createElement("div");
                k.className = this.classNamePrefix + "-scrollbar-chart-div";
                k.style.height = a.height + "px";
                e = this.periodSelectorContainer;
                c = this.periodSelector;
                h = this.centerContainer;
                "bottom" == a.position ? c ? "bottom" == c.position ? h.insertBefore(k, e) : h.appendChild(k) : h.appendChild(k) : c ? "top" == c.position ? h.insertBefore(k, e.nextSibling) : h.insertBefore(k, h.firstChild) : h.insertBefore(k, h.firstChild);
                b.write(k)
            }
        },
        handleScrollbarZoom: function(a) {
            if (this.skipScrollbarEvent) this.skipScrollbarEvent = !1;
            else {
                var b = a.endDate,
                    c = {};
                c.startDate = a.startDate;
                c.endDate = b;
                this.updateScrollbar = !1;
                this.handleZoom(c)
            }
        },
        addPeriodSelector: function() {
            var a = this.periodSelector;
            if (a) {
                var b = this.categoryAxesSettings.minPeriod;
                a.minDuration = d.getPeriodDuration(b);
                a.minPeriod = b;
                a.chart = this;
                var c = this.dataSetSelector,
                    e, b = this.dssContainer;
                c && (e = c.position);
                var c = this.panelsSettings.panelSpacing,
                    h = document.createElement("div");
                this.periodSelectorContainer = h;
                var l = this.leftContainer,
                    k = this.rightContainer,
                    g = this.centerContainer,
                    m = this.panelsContainer,
                    f = a.width +
                    2 * c + "px";
                switch (a.position) {
                    case "left":
                        l.style.width = a.width + "px";
                        l.appendChild(h);
                        g.style.paddingLeft = f;
                        break;
                    case "right":
                        g.style.marginRight = f;
                        k.appendChild(h);
                        k.style.width = a.width + "px";
                        break;
                    case "top":
                        m.style.clear = "both";
                        g.insertBefore(h, m);
                        h.style.paddingBottom = c + "px";
                        h.style.overflow = "hidden";
                        break;
                    case "bottom":
                        h.style.marginTop = c + "px", "bottom" == e ? g.insertBefore(h, b) : g.appendChild(h)
                }
                this.listenTo(a, "changed", this.handlePeriodSelectorZoom);
                a.write(h)
            }
        },
        addDataSetSelector: function() {
            var a = this.dataSetSelector;
            if (a) {
                a.chart = this;
                a.dataProvider = this.dataSets;
                var b = a.position,
                    c = this.panelsSettings.panelSpacing,
                    e = document.createElement("div");
                this.dssContainer = e;
                var d = this.leftContainer,
                    l = this.rightContainer,
                    k = this.centerContainer,
                    g = this.panelsContainer,
                    c = a.width + 2 * c + "px";
                switch (b) {
                    case "left":
                        d.style.width = a.width + "px";
                        d.appendChild(e);
                        k.style.paddingLeft = c;
                        break;
                    case "right":
                        k.style.marginRight = c;
                        l.appendChild(e);
                        l.style.width = a.width + "px";
                        break;
                    case "top":
                        g.style.clear = "both";
                        k.insertBefore(e, g);
                        e.style.overflow = "hidden";
                        break;
                    case "bottom":
                        k.appendChild(e)
                }
                a.write(e)
            }
        },
        handlePeriodSelectorZoom: function(a) {
            var b = this.scrollbarChart;
            b && (b.updateScrollbar = !0);
            a.predefinedPeriod ? (this.predefinedStart = a.startDate, this.predefinedEnd = a.endDate) : this.predefinedEnd = this.predefinedStart = null;
            this.zoomChart(a.startDate, a.endDate)
        },
        addCursor: function(a) {
            var b = this.chartCursorSettings;
            if (b.enabled) {
                var c = new d.ChartCursor(this.theme);
                d.copyProperties(b, c);
                a.chartCursor && d.copyProperties(a.chartCursor, c);
                a.removeChartCursor();
                a.addChartCursor(c);
                this.listenTo(c, "changed", this.handleCursorChange);
                this.listenTo(c, "onHideCursor", this.hideChartCursor);
                this.listenTo(c, "zoomed", this.handleCursorZoom);
                this.chartCursors.push(c)
            }
        },
        hideChartCursor: function() {
            var a = this.chartCursors,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.hideCursor(!1);
                (c = c.chart) && c.updateLegendValues()
            }
        },
        handleCursorZoom: function(a) {
            var b = this.scrollbarChart;
            b && (b.updateScrollbar = !0);
            var b = {},
                c;
            if (this.categoryAxesSettings.equalSpacing) {
                var e = this.mainDataSet.categoryField,
                    d = this.mainDataSet.agregatedDataProviders[this.currentPeriod];
                c = new Date(d[a.start][e]);
                a = new Date(d[a.end][e])
            } else c = new Date(a.start), a = new Date(a.end);
            b.startDate = c;
            b.endDate = a;
            this.handleZoom(b)
        },
        handleZoom: function(a) {
            this.zoomChart(a.startDate, a.endDate)
        },
        zoomChart: function(a, b) {
            var c = new Date(a),
                e = this,
                h = e.firstDate,
                l = e.lastDate,
                k = e.currentPeriod,
                g = e.categoryAxesSettings,
                m = g.minPeriod,
                f = e.panelsSettings,
                p = e.periodSelector,
                t = e.panels,
                u = e.comparedGraphs,
                x = e.scrollbarChart,
                y = e.firstDayOfWeek;
            if (h && l) {
                a || (a = h);
                b || (b = l);
                if (k) {
                    var n = d.extractPeriod(k);
                    a.getTime() == b.getTime() && n != m && (b = d.changeDate(b, n.period, n.count), b.setTime(b.getTime() - 1))
                }
                a.getTime() < h.getTime() && (a = h);
                a.getTime() > l.getTime() && (a = l);
                b.getTime() < h.getTime() && (b = h);
                b.getTime() > l.getTime() && (b = l);
                m = d.getItemIndex(m, g.groupToPeriods);
                g = k;
                k = e.choosePeriod(m, a, b);
                e.currentPeriod = k;
                var m = d.extractPeriod(k),
                    z = d.getPeriodDuration(m.period, m.count);
                1 > b.getTime() - a.getTime() && (a = new Date(b.getTime() - 1));
                n = new Date(a);
                e.extendToFullPeriod && (n.getTime() - h.getTime() < .1 * z && (n = d.resetDateToMin(a, m.period, m.count, y)), l.getTime() - b.getTime() < .1 * z && (b = d.resetDateToMin(l, m.period, m.count, y), b = d.changeDate(b, m.period, m.count, !0)));
                for (h = 0; h < t.length; h++) l = t[h], l.chartCursor && l.chartCursor.panning && (n = c);
                for (h = 0; h < t.length; h++) {
                    l = t[h];
                    if (k != g) {
                        for (c = 0; c < u.length; c++) z = u[c].graph, z.dataProvider = z.dataSet.agregatedDataProviders[k];
                        c = l.categoryAxis;
                        c.firstDayOfWeek = y;
                        c.minPeriod = k;
                        l.dataProvider = e.mainDataSet.agregatedDataProviders[k];
                        if (c = l.chartCursor) c.categoryBalloonDateFormat = e.chartCursorSettings.categoryBalloonDateFormat(m.period), l.showCategoryAxis || (c.categoryBalloonEnabled = !1);
                        l.startTime = n.getTime();
                        l.endTime = b.getTime();
                        l.validateData(!0)
                    }
                    c = !1;
                    l.chartCursor && l.chartCursor.panning && (c = !0);
                    c || (l.startTime = void 0, l.endTime = void 0, l.zoomToDates(n, b));
                    0 < f.startDuration && e.animationPlayed && !c ? (l.startDuration = 0, l.animateAgain()) : 0 < f.startDuration && !c && l.animateAgain()
                }
                e.animationPlayed = !0;
                f = new Date(b);
                x && e.updateScrollbar && (x.zoomToDates(a, f), e.skipScrollbarEvent = !0, setTimeout(function() {
                    e.resetSkip.call(e)
                }, 100));
                e.updateScrollbar = !0;
                e.startDate = a;
                e.endDate = b;
                p && p.zoom(a, b);
                if (a.getTime() != e.previousStartDate.getTime() || b.getTime() != e.previousEndDate.getTime()) p = {
                    type: "zoomed"
                }, p.startDate = a, p.endDate = b, p.chart = e, p.period = k, e.fire(p.type, p), e.previousStartDate = new Date(a), e.previousEndDate = new Date(b)
            }
            e.eventsHidden && e.showHideEvents(!1);
            e.skipEvents || (e.chartCreated || (k = "init", e.fire(k, {
                type: k,
                chart: e
            })), e.chartRendered || (k = "rendered", e.fire(k, {
                type: k,
                chart: e
            }), e.chartRendered = !0), k = "drawn", e.fire(k, {
                type: k,
                chart: e
            }));
            e.skipEvents = !1;
            e.chartCreated = !0;
            e.animationPlayed = !0
        },
        resetSkip: function() {
            this.skipScrollbarEvent = !1
        },
        updateGraphs: function() {
            this.getSelections();
            if (0 < this.dataSets.length) {
                var a = this.panels;
                this.comparedGraphs = [];
                var b;
                for (b = 0; b < a.length; b++) {
                    var c = a[b],
                        e = c.valueAxes,
                        h;
                    for (h = 0; h < e.length; h++) {
                        var l = e[h];
                        l.prevLog && (l.logarithmic = l.prevLog);
                        l.recalculateToPercents = "always" == c.recalculateToPercents ? !0 : !1
                    }
                    e = this.mainDataSet;
                    h = this.comparedDataSets;
                    l = c.stockGraphs;
                    c.graphs = [];
                    var k, g, m;
                    for (k = 0; k < l.length; k++) {
                        var f = l[k],
                            f = d.processObject(f, d.StockGraph, this.theme);
                        l[k] = f;
                        if (!f.title || f.resetTitleOnDataSetChange) f.title = e.title, f.resetTitleOnDataSetChange = !0;
                        f.useDataSetColors && (f.lineColor = e.color, f.fillColors = void 0, f.bulletColor = void 0);
                        var p = !1,
                            t = e.fieldMappings;
                        for (g = 0; g < t.length; g++) {
                            m = t[g];
                            var u = f.valueField;
                            u && m.toField == u && (p = !0);
                            (u = f.openField) && m.toField == u && (p = !0);
                            (u = f.closeField) && m.toField == u && (p = !0);
                            (u = f.lowField) && m.toField == u && (p = !0)
                        }
                        c.addGraph(f);
                        p || (f.visibleInLegend = !1);
                        u = !1;
                        "always" == c.recalculateToPercents && (u = !0);
                        var x = c.stockLegend,
                            y, n, z, A;
                        x && (x = d.processObject(x, d.StockLegend, this.theme), c.stockLegend = x, y = x.valueTextComparing, n = x.valueTextRegular, z = x.periodValueTextComparing, A = x.periodValueTextRegular);
                        if (f.comparable) {
                            var B = h.length;
                            if (f.valueAxis) {
                                0 < B && f.valueAxis.logarithmic && "never" != c.recalculateToPercents && (f.valueAxis.logarithmic = !1, f.valueAxis.prevLog = !0);
                                0 < B && "whenComparing" == c.recalculateToPercents && (f.valueAxis.recalculateToPercents = !0);
                                x && f.valueAxis && !0 === f.valueAxis.recalculateToPercents && (u = !0);
                                var D;
                                for (D = 0; D < B; D++) {
                                    var C = h[D],
                                        r = f.comparedGraphs[C.id];
                                    r || (r = new d.AmGraph(this.theme), r.id = "comparedGraph_" + f.id + "_" + C.id);
                                    f.compareGraph && d.copyProperties(f.compareGraph, r);
                                    r.periodValue = f.periodValue;
                                    r.recalculateValue = f.recalculateValue;
                                    r.dataSet = C;
                                    r.behindColumns = f.behindColumns;
                                    f.comparedGraphs[C.id] = r;
                                    r.seriesIdField = "amCategoryIdField";
                                    r.connect = f.connect;
                                    r.clustered = f.clustered;
                                    r.showBalloon = f.showBalloon;
                                    this.passFields(f, r);
                                    var v = f.compareField;
                                    v || (v = f.valueField);
                                    p = !1;
                                    t = C.fieldMappings;
                                    for (g = 0; g < t.length; g++) m = t[g], m.toField == v && (p = !0);
                                    if (p) {
                                        r.valueField = v;
                                        r.title = C.title;
                                        r.lineColor = C.color;
                                        f.compareGraphLineColor && (r.lineColor = f.compareGraphLineColor);
                                        f.compareGraphType && (r.type = f.compareGraphType);
                                        g = f.compareGraphLineThickness;
                                        isNaN(g) || (r.lineThickness = g);
                                        g = f.compareGraphDashLength;
                                        isNaN(g) || (r.dashLength = g);
                                        g = f.compareGraphLineAlpha;
                                        isNaN(g) || (r.lineAlpha = g);
                                        g = f.compareGraphCornerRadiusTop;
                                        isNaN(g) || (r.cornerRadiusTop = g);
                                        g = f.compareGraphCornerRadiusBottom;
                                        isNaN(g) || (r.cornerRadiusBottom = g);
                                        g = f.compareGraphBalloonColor;
                                        isNaN(g) || (r.balloonColor = g);
                                        g = f.compareGraphBulletColor;
                                        isNaN(g) || (r.bulletColor = g);
                                        if (g = f.compareGraphFillColors) r.fillColors = g;
                                        if (g = f.compareGraphNegativeFillColors) r.negativeFillColors = g;
                                        if (g = f.compareGraphFillAlphas) r.fillAlphas = g;
                                        if (g = f.compareGraphNegativeFillAlphas) r.negativeFillAlphas = g;
                                        if (g = f.compareGraphBullet) r.bullet = g;
                                        if (g = f.compareGraphNumberFormatter) r.numberFormatter = g;
                                        g = f.compareGraphPrecision;
                                        isNaN(g) || (r.precision = g);
                                        if (g = f.compareGraphBalloonText) r.balloonText = g;
                                        g = f.compareGraphBulletSize;
                                        isNaN(g) || (r.bulletSize = g);
                                        g = f.compareGraphBulletAlpha;
                                        isNaN(g) || (r.bulletAlpha = g);
                                        g = f.compareGraphBulletBorderAlpha;
                                        isNaN(g) || (r.bulletBorderAlpha = g);
                                        if (g = f.compareGraphBulletBorderColor) r.bulletBorderColor = g;
                                        g = f.compareGraphBulletBorderThickness;
                                        isNaN(g) || (r.bulletBorderThickness = g);
                                        r.visibleInLegend = f.compareGraphVisibleInLegend;
                                        r.balloonFunction = f.compareGraphBalloonFunction;
                                        r.hideBulletsCount = f.hideBulletsCount;
                                        r.valueAxis = f.valueAxis;
                                        x && (u && y ? (r.legendValueText = y, r.legendPeriodValueText = z) : (n && (r.legendValueText = n), r.legendPeriodValueText = A));
                                        c.showComparedOnTop ? c.graphs.push(r) : c.graphs.unshift(r);
                                        this.comparedGraphs.push({
                                            graph: r,
                                            dataSet: C
                                        })
                                    }
                                }
                            }
                        }
                        x && (u && y ? (f.legendValueText = y, f.legendPeriodValueText = z) : (n && (f.legendValueText = n), f.legendPeriodValueText = A))
                    }
                }
            }
        },
        passFields: function(a, b) {
            for (var c = "lineColor color alpha fillColors description bullet customBullet bulletSize bulletConfig url labelColor dashLength pattern gap className".split(" "), e = 0; e < c.length; e++) {
                var d = c[e];
                b[d + "Field"] = a[d + "Field"]
            }
        },
        choosePeriod: function(a, b, c) {
            var e = this.categoryAxesSettings,
                h = e.groupToPeriods,
                l = h[a],
                k = h[a + 1],
                g = d.extractPeriod(l),
                g = d.getPeriodDuration(g.period, g.count),
                m = b.getTime(),
                f = c.getTime(),
                p = e.maxSeries;
            e.alwaysGroup && l == e.minPeriod && (l = 1 < h.length ? h[1] : h[0]);
            return (f - m) / g > p && 0 < p && k ? this.choosePeriod(a + 1, b, c) : l
        },
        handleCursorChange: function(a) {
            if (!this.chartCursorSettings.onePanelOnly) {
                var b = a.target,
                    c = a.position,
                    e = a.zooming;
                a = a.index;
                var d = this.chartCursors,
                    l;
                for (l = 0; l < d.length; l++) {
                    var k = d[l];
                    k != b && c && (k.isZooming(e), k.previousMousePosition = NaN, k.forceShow = !0, k.initialMouse = b.initialMouse, k.selectionPosX = b.selectionPosX, k.setPosition(c, !1, a))
                }
            }
        },
        getSelections: function() {
            var a = [],
                b = this.dataSets,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c];
                e.compared && a.push(e)
            }
            this.comparedDataSets = a;
            b = this.panels;
            for (c = 0; c < b.length; c++) e = b[c], "never" != e.recalculateToPercents && 0 < a.length ? e.hideDrawingIcons(!0) : e.drawingIconsEnabled && e.hideDrawingIcons(!1)
        },
        addPanel: function(a) {
            this.panels.push(a);
            this.prevPH = void 0;
            d.removeChart(a);
            d.addChart(a)
        },
        addPanelAt: function(a, b) {
            this.panels.splice(b, 0, a);
            this.prevPH = void 0;
            d.removeChart(a);
            d.addChart(a)
        },
        removePanel: function(a) {
            var b = this.panels;
            this.prevPH = void 0;
            var c;
            for (c = b.length - 1; 0 <= c; c--)
                if (b[c] == a) {
                    var e = {
                        type: "panelRemoved",
                        panel: a,
                        chart: this
                    };
                    this.fire(e.type, e);
                    b.splice(c, 1);
                    a.destroy();
                    a.clear()
                }
        },
        validateData: function() {
            this.resetDataParsed();
            this.updateDataSets();
            this.mainDataSet.compared = !1;
            this.updateGraphs();
            this.updateData();
            var a = this.dataSetSelector;
            a && a.write(a.div)
        },
        resetDataParsed: function() {
            var a = this.dataSets,
                b;
            for (b = 0; b < a.length; b++) a[b].dataParsed = !1
        },
        validateNow: function(a, b) {
            this.skipDefault = !0;
            this.chartRendered = !1;
            this.prevPH = void 0;
            this.skipEvents = b;
            this.clear(!0);
            this.initTO && clearTimeout(this.initTO);
            a && this.resetDataParsed();
            this.write(this.div)
        },
        hideStockEvents: function() {
            this.showHideEvents(!1);
            this.eventsHidden = !0
        },
        showStockEvents: function() {
            this.showHideEvents(!0);
            this.eventsHidden = !1
        },
        showHideEvents: function(a) {
            var b = this.panels,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c].graphs,
                    d;
                for (d = 0; d < e.length; d++) {
                    var l = e[d];
                    !0 === a ? l.showCustomBullets(!0) : l.hideCustomBullets(!0)
                }
            }
        },
        invalidateSize: function() {
            var a = this;
            clearTimeout(a.validateTO);
            var b = setTimeout(function() {
                a.validateNow()
            }, 5);
            a.validateTO = b
        },
        measure: function() {
            var a = this.div;
            if (a) {
                var b = a.offsetWidth,
                    c = a.offsetHeight;
                a.clientHeight && (b = a.clientWidth, c = a.clientHeight);
                this.divRealWidth = b;
                this.divRealHeight = c
            }
        },
        handleResize: function() {
            var a = this,
                b = setTimeout(function() {
                    a.validateSizeReal()
                }, 150);
            a.initTO = b
        },
        validateSizeReal: function() {
            this.previousWidth = this.divRealWidth;
            this.previousHeight = this.divRealHeight;
            this.measure();
            if (this.divRealWidth != this.previousWidth || this.divRealHeight != this.previousHeight) 0 < this.divRealWidth && 0 < this.divRealHeight && this.fire("resized", {
                type: "resized",
                chart: this
            }), this.divRealHeight != this.previousHeight && this.validateNow()
        },
        clear: function(a) {
            var b = this.panels,
                c;
            if (b)
                for (c = 0; c < b.length; c++) {
                    var e = b[c];
                    a || (e.cleanChart(), e.destroy());
                    e.clear(a)
                }(b = this.scrollbarChart) && b.clear();
            if (b = this.div) b.innerHTML = "";
            a || (this.div = null, d.deleteObject(this))
        }
    });
    d.StockEvent = d.Class({
        construct: function() {}
    })
})();
(function() {
    var d = window.AmCharts;
    d.DataSet = d.Class({
        construct: function() {
            this.cname = "DataSet";
            this.fieldMappings = [];
            this.dataProvider = [];
            this.agregatedDataProviders = [];
            this.stockEvents = [];
            this.compared = !1;
            this.showInCompare = this.showInSelect = !0
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.PeriodSelector = d.Class({
        construct: function(a) {
            this.cname = "PeriodSelector";
            this.theme = a;
            this.createEvents("changed");
            this.inputFieldsEnabled = !0;
            this.position = "bottom";
            this.width = 180;
            this.fromText = "From: ";
            this.toText = "to: ";
            this.periodsText = "Zoom: ";
            this.periods = [];
            this.inputFieldWidth = 100;
            this.dateFormat = "DD-MM-YYYY";
            this.hideOutOfScopePeriods = !0;
            d.applyTheme(this, a, this.cname)
        },
        zoom: function(a, b) {
            var c = this.chart;
            this.inputFieldsEnabled && (this.startDateField.value = d.formatDate(a, this.dateFormat, c), this.endDateField.value = d.formatDate(b, this.dateFormat, c));
            this.markButtonAsSelected()
        },
        write: function(a) {
            var b = this,
                c = b.chart.classNamePrefix;
            a.className = "amChartsPeriodSelector " + c + "-period-selector-div";
            var e = b.width,
                h = b.position;
            b.width = void 0;
            b.position = void 0;
            d.applyStyles(a.style, b);
            b.width = e;
            b.position = h;
            b.div = a;
            a.innerHTML = "";
            e = b.theme;
            h = b.position;
            h = "top" == h || "bottom" == h ? !1 : !0;
            b.vertical = h;
            var l = 0,
                k = 0;
            if (b.inputFieldsEnabled) {
                var g = document.createElement("div");
                a.appendChild(g);
                var m = document.createTextNode(d.lang.fromText || b.fromText);
                g.appendChild(m);
                h ? d.addBr(g) : (g.style.styleFloat = "left", g.style.display = "inline");
                var f = document.createElement("input");
                f.className = "amChartsInputField " + c + "-start-date-input";
                e && d.applyStyles(f.style, e.PeriodInputField);
                f.style.textAlign = "center";
                f.onblur = function(a) {
                    b.handleCalChange(a)
                };
                d.isNN && f.addEventListener("keypress", function(a) {
                    b.handleCalendarChange.call(b, a)
                }, !0);
                d.isIE && f.attachEvent("onkeypress", function(a) {
                    b.handleCalendarChange.call(b, a)
                });
                g.appendChild(f);
                b.startDateField = f;
                if (h) m = b.width - 6 + "px", d.addBr(g);
                else {
                    var m = b.inputFieldWidth + "px",
                        p = document.createTextNode(" ");
                    g.appendChild(p)
                }
                f.style.width = m;
                f = document.createTextNode(d.lang.toText || b.toText);
                g.appendChild(f);
                h && d.addBr(g);
                f = document.createElement("input");
                f.className = "amChartsInputField " + c + "-end-date-input";
                e && d.applyStyles(f.style, e.PeriodInputField);
                f.style.textAlign = "center";
                f.onblur = function() {
                    b.handleCalChange()
                };
                d.isNN && f.addEventListener("keypress", function(a) {
                    b.handleCalendarChange.call(b, a)
                }, !0);
                d.isIE && f.attachEvent("onkeypress", function(a) {
                    b.handleCalendarChange.call(b, a)
                });
                g.appendChild(f);
                b.endDateField = f;
                h ? d.addBr(g) : l = f.offsetHeight + 2;
                m && (f.style.width = m)
            }
            g = b.periods;
            if (d.ifArray(g)) {
                m = document.createElement("div");
                h || (m.style.cssFloat = "right", m.style.styleFloat = "right", m.style.display = "inline");
                a.appendChild(m);
                h && d.addBr(m);
                a = document.createTextNode(d.lang.periodsText || b.periodsText);
                m.appendChild(a);
                b.periodContainer = m;
                var t;
                for (a = 0; a < g.length; a++) f = g[a], t = document.createElement("input"), t.type = "button", t.value = f.label, t.period = f.period, t.count = f.count, t.periodObj = f, t.className = "amChartsButton " + c + "-period-input", e && d.applyStyles(t.style, e.PeriodButton), h && (t.style.width = b.width - 1 + "px"), t.style.boxSizing = "border-box", m.appendChild(t), b.addEventListeners(t), f.button = t;
                !h && t && (k = t.offsetHeight)
            }
            b.offsetHeight = Math.max(l, k)
        },
        addEventListeners: function(a) {
            var b = this;
            d.isNN && a.addEventListener("click", function(a) {
                b.handlePeriodChange.call(b, a)
            }, !0);
            d.isIE && a.attachEvent("onclick", function(a) {
                b.handlePeriodChange.call(b, a)
            })
        },
        getPeriodDates: function() {
            var a = this.periods,
                b;
            for (b = 0; b < a.length; b++) this.selectPeriodButton(a[b], !0)
        },
        handleCalendarChange: function(a) {
            13 == a.keyCode && this.handleCalChange(a)
        },
        handleCalChange: function(a) {
            var b = this.dateFormat,
                c = d.stringToDate(this.startDateField.value, b),
                b = this.chart.getLastDate(d.stringToDate(this.endDateField.value, b));
            try {
                this.startDateField.blur(), this.endDateField.blur()
            } catch (e) {}
            if (c && b) {
                var h = {
                    type: "changed"
                };
                h.startDate = c;
                h.endDate = b;
                h.chart = this.chart;
                h.event = a;
                this.fire(h.type, h)
            }
        },
        handlePeriodChange: function(a) {
            this.selectPeriodButton((a.srcElement ? a.srcElement : a.target).periodObj, !1, a)
        },
        setRanges: function(a, b) {
            this.firstDate = a;
            this.lastDate = b;
            this.getPeriodDates()
        },
        selectPeriodButton: function(a, b, c) {
            var e = a.button,
                h = e.count,
                l = e.period,
                k = this.chart,
                g, m, f = this.firstDate,
                p = this.lastDate,
                t, u = this.theme;
            f && p && ("MAX" == l ? (g = f, m = p) : "YTD" == l ? (g = new Date, g.setMonth(0, 1), g.setHours(0, 0, 0, 0), 0 === h && g.setDate(g.getDate() - 1), m = this.lastDate) : "YYYY" == l || "MM" == l ? this.selectFromStart ? (g = f, m = new Date(f), m.setMonth(m.getMonth() + h)) : (g = new Date(p), d.changeDate(g, l, h, !1), m = p) : (t = d.getPeriodDuration(l, h), this.selectFromStart ? (g = f, m = new Date(f.getTime() + t - 1)) : (g = new Date(p.getTime() - t + 1), m = p)), a.startTime = g.getTime(), this.hideOutOfScopePeriods && (b && a.startTime < f.getTime() ? e.style.display = "none" : e.style.display = "inline"), g.getTime() > p.getTime() && (t = d.getPeriodDuration("DD", 1), g = new Date(p.getTime() - t)), g.getTime() < f.getTime() && (g = f), "YTD" == l && (a.startTime = g.getTime()), a.endTime = m.getTime(), b || (this.skipMark = !0, this.unselectButtons(), e.className = "amChartsButtonSelected " + k.classNamePrefix + "-period-input-selected", u && d.applyStyles(e.style, u.PeriodButtonSelected), a = {
                type: "changed"
            }, a.startDate = g, a.endDate = m, a.predefinedPeriod = l, a.chart = this.chart, a.count = h, a.event = c, this.fire(a.type, a)))
        },
        markButtonAsSelected: function() {
            if (!this.skipMark) {
                var a = this.chart,
                    b = this.periods,
                    c = a.startDate.getTime(),
                    e = a.endDate.getTime(),
                    h = this.lastDate.getTime();
                e > h && (e = h);
                h = this.theme;
                this.unselectButtons();
                var l;
                for (l = b.length - 1; 0 <= l; l--) {
                    var k = b[l],
                        g = k.button;
                    k.startTime && k.endTime && c == k.startTime && e == k.endTime && (this.unselectButtons(), g.className = "amChartsButtonSelected " + a.classNamePrefix + "-period-input-selected", h && d.applyStyles(g.style, h.PeriodButtonSelected))
                }
            }
            this.skipMark = !1
        },
        unselectButtons: function() {
            var a = this.chart,
                b = this.periods,
                c, e = this.theme;
            for (c = b.length - 1; 0 <= c; c--) {
                var h = b[c].button;
                h.className = "amChartsButton " + a.classNamePrefix + "-period-input";
                e && d.applyStyles(h.style, e.PeriodButton)
            }
        },
        setDefaultPeriod: function() {
            var a = this.periods,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.selected && this.selectPeriodButton(c)
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.StockGraph = d.Class({
        inherits: d.AmGraph,
        construct: function(a) {
            d.StockGraph.base.construct.call(this, a);
            this.cname = "StockGraph";
            this.useDataSetColors = !0;
            this.periodValue = "Close";
            this.compareGraphType = "line";
            this.compareGraphVisibleInLegend = !0;
            this.comparable = this.resetTitleOnDataSetChange = !1;
            this.comparedGraphs = {};
            this.showEventsOnComparedGraphs = !1;
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.StockPanel = d.Class({
        inherits: d.AmSerialChart,
        construct: function(a) {
            d.StockPanel.base.construct.call(this, a);
            this.cname = "StockPanel";
            this.theme = a;
            this.showCategoryAxis = this.showComparedOnTop = !0;
            this.recalculateToPercents = "whenComparing";
            this.panelHeaderPaddingBottom = this.panelHeaderPaddingLeft = this.panelHeaderPaddingRight = this.panelHeaderPaddingTop = 0;
            this.trendLineAlpha = 1;
            this.trendLineColor = "#00CC00";
            this.trendLineColorHover = "#CC0000";
            this.trendLineThickness = 2;
            this.trendLineDashLength = 0;
            this.stockGraphs = [];
            this.drawingIconsEnabled = !1;
            this.iconSize = 38;
            this.autoMargins = this.allowTurningOff = this.eraseAll = this.erasingEnabled = this.drawingEnabled = !1;
            d.applyTheme(this, a, this.cname)
        },
        initChart: function(a) {
            d.StockPanel.base.initChart.call(this, a);
            this.drawingIconsEnabled && this.createDrawIcons();
            (a = this.chartCursor) && this.listenTo(a, "draw", this.handleDraw)
        },
        addStockGraph: function(a) {
            this.stockGraphs.push(a);
            return a
        },
        handleCursorZoom: function(a) {
            this.chartCursor && this.chartCursor.pan && d.StockPanel.base.handleCursorZoom.call(this, a)
        },
        removeStockGraph: function(a) {
            var b = this.stockGraphs,
                c;
            for (c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1)
        },
        createDrawIcons: function() {
            var a = this,
                b = a.iconSize,
                c = a.container,
                e = a.pathToImages,
                h = a.realWidth - 2 * b - 1 - a.marginRight,
                l = d.rect(c, b, b, "#000", .005),
                k = d.rect(c, b, b, "#000", .005);
            k.translate(b + 1, 0);
            var g = c.image(e + "pencilIcon" + a.extension, 0, 0, b, b);
            d.setCN(a, g, "pencil");
            a.pencilButton = g;
            k.setAttr("cursor", "pointer");
            l.setAttr("cursor", "pointer");
            l.mouseup(function() {
                a.handlePencilClick()
            });
            var m = c.image(e + "pencilIconH" + a.extension, 0, 0, b, b);
            d.setCN(a, m, "pencil-pushed");
            a.pencilButtonPushed = m;
            a.drawingEnabled || m.hide();
            var f = c.image(e + "eraserIcon" + a.extension, b + 1, 0, b, b);
            d.setCN(a, f, "eraser");
            a.eraserButton = f;
            k.mouseup(function() {
                a.handleEraserClick()
            });
            l.touchend && (l.touchend(function() {
                a.handlePencilClick()
            }), k.touchend(function() {
                a.handleEraserClick()
            }));
            b = c.image(e + "eraserIconH" + a.extension, b + 1, 0, b, b);
            d.setCN(a, b, "eraser-pushed");
            a.eraserButtonPushed = b;
            a.erasingEnabled || b.hide();
            c = c.set([g, m, f, b, l, k]);
            d.setCN(a, c, "drawing-tools");
            c.translate(h, 1);
            this.hideIcons && c.hide()
        },
        handlePencilClick: function() {
            var a = !this.drawingEnabled;
            this.disableDrawing(!a);
            this.erasingEnabled = !1;
            var b = this.eraserButtonPushed;
            b && b.hide();
            b = this.pencilButtonPushed;
            a ? b && b.show() : (b && b.hide(), this.setMouseCursor("auto"))
        },
        disableDrawing: function(a) {
            this.drawingEnabled = !a;
            var b = this.chartCursor;
            this.stockChart.enableCursors(a);
            b && b.enableDrawing(!a)
        },
        handleEraserClick: function() {
            this.disableDrawing(!0);
            var a = this.pencilButtonPushed;
            a && a.hide();
            a = this.eraserButtonPushed;
            if (this.eraseAll) {
                var a = this.trendLines,
                    b;
                for (b = a.length - 1; 0 <= b; b--) {
                    var c = a[b];
                    c.isProtected || this.removeTrendLine(c)
                }
                this.validateNow()
            } else(this.erasingEnabled = b = !this.erasingEnabled) ? (a && a.show(), this.setTrendColorHover(this.trendLineColorHover), this.setMouseCursor("auto")) : (a && a.hide(), this.setTrendColorHover())
        },
        setTrendColorHover: function(a) {
            var b = this.trendLines,
                c;
            for (c = b.length - 1; 0 <= c; c--) {
                var e = b[c];
                e.isProtected || (e.rollOverColor = a)
            }
        },
        handleDraw: function(a) {
            var b = this.drawOnAxis;
            d.isString(b) && (b = this.getValueAxisById(b));
            b || (b = this.valueAxes[0]);
            this.drawOnAxis = b;
            var c = this.categoryAxis,
                e = a.initialX,
                h = a.finalX,
                l = a.initialY;
            a = a.finalY;
            var k = new d.TrendLine(this.theme);
            k.initialDate = c.coordinateToDate(e);
            k.finalDate = c.coordinateToDate(h);
            k.initialValue = b.coordinateToValue(l);
            k.finalValue = b.coordinateToValue(a);
            k.lineAlpha = this.trendLineAlpha;
            k.lineColor = this.trendLineColor;
            k.lineThickness = this.trendLineThickness;
            k.dashLength = this.trendLineDashLength;
            k.valueAxis = b;
            k.categoryAxis = c;
            this.addTrendLine(k);
            this.listenTo(k, "click", this.handleTrendClick);
            this.validateNow()
        },
        hideDrawingIcons: function(a) {
            (this.hideIcons = a) && this.disableDrawing(a)
        },
        handleTrendClick: function(a) {
            this.erasingEnabled && (a = a.trendLine, this.eraseAll || a.isProtected || this.removeTrendLine(a), this.validateNow())
        },
        handleWheelReal: function(a, b) {
            var c = this.scrollbarChart;
            if (!this.wheelBusy && c) {
                var e = 1;
                b && (e = -1);
                var c = c.chartScrollbar,
                    d = this.categoryAxis.minDuration();
                0 > a ? (e = this.startTime + e * d, d = this.endTime + 1 * d) : (e = this.startTime - e * d, d = this.endTime - 1 * d);
                e < this.firstTime && (e = this.firstTime);
                d > this.lastTime && (d = this.lastTime);
                e < d && c.timeZoom(e, d, !0)
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.CategoryAxesSettings = d.Class({
        construct: function(a) {
            this.cname = "CategoryAxesSettings";
            this.minPeriod = "DD";
            this.equalSpacing = !1;
            this.axisHeight = 28;
            this.tickLength = this.axisAlpha = 0;
            this.gridCount = 10;
            this.maxSeries = 150;
            this.groupToPeriods = "ss 10ss 30ss mm 10mm 30mm hh DD WW MM YYYY".split(" ");
            this.markPeriodChange = this.autoGridCount = !0;
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ChartCursorSettings = d.Class({
        construct: function(a) {
            this.cname = "ChartCursorSettings";
            this.enabled = !0;
            this.bulletsEnabled = this.valueBalloonsEnabled = !1;
            this.graphBulletSize = 1;
            this.onePanelOnly = !1;
            this.categoryBalloonDateFormats = [{
                period: "YYYY",
                format: "YYYY"
            }, {
                period: "MM",
                format: "MMM, YYYY"
            }, {
                period: "WW",
                format: "MMM DD, YYYY"
            }, {
                period: "DD",
                format: "MMM DD, YYYY"
            }, {
                period: "hh",
                format: "JJ:NN"
            }, {
                period: "mm",
                format: "JJ:NN"
            }, {
                period: "ss",
                format: "JJ:NN:SS"
            }, {
                period: "fff",
                format: "JJ:NN:SS"
            }];
            d.applyTheme(this, a, this.cname)
        },
        categoryBalloonDateFormat: function(a) {
            var b = this.categoryBalloonDateFormats,
                c, e;
            for (e = 0; e < b.length; e++) b[e].period == a && (c = b[e].format);
            return c
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ChartScrollbarSettings = d.Class({
        construct: function(a) {
            this.cname = "ChartScrollbarSettings";
            this.height = 40;
            this.enabled = !0;
            this.color = "#FFFFFF";
            this.updateOnReleaseOnly = this.autoGridCount = !0;
            this.hideResizeGrips = !1;
            this.position = "bottom";
            this.minDistance = 1;
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.LegendSettings = d.Class({
        construct: function(a) {
            this.cname = "LegendSettings";
            this.marginBottom = this.marginTop = 0;
            this.usePositiveNegativeOnPercentsOnly = !0;
            this.positiveValueColor = "#00CC00";
            this.negativeValueColor = "#CC0000";
            this.autoMargins = this.equalWidths = this.textClickEnabled = !1;
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.PanelsSettings = d.Class({
        construct: function(a) {
            this.cname = "PanelsSettings";
            this.marginBottom = this.marginTop = this.marginRight = this.marginLeft = 0;
            this.backgroundColor = "#FFFFFF";
            this.backgroundAlpha = 0;
            this.panelSpacing = 8;
            this.panEventsEnabled = !0;
            this.creditsPosition = "top-right";
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.StockEventsSettings = d.Class({
        construct: function(a) {
            this.cname = "StockEventsSettings";
            this.type = "sign";
            this.backgroundAlpha = 1;
            this.backgroundColor = "#DADADA";
            this.borderAlpha = 1;
            this.borderColor = "#888888";
            this.balloonColor = this.rollOverColor = "#CC0000";
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ValueAxesSettings = d.Class({
        construct: function(a) {
            this.cname = "ValueAxesSettings";
            this.tickLength = 0;
            this.showFirstLabel = this.autoGridCount = this.inside = !0;
            this.showLastLabel = !1;
            this.axisAlpha = 0;
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.getItemIndex = function(a, b) {
        var c = -1,
            e;
        for (e = 0; e < b.length; e++) a == b[e] && (c = e);
        return c
    };
    d.addBr = function(a) {
        a.appendChild(document.createElement("br"))
    };
    d.applyStyles = function(a, b) {
        if (b && a)
            for (var c in a) {
                var e = c,
                    d = b[e];
                if (void 0 !== d) try {
                    a[e] = d
                } catch (l) {}
            }
    };
    d.parseStockData = function(a, b, c, e, h) {
        var l = {},
            k = a.dataProvider,
            g = a.categoryField;
        if (g) {
            var m = d.getItemIndex(b, c),
                f = c.length,
                p, t = k.length,
                u, x = {};
            for (p = m; p < f; p++) u = c[p], l[u] = [];
            var y = {},
                n = a.fieldMappings,
                z = n.length;
            for (p = 0; p < t; p++) {
                var A = k[p],
                    B = A[g],
                    D = d.getDate(B, h, b),
                    D = B instanceof Date ? d.newDate(B, b) : h ? d.stringToDate(B, h) : new Date(B),
                    B = D.getTime(),
                    C = {};
                for (u = 0; u < z; u++) C[n[u].toField] = A[n[u].fromField];
                var r;
                for (r = m; r < f; r++) {
                    u = c[r];
                    var v = d.extractPeriod(u),
                        E = v.period,
                        G = v.count,
                        w, q;
                    if (r == m || B >= x[u] || !x[u]) {
                        y[u] = {};
                        y[u].amCategoryIdField = String(d.resetDateToMin(D, E, G, e).getTime());
                        var F;
                        for (F = 0; F < z; F++) v = n[F].toField, w = y[u], q = Number(C[v]), w[v + "Count"] = 0, isNaN(q) || (w[v + "Open"] = q, w[v + "Sum"] = q, w[v + "High"] = q, w[v + "AbsHigh"] = q, w[v + "Low"] = q, w[v + "Close"] = q, w[v + "Count"] = 1, w[v + "Average"] = q);
                        w.dataContext = A;
                        l[u].push(y[u]);
                        r > m && (v = d.newDate(D, b), v = d.changeDate(v, E, G, !0), v = d.resetDateToMin(v, E, G, e), x[u] = v.getTime());
                        if (r == m)
                            for (var H in A) A.hasOwnProperty(H) && (y[u][H] = A[H]);
                        y[u][g] = d.newDate(D, b)
                    } else
                        for (E = 0; E < z; E++) v = n[E].toField, w = y[u], p == t - 1 && (w[g] = d.newDate(D, b)), q = Number(C[v]), isNaN(q) || (isNaN(w[v + "Low"]) && (w[v + "Low"] = q), q < w[v + "Low"] && (w[v + "Low"] = q), isNaN(w[v + "High"]) && (w[v + "High"] = q), q > w[v + "High"] && (w[v + "High"] = q), isNaN(w[v + "AbsHigh"]) && (w[v + "AbsHigh"] = q), Math.abs(q) > w[v + "AbsHigh"] && (w[v + "AbsHigh"] = q), w[v + "Close"] = q, G = d.getDecimals(w[v + "Sum"]), F = d.getDecimals(q), isNaN(w[v + "Sum"]) && (w[v + "Sum"] = 0), w[v + "Sum"] += q, w[v + "Sum"] = d.roundTo(w[v + "Sum"], Math.max(G, F)), w[v + "Count"]++, w[v + "Average"] = w[v + "Sum"] / w[v + "Count"])
                }
            }
        }
        a.agregatedDataProviders = l
    };
    d.parseEvents = function(a, b, c, e, h, l) {
        var k = a.stockEvents,
            g = a.agregatedDataProviders,
            m = b.length,
            f, p, t, u, x, y, n, z, A;
        for (f = 0; f < m; f++) {
            y = b[f];
            x = y.graphs;
            t = x.length;
            var B;
            for (p = 0; p < t; p++) u = x[p], u.customBulletField = "amCustomBullet" + u.id + "_" + y.id, u.bulletConfigField = "amCustomBulletConfig" + u.id + "_" + y.id;
            for (A = 0; A < k.length; A++)
                if (n = k[A], B = n.graph, d.isString(B) && (B = d.getObjById(x, B))) n.graph = B
        }
        for (var D in g)
            if (g.hasOwnProperty(D)) {
                B = g[D];
                var C = d.extractPeriod(D),
                    r = B.length,
                    v;
                for (v = 0; v < r; v++) {
                    var E = B[v];
                    f = E[a.categoryField];
                    z = f instanceof Date;
                    l && !z && (f = d.stringToDate(f, l));
                    var G = f.getTime();
                    x = C.period;
                    A = C.count;
                    var w;
                    w = "fff" == x ? f.getTime() + 1 : d.resetDateToMin(d.changeDate(new Date(f), C.period, C.count), x, A, e).getTime();
                    for (f = 0; f < m; f++)
                        for (y = b[f], x = y.graphs, t = x.length, p = 0; p < t; p++) {
                            u = x[p];
                            var q = {};
                            q.eventDispatcher = h;
                            q.eventObjects = [];
                            q.letters = [];
                            q.descriptions = [];
                            q.shapes = [];
                            q.backgroundColors = [];
                            q.backgroundAlphas = [];
                            q.borderColors = [];
                            q.borderAlphas = [];
                            q.colors = [];
                            q.rollOverColors = [];
                            q.showOnAxis = [];
                            q.values = [];
                            q.showAts = [];
                            q.fontSizes = [];
                            q.showBullets = [];
                            for (A = 0; A < k.length; A++) {
                                n = k[A];
                                z = n.date instanceof Date;
                                l && !z && (n.date = d.stringToDate(n.date, l));
                                z = n.date.getTime();
                                var F = !1;
                                n.graph && (n.graph.showEventsOnComparedGraphs && n.graph.comparedGraphs[a.id] && (F = !0), (u == n.graph || F) && z >= G && z < w && (q.eventObjects.push(n), q.letters.push(n.text), q.descriptions.push(n.description), n.type ? q.shapes.push(n.type) : q.shapes.push(c.type), void 0 !== n.backgroundColor ? q.backgroundColors.push(n.backgroundColor) : q.backgroundColors.push(c.backgroundColor), isNaN(n.backgroundAlpha) ? q.backgroundAlphas.push(c.backgroundAlpha) : q.backgroundAlphas.push(n.backgroundAlpha), isNaN(n.borderAlpha) ? q.borderAlphas.push(c.borderAlpha) : q.borderAlphas.push(n.borderAlpha), void 0 !== n.borderColor ? q.borderColors.push(n.borderColor) : q.borderColors.push(c.borderColor), void 0 !== n.rollOverColor ? q.rollOverColors.push(n.rollOverColor) : q.rollOverColors.push(c.rollOverColor), void 0 !== n.showAt ? q.showAts.push(n.showAt) : q.showAts.push(c.showAt), void 0 !== n.fontSize && q.fontSizes.push(n.fontSize), q.colors.push(n.color), q.values.push(n.value), !n.panel && n.graph && (n.panel = n.graph.chart), q.showOnAxis.push(n.showOnAxis), q.showBullets.push(n.showBullet), q.date = new Date(n.date)));
                                0 < q.shapes.length && (n = "amCustomBullet" + u.id + "_" + y.id, z = "amCustomBulletConfig" + u.id + "_" + y.id, E[n] = d.StackedBullet, E[z] = q)
                            }
                        }
                }
            }
    }
})();
(function() {
    var d = window.AmCharts;
    d.StockLegend = d.Class({
        inherits: d.AmLegend,
        construct: function(a) {
            d.StockLegend.base.construct.call(this, a);
            this.cname = "StockLegend";
            this.valueTextComparing = "[[percents.value]]%";
            this.valueTextRegular = "[[value]]";
            d.applyTheme(this, a, this.cname)
        },
        drawLegend: function() {
            var a = this;
            d.StockLegend.base.drawLegend.call(a);
            var b = a.chart;
            if (b.allowTurningOff) {
                var c = a.container,
                    e = c.image(b.pathToImages + "xIcon" + b.extension, b.realWidth - 19, 3, 19, 19),
                    b = c.image(b.pathToImages + "xIconH" +
                        b.extension, b.realWidth - 19, 3, 19, 19);
                b.hide();
                a.xButtonHover = b;
                e.mouseup(function() {
                    a.handleXClick()
                }).mouseover(function() {
                    a.handleXOver()
                });
                b.mouseup(function() {
                    a.handleXClick()
                }).mouseout(function() {
                    a.handleXOut()
                })
            }
        },
        handleXOver: function() {
            this.xButtonHover.show()
        },
        handleXOut: function() {
            this.xButtonHover.hide()
        },
        handleXClick: function() {
            var a = this.chart,
                b = a.stockChart;
            b.removePanel(a);
            b.validateNow()
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.DataSetSelector = d.Class({
        construct: function(a) {
            this.cname = "DataSetSelector";
            this.theme = a;
            this.createEvents("dataSetSelected", "dataSetCompared", "dataSetUncompared");
            this.position = "left";
            this.selectText = "Select:";
            this.comboBoxSelectText = "Select...";
            this.compareText = "Compare to:";
            this.width = 180;
            this.dataProvider = [];
            this.listHeight = 150;
            this.listCheckBoxSize = 14;
            this.rollOverBackgroundColor = "#b2e1ff";
            this.selectedBackgroundColor = "#7fceff";
            d.applyTheme(this, a, this.cname)
        },
        write: function(a) {
            var b = this,
                c, e = b.theme,
                h = b.chart;
            a.className = "amChartsDataSetSelector " + h.classNamePrefix + "-data-set-selector-div";
            var l = b.width;
            c = b.position;
            b.width = void 0;
            b.position = void 0;
            d.applyStyles(a.style, b);
            b.div = a;
            b.width = l;
            b.position = c;
            a.innerHTML = "";
            var l = b.position,
                k;
            k = "top" == l || "bottom" == l ? !1 : !0;
            b.vertical = k;
            var g;
            k && (g = b.width + "px");
            var l = b.dataProvider,
                m, f;
            if (1 < b.countDataSets("showInSelect")) {
                c = document.createTextNode(d.lang.selectText || b.selectText);
                a.appendChild(c);
                k && d.addBr(a);
                var p = document.createElement("select");
                g && (p.style.width = g);
                b.selectCB = p;
                e && d.applyStyles(p.style, e.DataSetSelect);
                p.className = h.classNamePrefix + "-data-set-select";
                a.appendChild(p);
                d.isNN && p.addEventListener("change", function(a) {
                    b.handleDataSetChange.call(b, a)
                }, !0);
                d.isIE && p.attachEvent("onchange", function(a) {
                    b.handleDataSetChange.call(b, a)
                });
                for (c = 0; c < l.length; c++)
                    if (m = l[c], !0 === m.showInSelect) {
                        f = document.createElement("option");
                        f.className = h.classNamePrefix + "-data-set-select-option";
                        f.text = m.title;
                        f.value = c;
                        m == b.chart.mainDataSet && (f.selected = !0);
                        try {
                            p.add(f, null)
                        } catch (t) {
                            p.add(f)
                        }
                    }
                b.offsetHeight = p.offsetHeight
            }
            if (0 < b.countDataSets("showInCompare") && 1 < l.length)
                if (k ? (d.addBr(a), d.addBr(a)) : (c = document.createTextNode(" "), a.appendChild(c)), c = document.createTextNode(d.lang.compareText || b.compareText), a.appendChild(c), f = b.listCheckBoxSize, k) {
                    d.addBr(a);
                    g = document.createElement("div");
                    a.appendChild(g);
                    g.className = "amChartsCompareList " + h.classNamePrefix + "-compare-div";
                    e && d.applyStyles(g.style, e.DataSetCompareList);
                    g.style.overflow = "auto";
                    g.style.overflowX = "hidden";
                    g.style.width = b.width - 2 + "px";
                    g.style.maxHeight = b.listHeight + "px";
                    for (c = 0; c < l.length; c++) m = l[c], !0 === m.showInCompare && m != b.chart.mainDataSet && (e = document.createElement("div"), e.style.padding = "4px", e.style.position = "relative", e.name = "amCBContainer", e.className = h.classNamePrefix + "-compare-item-div", e.dataSet = m, e.style.height = f + "px", m.compared && (e.style.backgroundColor = b.selectedBackgroundColor), g.appendChild(e), k = document.createElement("div"), k.style.width = f + "px", k.style.height = f + "px", k.style.position = "absolute", k.style.backgroundColor = m.color, e.appendChild(k), k = document.createElement("div"), k.style.width = "100%", k.style.position = "absolute", k.style.left = f + 10 + "px", e.appendChild(k), m = document.createTextNode(m.title), k.style.whiteSpace = "nowrap", k.style.cursor = "default", k.appendChild(m), b.addEventListeners(e));
                    d.addBr(a);
                    d.addBr(a)
                } else {
                    h = document.createElement("select");
                    b.compareCB = h;
                    g && (h.style.width = g);
                    a.appendChild(h);
                    d.isNN && h.addEventListener("change", function(a) {
                        b.handleCBSelect.call(b, a)
                    }, !0);
                    d.isIE && h.attachEvent("onchange", function(a) {
                        b.handleCBSelect.call(b, a)
                    });
                    f = document.createElement("option");
                    f.text = d.lang.comboBoxSelectText || b.comboBoxSelectText;
                    try {
                        h.add(f, null)
                    } catch (u) {
                        h.add(f)
                    }
                    for (c = 0; c < l.length; c++)
                        if (m = l[c], !0 === m.showInCompare && m != b.chart.mainDataSet) {
                            f = document.createElement("option");
                            f.text = m.title;
                            f.value = c;
                            m.compared && (f.selected = !0);
                            try {
                                h.add(f, null)
                            } catch (x) {
                                h.add(f)
                            }
                        }
                    b.offsetHeight = h.offsetHeight
                }
        },
        addEventListeners: function(a) {
            var b = this;
            d.isNN && (a.addEventListener("mouseover", function(a) {
                b.handleRollOver.call(b, a)
            }, !0), a.addEventListener("mouseout", function(a) {
                b.handleRollOut.call(b, a)
            }, !0), a.addEventListener("click", function(a) {
                b.handleClick.call(b, a)
            }, !0));
            d.isIE && (a.attachEvent("onmouseout", function(a) {
                b.handleRollOut.call(b, a)
            }), a.attachEvent("onmouseover", function(a) {
                b.handleRollOver.call(b, a)
            }), a.attachEvent("onclick", function(a) {
                b.handleClick.call(b, a)
            }))
        },
        handleDataSetChange: function() {
            var a = this.selectCB,
                a = this.dataProvider[a.options[a.selectedIndex].value],
                b = this.chart;
            b.mainDataSet = a;
            b.zoomOutOnDataSetChange && (b.startDate = void 0, b.endDate = void 0);
            b.validateData();
            a = {
                type: "dataSetSelected",
                dataSet: a,
                chart: this.chart
            };
            this.fire(a.type, a)
        },
        handleRollOver: function(a) {
            a = this.getRealDiv(a);
            a.dataSet.compared || (a.style.backgroundColor = this.rollOverBackgroundColor)
        },
        handleRollOut: function(a) {
            a = this.getRealDiv(a);
            a.dataSet.compared || (a.style.removeProperty && a.style.removeProperty("background-color"), a.style.removeAttribute && a.style.removeAttribute("backgroundColor"))
        },
        handleCBSelect: function(a) {
            var b = this.compareCB,
                c = this.dataProvider,
                e, d;
            for (e = 0; e < c.length; e++) d = c[e], d.compared && (a = {
                type: "dataSetUncompared",
                dataSet: d
            }), d.compared = !1;
            c = b.selectedIndex;
            0 < c && (d = this.dataProvider[b.options[c].value], d.compared || (a = {
                type: "dataSetCompared",
                dataSet: d
            }), d.compared = !0);
            b = this.chart;
            b.validateData();
            a.chart = b;
            this.fire(a.type, a)
        },
        handleClick: function(a) {
            a = this.getRealDiv(a).dataSet;
            !0 === a.compared ? (a.compared = !1, a = {
                type: "dataSetUncompared",
                dataSet: a
            }) : (a.compared = !0, a = {
                type: "dataSetCompared",
                dataSet: a
            });
            var b = this.chart;
            b.validateData();
            a.chart = b;
            this.fire(a.type, a)
        },
        getRealDiv: function(a) {
            a || (a = window.event);
            a = a.currentTarget ? a.currentTarget : a.srcElement;
            "amCBContainer" == a.parentNode.name && (a = a.parentNode);
            return a
        },
        countDataSets: function(a) {
            var b = this.dataProvider,
                c = 0,
                d;
            for (d = 0; d < b.length; d++) !0 === b[d][a] && c++;
            return c
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.StackedBullet = d.Class({
        construct: function() {
            this.stackDown = !1;
            this.mastHeight = 8;
            this.shapes = [];
            this.backgroundColors = [];
            this.backgroundAlphas = [];
            this.borderAlphas = [];
            this.borderColors = [];
            this.colors = [];
            this.rollOverColors = [];
            this.showOnAxiss = [];
            this.values = [];
            this.showAts = [];
            this.textColor = "#000000";
            this.nextY = 0;
            this.size = 16
        },
        parseConfig: function() {
            var a = this.bulletConfig;
            this.eventObjects = a.eventObjects;
            this.letters = a.letters;
            this.shapes = a.shapes;
            this.backgroundColors = a.backgroundColors;
            this.backgroundAlphas = a.backgroundAlphas;
            this.borderColors = a.borderColors;
            this.borderAlphas = a.borderAlphas;
            this.colors = a.colors;
            this.rollOverColors = a.rollOverColors;
            this.date = a.date;
            this.showOnAxiss = a.showOnAxis;
            this.axisCoordinate = a.minCoord;
            this.showAts = a.showAts;
            this.values = a.values;
            this.fontSizes = a.fontSizes;
            this.showBullets = a.showBullets
        },
        write: function(a) {
            this.parseConfig();
            this.container = a;
            this.bullets = [];
            this.fontSize = this.chart.fontSize;
            if (this.graph) {
                var b = this.graph.fontSize;
                b && (this.fontSize = b)
            }
            b = this.letters.length;
            (this.mastHeight + 2 * (this.fontSize / 2 + 2)) * b > this.availableSpace && (this.stackDown = !0);
            this.set = a.set();
            this.cset = a.set();
            this.set.push(this.cset);
            a = 0;
            var c;
            for (c = 0; c < b; c++) {
                this.shape = this.shapes[c];
                this.backgroundColor = this.backgroundColors[c];
                this.backgroundAlpha = this.backgroundAlphas[c];
                this.borderAlpha = this.borderAlphas[c];
                this.borderColor = this.borderColors[c];
                this.rollOverColor = this.rollOverColors[c];
                this.showOnAxis = this.showOnAxiss[c];
                this.showBullet = this.showBullets[c];
                this.color = this.colors[c];
                this.value = this.values[c];
                this.showAt = this.showAts[c];
                var d = this.fontSizes[c];
                isNaN(d) || (this.fontSize = d);
                this.addLetter(this.letters[c], a, c);
                this.showOnAxis || a++
            }
        },
        addLetter: function(a, b, c) {
            var e = this.container;
            b = e.set();
            var h = -1,
                l = this.stackDown,
                k = this.graph.valueAxis;
            this.showOnAxis && (this.stackDown = k.reversed ? !0 : !1);
            this.stackDown && (h = 1);
            var g = 0,
                m = 0,
                f = 0,
                p, t = this.fontSize,
                u = this.mastHeight,
                x = this.shape,
                y = this.textColor;
            void 0 !== this.color && (y = this.color);
            void 0 === a && (a = "");
            a = d.fixBrakes(a);
            a = d.text(e, a, y, this.chart.fontFamily, this.fontSize);
            a.node.style.pointerEvents = "none";
            e = a.getBBox();
            this.labelWidth = y = e.width;
            this.labelHeight = e.height;
            var n, e = 0;
            switch (x) {
                case "sign":
                    n = this.drawSign(b);
                    g = u + 4 + t / 2;
                    e = u + t + 4;
                    1 == h && (g -= 4);
                    break;
                case "flag":
                    n = this.drawFlag(b);
                    m = y / 2 + 3;
                    g = u + 4 + t / 2;
                    e = u + t + 4;
                    1 == h && (g -= 4);
                    break;
                case "pin":
                    n = this.drawPin(b);
                    g = 6 + t / 2;
                    e = t + 8;
                    break;
                case "triangleUp":
                    n = this.drawTriangleUp(b);
                    g = -t - 1;
                    e = t + 4;
                    h = -1;
                    break;
                case "triangleDown":
                    n = this.drawTriangleDown(b);
                    g = t + 1;
                    e = t + 4;
                    h = -1;
                    break;
                case "triangleLeft":
                    n = this.drawTriangleLeft(b);
                    m = t;
                    e = t + 4;
                    h = -1;
                    break;
                case "triangleRight":
                    n = this.drawTriangleRight(b);
                    m = -t;
                    h = -1;
                    e = t + 4;
                    break;
                case "arrowUp":
                    n = this.drawArrowUp(b);
                    a.hide();
                    break;
                case "arrowDown":
                    n = this.drawArrowDown(b);
                    a.hide();
                    e = t + 4;
                    break;
                case "text":
                    h = -1;
                    n = this.drawTextBackground(b, a);
                    g = this.labelHeight + 3;
                    e = t + 10;
                    break;
                case "round":
                    n = this.drawCircle(b)
            }
            this.bullets[c] = n;
            this.showOnAxis ? (p = isNaN(this.nextAxisY) ? this.axisCoordinate : this.nextY, f = g * h, this.nextAxisY = p + h * e) : this.value ? (p = this.value, k.recalculateToPercents && (p = p / k.recBaseValue * 100 - 100), p = k.getCoordinate(p) - this.bulletY, f = g * h) : this.showAt ? (n = this.graphDataItem.values, k.recalculateToPercents && (n = this.graphDataItem.percents), n && (p = k.getCoordinate(n[this.showAt]) - this.bulletY, f = g * h)) : (p = this.nextY, f = g * h);
            a.translate(m, f);
            b.push(a);
            b.translate(0, p);
            this.addEventListeners(b, c);
            this.nextY = p + h * e;
            this.stackDown = l
        },
        addEventListeners: function(a, b) {
            var c = this;
            a.click(function() {
                c.handleClick(b)
            }).mouseover(function() {
                c.handleMouseOver(b)
            }).touchend(function() {
                c.handleMouseOver(b, !0);
                c.handleClick(b)
            }).mouseout(function() {
                c.handleMouseOut(b)
            })
        },
        drawPin: function(a) {
            var b = -1;
            this.stackDown && (b = 1);
            var c = this.fontSize + 4;
            return this.drawRealPolygon(a, [0, c / 2, c / 2, -c / 2, -c / 2, 0], [0, b * c / 4, b * (c + c / 4), b * (c + c / 4), b * c / 4, 0])
        },
        drawSign: function(a) {
            var b = -1;
            this.stackDown && (b = 1);
            var c = this.mastHeight * b,
                e = this.fontSize / 2 + 2,
                h = d.line(this.container, [0, 0], [0, c], this.borderColor, this.borderAlpha, 1),
                l = d.circle(this.container, e, this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
            l.translate(0, c + e * b);
            a.push(h);
            a.push(l);
            this.cset.push(a);
            return l
        },
        drawFlag: function(a) {
            var b = -1;
            this.stackDown && (b = 1);
            var c = this.fontSize + 4,
                e = this.labelWidth + 6,
                h = this.mastHeight,
                b = 1 == b ? b * h : b * h - c,
                h = d.line(this.container, [0, 0], [0, b], this.borderColor, this.borderAlpha, 1),
                c = d.polygon(this.container, [0, e, e, 0], [0, 0, c, c], this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
            c.translate(0, b);
            a.push(h);
            a.push(c);
            this.cset.push(a);
            return c
        },
        drawTriangleUp: function(a) {
            var b = this.fontSize +
                7;
            return this.drawRealPolygon(a, [0, b / 2, -b / 2, 0], [0, b, b, 0])
        },
        drawArrowUp: function(a) {
            var b = this.size,
                c = b / 2,
                d = b / 4;
            return this.drawRealPolygon(a, [0, c, d, d, -d, -d, -c, 0], [0, c, c, b, b, c, c, 0])
        },
        drawArrowDown: function(a) {
            var b = this.size,
                c = b / 2,
                d = b / 4;
            return this.drawRealPolygon(a, [0, c, d, d, -d, -d, -c, 0], [0, -c, -c, -b, -b, -c, -c, 0])
        },
        drawTriangleDown: function(a) {
            var b = this.fontSize + 7;
            return this.drawRealPolygon(a, [0, b / 2, -b / 2, 0], [0, -b, -b, 0])
        },
        drawTriangleLeft: function(a) {
            var b = this.fontSize + 7;
            return this.drawRealPolygon(a, [0, b, b, 0], [0, -b / 2, b / 2])
        },
        drawTriangleRight: function(a) {
            var b = this.fontSize + 7;
            return this.drawRealPolygon(a, [0, -b, -b, 0], [0, -b / 2, b / 2, 0])
        },
        drawRealPolygon: function(a, b, c) {
            b = d.polygon(this.container, b, c, this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
            a.push(b);
            this.cset.push(a);
            return b
        },
        drawCircle: function(a) {
            var b = d.circle(this.container, this.fontSize / 2, this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
            a.push(b);
            this.cset.push(a);
            return b
        },
        drawTextBackground: function(a, b) {
            var c = b.getBBox(),
                d = -c.width / 2 - 5,
                h = c.width / 2 + 5,
                c = -c.height - 12;
            return this.drawRealPolygon(a, [d, -5, 0, 5, h, h, d, d], [-5, -5, 0, -5, -5, c, c, -5])
        },
        handleMouseOver: function(a, b) {
            b || this.bullets[a].attr({
                fill: this.rollOverColors[a]
            });
            var c = this.eventObjects[a],
                e = {
                    type: "rollOverStockEvent",
                    eventObject: c,
                    graph: this.graph,
                    date: this.date
                },
                h = this.bulletConfig.eventDispatcher;
            e.chart = h;
            h.fire(e.type, e);
            c.url && this.bullets[a].setAttr("cursor", "pointer");
            this.chart.showBalloon(d.fixNewLines(c.description), h.stockEventsSettings.balloonColor, !0)
        },
        handleClick: function(a) {
            a = this.eventObjects[a];
            var b = {
                    type: "clickStockEvent",
                    eventObject: a,
                    graph: this.graph,
                    date: this.date
                },
                c = this.bulletConfig.eventDispatcher;
            b.chart = c;
            c.fire(b.type, b);
            b = a.urlTarget;
            b || (b = c.stockEventsSettings.urlTarget);
            d.getURL(a.url, b)
        },
        handleMouseOut: function(a) {
            this.bullets[a].attr({
                fill: this.backgroundColors[a]
            });
            a = {
                type: "rollOutStockEvent",
                eventObject: this.eventObjects[a],
                graph: this.graph,
                date: this.date
            };
            var b = this.bulletConfig.eventDispatcher;
            a.chart = b;
            b.fire(a.type, a)
        }
    })
})();;;;
(function() {
    var e = window.AmCharts;
    e.AmXYChart = e.Class({
        inherits: e.AmRectangularChart,
        construct: function(a) {
            this.type = "xy";
            e.AmXYChart.base.construct.call(this, a);
            this.cname = "AmXYChart";
            this.theme = a;
            this.createEvents("zoomed");
            this.maxZoomFactor = 20;
            e.applyTheme(this, a, this.cname)
        },
        initChart: function() {
            e.AmXYChart.base.initChart.call(this);
            this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);
            this.updateScrollbar = !0;
            this.drawChart();
            this.autoMargins && !this.marginsUpdated && (this.marginsUpdated = !0, this.measureMargins());
            var a = this.marginLeftReal,
                c = this.marginTopReal,
                b = this.plotAreaWidth,
                d = this.plotAreaHeight;
            this.graphsSet.clipRect(a, c, b, d);
            this.bulletSet.clipRect(a, c, b, d);
            this.trendLinesSet.clipRect(a, c, b, d)
        },
        prepareForExport: function() {
            var a = this.bulletSet;
            a.clipPath && this.container.remove(a.clipPath)
        },
        createValueAxes: function() {
            var a = [],
                c = [];
            this.xAxes = a;
            this.yAxes = c;
            var b = this.valueAxes,
                d, f;
            for (f = 0; f < b.length; f++) {
                d = b[f];
                var k = d.position;
                if ("top" == k || "bottom" == k) d.rotate = !0;
                d.setOrientation(d.rotate);
                k = d.orientation;
                "V" == k && c.push(d);
                "H" == k && a.push(d)
            }
            0 === c.length && (d = new e.ValueAxis(this.theme), d.rotate = !1, d.setOrientation(!1), b.push(d), c.push(d));
            0 === a.length && (d = new e.ValueAxis(this.theme), d.rotate = !0, d.setOrientation(!0), b.push(d), a.push(d));
            for (f = 0; f < b.length; f++) this.processValueAxis(b[f], f);
            a = this.graphs;
            for (f = 0; f < a.length; f++) this.processGraph(a[f], f)
        },
        drawChart: function() {
            e.AmXYChart.base.drawChart.call(this);
            e.ifArray(this.chartData) ? (this.chartScrollbar && this.updateScrollbars(), this.selfZoom && (this.horizontalPosition = this.horizontalPosition * this.plotAreaWidth / this.prevPlotAreaWidth, this.verticalPosition = this.verticalPosition * this.plotAreaHeight / this.prevPlotAreaHeight, this.selfZoom = !1), this.zoomChart()) : this.cleanChart();
            if (this.hideXScrollbar) {
                var a = this.scrollbarH;
                a && (this.removeListener(a, "zoomed", this.handleHSBZoom), a.destroy());
                this.scrollbarH = null
            }
            if (this.hideYScrollbar) {
                if (a = this.scrollbarV) this.removeListener(a, "zoomed", this.handleVSBZoom), a.destroy();
                this.scrollbarV = null
            }
            if (!this.autoMargins || this.marginsUpdated) this.dispDUpd(), this.chartCreated = !0, this.zoomScrollbars()
        },
        cleanChart: function() {
            e.callMethod("destroy", [this.valueAxes, this.graphs, this.scrollbarV, this.scrollbarH, this.chartCursor])
        },
        zoomChart: function() {
            this.toggleZoomOutButton();
            this.zoomObjects(this.valueAxes);
            this.zoomObjects(this.graphs);
            this.zoomTrendLines();
            this.dispatchAxisZoom();
            this.prevPlotAreaWidth = this.plotAreaWidth;
            this.prevPlotAreaHeight = this.plotAreaHeight
        },
        toggleZoomOutButton: function() {
            1 == this.heightMultiplier && 1 == this.widthMultiplier ? this.showZB(!1) : this.showZB(!0)
        },
        dispatchAxisZoom: function() {
            var a = this.valueAxes,
                c;
            for (c = 0; c < a.length; c++) {
                var b = a[c];
                if (!isNaN(b.min) && !isNaN(b.max)) {
                    var d, f;
                    "V" == b.orientation ? (d = b.coordinateToValue(-this.verticalPosition), f = b.coordinateToValue(-this.verticalPosition + this.plotAreaHeight)) : (d = b.coordinateToValue(-this.horizontalPosition), f = b.coordinateToValue(-this.horizontalPosition + this.plotAreaWidth));
                    if (!isNaN(d) && !isNaN(f)) {
                        if (d > f) {
                            var e = f;
                            f = d;
                            d = e
                        }
                        b.dispatchZoomEvent(d, f)
                    }
                }
            }
        },
        zoomObjects: function(a) {
            var c = a.length,
                b, d;
            for (b = 0; b < c; b++) d = a[b], d.minTemp = d.min, d.maxTemp = d.max, this.updateObjectSize(d), d.zoom(0, this.chartData.length - 1), d.minTemp = NaN, d.maxTemp = NaN
        },
        updateData: function() {
            this.parseData();
            var a = this.chartData,
                c = a.length - 1,
                b = this.graphs,
                d = this.dataProvider,
                e = -Infinity,
                k = Infinity,
                h, l;
            for (h = 0; h < b.length; h++)
                if (l = b[h], l.data = a, l.zoom(0, c), l = l.valueField) {
                    var n;
                    for (n = 0; n < d.length; n++)
                        if (null !== p) {
                            var p = Number(d[n][l]);
                            p > e && (e = p);
                            p < k && (k = p)
                        }
                }
            for (h = 0; h < b.length; h++) l = b[h], l.maxValue = e, l.minValue = k;
            if (a = this.chartCursor) a.updateData(), a.type = "crosshair", a.valueBalloonsEnabled = !1
        },
        zoomOut: function() {
            this.verticalPosition = this.horizontalPosition = 0;
            this.heightMultiplier = this.widthMultiplier = 1;
            this.zoomChart();
            this.zoomScrollbars()
        },
        processValueAxis: function(a) {
            a.chart = this;
            a.minMaxField = "H" == a.orientation ? "x" : "y";
            a.min = NaN;
            a.max = NaN;
            this.listenTo(a, "axisSelfZoomed", this.handleAxisSelfZoom)
        },
        processGraph: function(a) {
            e.isString(a.xAxis) && (a.xAxis = this.getValueAxisById(a.xAxis));
            e.isString(a.yAxis) && (a.yAxis = this.getValueAxisById(a.yAxis));
            a.xAxis || (a.xAxis = this.xAxes[0]);
            a.yAxis || (a.yAxis = this.yAxes[0]);
            a.valueAxis = a.yAxis
        },
        parseData: function() {
            e.AmXYChart.base.parseData.call(this);
            this.chartData = [];
            var a = this.dataProvider,
                c = this.valueAxes,
                b = this.graphs,
                d;
            if (a)
                for (d = 0; d < a.length; d++) {
                    var f = {
                            axes: {},
                            x: {},
                            y: {}
                        },
                        k = this.dataDateFormat,
                        h = a[d],
                        l;
                    for (l = 0; l < c.length; l++) {
                        var n = c[l].id;
                        f.axes[n] = {};
                        f.axes[n].graphs = {};
                        var p;
                        for (p = 0; p < b.length; p++) {
                            var m = b[p],
                                t = m.id;
                            if (m.xAxis.id == n || m.yAxis.id == n) {
                                var q = {};
                                q.serialDataItem = f;
                                q.index = d;
                                var r = {},
                                    g = h[m.valueField];
                                null !== g && (g = Number(g), isNaN(g) || (r.value = g));
                                g = h[m.xField];
                                null !== g && ("date" == m.xAxis.type && (g = e.getDate(h[m.xField], k).getTime()), g = Number(g), isNaN(g) || (r.x = g));
                                g = h[m.yField];
                                null !== g && ("date" == m.yAxis.type && (g = e.getDate(h[m.yField], k).getTime()), g = Number(g), isNaN(g) || (r.y = g));
                                g = h[m.errorField];
                                null !== g && (g = Number(g), isNaN(g) || (r.error = g));
                                q.values = r;
                                this.processFields(m, q, h);
                                q.serialDataItem = f;
                                q.graph = m;
                                f.axes[n].graphs[t] = q
                            }
                        }
                    }
                    this.chartData[d] = f
                }
        },
        formatString: function(a, c, b) {
            var d = c.graph,
                f = d.numberFormatter;
            f || (f = this.nf);
            var k, h;
            "date" == c.graph.xAxis.type && (k = e.formatDate(new Date(c.values.x), d.dateFormat, this), h = RegExp("\\[\\[x\\]\\]", "g"), a = a.replace(h, k));
            "date" == c.graph.yAxis.type && (k = e.formatDate(new Date(c.values.y), d.dateFormat, this), h = RegExp("\\[\\[y\\]\\]", "g"), a = a.replace(h, k));
            a = e.formatValue(a, c.values, ["value", "x", "y"], f); - 1 != a.indexOf("[[") && (a = e.formatDataContextValue(a, c.dataContext));
            return a = e.AmXYChart.base.formatString.call(this, a, c, b)
        },
        addChartScrollbar: function(a) {
            e.callMethod("destroy", [this.chartScrollbar, this.scrollbarH, this.scrollbarV]);
            if (a) {
                this.chartScrollbar = a;
                this.scrollbarHeight = a.scrollbarHeight;
                var c = "backgroundColor backgroundAlpha selectedBackgroundColor selectedBackgroundAlpha scrollDuration resizeEnabled hideResizeGrips scrollbarHeight updateOnReleaseOnly".split(" ");
                if (!this.hideYScrollbar) {
                    var b = new e.SimpleChartScrollbar(this.theme);
                    b.skipEvent = !0;
                    b.chart = this;
                    this.listenTo(b, "zoomed", this.handleVSBZoom);
                    e.copyProperties(a, b, c);
                    b.rotate = !0;
                    this.scrollbarV = b
                }
                this.hideXScrollbar || (b = new e.SimpleChartScrollbar(this.theme), b.skipEvent = !0, b.chart = this, this.listenTo(b, "zoomed", this.handleHSBZoom), e.copyProperties(a, b, c), b.rotate = !1, this.scrollbarH = b)
            }
        },
        updateTrendLines: function() {
            var a = this.trendLines,
                c;
            for (c = 0; c < a.length; c++) {
                var b = a[c],
                    b = e.processObject(b, e.TrendLine, this.theme);
                a[c] = b;
                b.chart = this;
                var d = b.valueAxis;
                e.isString(d) && (b.valueAxis = this.getValueAxisById(d));
                d = b.valueAxisX;
                e.isString(d) && (b.valueAxisX = this.getValueAxisById(d));
                b.id || (b.id = "trendLineAuto" + c + "_" + (new Date).getTime());
                b.valueAxis || (b.valueAxis = this.yAxes[0]);
                b.valueAxisX || (b.valueAxisX = this.xAxes[0])
            }
        },
        updateMargins: function() {
            e.AmXYChart.base.updateMargins.call(this);
            var a = this.scrollbarV;
            a && (this.getScrollbarPosition(a, !0, this.yAxes[0].position), this.adjustMargins(a, !0));
            if (a = this.scrollbarH) this.getScrollbarPosition(a, !1, this.xAxes[0].position), this.adjustMargins(a, !1)
        },
        updateScrollbars: function() {
            e.AmXYChart.base.updateScrollbars.call(this);
            var a = this.scrollbarV;
            a && (this.updateChartScrollbar(a, !0), a.draw());
            if (a = this.scrollbarH) this.updateChartScrollbar(a, !1), a.draw()
        },
        zoomScrollbars: function() {
            var a = this.scrollbarH;
            a && a.relativeZoom(this.widthMultiplier, -this.horizontalPosition / this.widthMultiplier);
            (a = this.scrollbarV) && a.relativeZoom(this.heightMultiplier, -this.verticalPosition / this.heightMultiplier)
        },
        fitMultiplier: function(a) {
            a > this.maxZoomFactor && (a = this.maxZoomFactor);
            return a
        },
        fitH: function(a, c) {
            var b = -(this.plotAreaWidth * c - this.plotAreaWidth);
            a < b && (a = b);
            this.horizontalPosition = a
        },
        fitV: function(a, c) {
            var b = -(this.plotAreaHeight * c - this.plotAreaHeight);
            a < b && (a = b);
            this.verticalPosition = a
        },
        handleHSBZoom: function(a) {
            var c = this.fitMultiplier(a.multiplier);
            this.fitH(-a.position * c, c);
            this.widthMultiplier = c;
            this.zoomChart()
        },
        handleVSBZoom: function(a) {
            var c = this.fitMultiplier(a.multiplier);
            this.fitV(-a.position * c, c);
            this.heightMultiplier = c;
            this.zoomChart()
        },
        handleAxisSelfZoom: function(a) {
            if ("H" == a.valueAxis.orientation) {
                var c = this.fitMultiplier(a.multiplier);
                this.fitH(-a.position * c, c);
                this.widthMultiplier = c
            } else c = this.fitMultiplier(a.multiplier), this.fitV(-a.position * c, c), this.heightMultiplier = c;
            this.zoomChart();
            a = this.graphs;
            for (c = 0; c < a.length; c++) a[c].setAnimationPlayed();
            this.zoomScrollbars()
        },
        handleCursorZoom: function(a) {
            var c = this.widthMultiplier * this.plotAreaWidth / a.selectionWidth,
                b = this.heightMultiplier * this.plotAreaHeight / a.selectionHeight,
                c = this.fitMultiplier(c),
                b = this.fitMultiplier(b),
                d = (this.verticalPosition - a.selectionY) * b / this.heightMultiplier;
            this.fitH((this.horizontalPosition - a.selectionX) * c / this.widthMultiplier, c);
            this.fitV(d, b);
            this.widthMultiplier = c;
            this.heightMultiplier = b;
            this.zoomChart();
            this.zoomScrollbars()
        },
        removeChartScrollbar: function() {
            e.callMethod("destroy", [this.scrollbarH, this.scrollbarV]);
            this.scrollbarV = this.scrollbarH = null
        },
        handleReleaseOutside: function(a) {
            e.AmXYChart.base.handleReleaseOutside.call(this, a);
            e.callMethod("handleReleaseOutside", [this.scrollbarH, this.scrollbarV])
        },
        update: function() {
            e.AmXYChart.base.update.call(this);
            this.scrollbarH && this.scrollbarH.update && this.scrollbarH.update();
            this.scrollbarV && this.scrollbarV.update && this.scrollbarV.update()
        }
    })
})();;;;
(function() {
    var l = window.AmCharts;
    l.AmPieChart = l.Class({
        inherits: l.AmSlicedChart,
        construct: function(d) {
            this.type = "pie";
            l.AmPieChart.base.construct.call(this, d);
            this.cname = "AmPieChart";
            this.pieBrightnessStep = 30;
            this.minRadius = 10;
            this.depth3D = 0;
            this.startAngle = 90;
            this.angle = this.innerRadius = 0;
            this.startRadius = "500%";
            this.pullOutRadius = "20%";
            this.labelRadius = 20;
            this.labelText = "[[title]]: [[percents]]%";
            this.balloonText = "[[title]]: [[percents]]% ([[value]])\n[[description]]";
            this.previousScale = 1;
            this.adjustPrecision = !1;
            l.applyTheme(this, d, this.cname)
        },
        drawChart: function() {
            l.AmPieChart.base.drawChart.call(this);
            var d = this.chartData;
            if (l.ifArray(d)) {
                if (0 < this.realWidth && 0 < this.realHeight) {
                    l.VML && (this.startAlpha = 1);
                    var g = this.startDuration,
                        c = this.container,
                        b = this.updateWidth();
                    this.realWidth = b;
                    var n = this.updateHeight();
                    this.realHeight = n;
                    var e = l.toCoordinate,
                        f = e(this.marginLeft, b),
                        a = e(this.marginRight, b),
                        v = e(this.marginTop, n) + this.getTitleHeight(),
                        m = e(this.marginBottom, n),
                        A, B, k, y = l.toNumber(this.labelRadius),
                        p = this.measureMaxLabel();
                    p > this.maxLabelWidth && (p = this.maxLabelWidth);
                    this.labelText && this.labelsEnabled || (y = p = 0);
                    A = void 0 === this.pieX ? (b - f - a) / 2 + f : e(this.pieX, this.realWidth);
                    B = void 0 === this.pieY ? (n - v - m) / 2 + v : e(this.pieY, n);
                    k = e(this.radius, b, n);
                    k || (b = 0 <= y ? b - f - a - 2 * p : b - f - a, n = n - v - m, k = Math.min(b, n), n < b && (k /= 1 - this.angle / 90, k > b && (k = b)), n = l.toCoordinate(this.pullOutRadius, k), k = (0 <= y ? k - 1.8 * (y + n) : k - 1.8 * n) / 2);
                    k < this.minRadius && (k = this.minRadius);
                    n = e(this.pullOutRadius, k);
                    v = l.toCoordinate(this.startRadius, k);
                    e = e(this.innerRadius, k);
                    e >= k && (e = k - 1);
                    m = l.fitToBounds(this.startAngle, 0, 360);
                    0 < this.depth3D && (m = 270 <= m ? 270 : 90);
                    m -= 90;
                    360 < m && (m -= 360);
                    b = k - k * this.angle / 90;
                    for (f = p = 0; f < d.length; f++) a = d[f], !0 !== a.hidden && (p += l.roundTo(a.percents, this.pf.precision));
                    p = l.roundTo(p, this.pf.precision);
                    this.tempPrec = NaN;
                    this.adjustPrecision && 100 != p && (this.tempPrec = this.pf.precision + 1);
                    for (var D, f = 0; f < d.length; f++)
                        if (a = d[f], !0 !== a.hidden && (this.showZeroSlices || 0 !== a.percents)) {
                            var t = 360 * a.percents / 100,
                                p = Math.sin((m + t / 2) / 180 * Math.PI),
                                C = -Math.cos((m + t / 2) / 180 * Math.PI) * (b / k),
                                q = this.outlineColor;
                            q || (q = a.color);
                            var w = this.alpha;
                            isNaN(a.alpha) || (w = a.alpha);
                            q = {
                                fill: a.color,
                                stroke: q,
                                "stroke-width": this.outlineThickness,
                                "stroke-opacity": this.outlineAlpha,
                                "fill-opacity": w
                            };
                            a.url && (q.cursor = "pointer");
                            q = l.wedge(c, A, B, m, t, k, b, e, this.depth3D, q, this.gradientRatio, a.pattern, this.path);
                            l.setCN(this, q, "pie-item");
                            l.setCN(this, q.wedge, "pie-slice");
                            l.setCN(this, q, a.className, !0);
                            this.addEventListeners(q, a);
                            a.startAngle = m;
                            d[f].wedge = q;
                            0 < g && (this.chartCreated || q.setAttr("opacity", this.startAlpha));
                            a.ix = p;
                            a.iy = C;
                            a.wedge = q;
                            a.index = f;
                            w = c.set();
                            if (this.labelsEnabled && this.labelText && a.percents >= this.hideLabelsPercent) {
                                var h = m + t / 2;
                                0 > h && (h += 360);
                                360 < h && (h -= 360);
                                var r = y;
                                isNaN(a.labelRadius) || (r = a.labelRadius, 0 > r && (a.skipTick = !0));
                                var t = A + p * (k + r),
                                    E = B + C * (k + r),
                                    x, u = 0;
                                isNaN(D) && 350 < h && 1 < d.length - f && (D = f - 1 + Math.floor((d.length - f) / 2));
                                if (0 <= r) {
                                    var z;
                                    90 >= h && 0 <= h ? (z = 0, x = "start", u = 8) : 90 <= h && 180 > h ? (z = 1, x = "start", u = 8) : 180 <= h && 270 > h ? (z = 2, x = "end", u = -8) : 270 <= h && 357 >= h ? (z = 3, x = "end", u = -8) : 357 <= h && (f > D ? (z = 0, x = "start", u = 8) : (z = 3, x = "end", u = -8));
                                    a.labelQuarter = z
                                } else x = "middle";
                                h = this.formatString(this.labelText, a);
                                (r = this.labelFunction) && (h = r(a, h));
                                r = a.labelColor;
                                r || (r = this.color);
                                if ("" !== h) {
                                    h = l.wrappedText(c, h, r, this.fontFamily, this.fontSize, x, !1, this.maxLabelWidth);
                                    l.setCN(this, h, "pie-label");
                                    l.setCN(this, h, a.className, !0);
                                    h.translate(t + 1.5 * u, E);
                                    h.node.style.pointerEvents = "none";
                                    a.ty = E;
                                    a.textX = t + 1.5 * u;
                                    var r = h.getBBox(),
                                        F = l.rect(c, r.width + 5, r.height +
                                            5, "#FFFFFF", .005);
                                    F.translate(t + 1.5 * u + r.x, E + r.y);
                                    a.hitRect = F;
                                    w.push(h);
                                    w.push(F);
                                    this.axesSet.push(w);
                                    a.labelSet = w;
                                    a.label = h
                                }
                                a.tx = t;
                                a.tx2 = t + u;
                                a.tx0 = A + p * k;
                                a.ty0 = B + C * k
                            }
                            t = e + (k - e) / 2;
                            a.pulled && (t += this.pullOutRadiusReal);
                            a.balloonX = p * t + A;
                            a.balloonY = C * t + B;
                            a.startX = Math.round(p * v);
                            a.startY = Math.round(C * v);
                            a.pullX = Math.round(p * n);
                            a.pullY = Math.round(C * n);
                            this.graphsSet.push(q);
                            if (0 === a.alpha || 0 < g && !this.chartCreated) q.hide(), w && w.hide();
                            m += 360 * a.percents / 100;
                            360 < m && (m -= 360)
                        }
                    0 < y && this.arrangeLabels();
                    this.pieXReal = A;
                    this.pieYReal = B;
                    this.radiusReal = k;
                    this.innerRadiusReal = e;
                    0 < y && this.drawTicks();
                    this.initialStart();
                    this.setDepths()
                }(d = this.legend) && d.invalidateSize()
            } else this.cleanChart();
            this.dispDUpd()
        },
        setDepths: function() {
            var d = this.chartData,
                g;
            for (g = 0; g < d.length; g++) {
                var c = d[g],
                    b = c.wedge,
                    c = c.startAngle;
                0 <= c && 180 > c ? b.toFront() : 180 <= c && b.toBack()
            }
        },
        arrangeLabels: function() {
            var d = this.chartData,
                g = d.length,
                c, b;
            for (b = g - 1; 0 <= b; b--) c = d[b], 0 !== c.labelQuarter || c.hidden || this.checkOverlapping(b, c, 0, !0, 0);
            for (b = 0; b < g; b++) c = d[b], 1 != c.labelQuarter || c.hidden || this.checkOverlapping(b, c, 1, !1, 0);
            for (b = g - 1; 0 <= b; b--) c = d[b], 2 != c.labelQuarter || c.hidden || this.checkOverlapping(b, c, 2, !0, 0);
            for (b = 0; b < g; b++) c = d[b], 3 != c.labelQuarter || c.hidden || this.checkOverlapping(b, c, 3, !1, 0)
        },
        checkOverlapping: function(d, g, c, b, l) {
            var e, f, a = this.chartData,
                v = a.length,
                m = g.label;
            if (m) {
                if (!0 === b)
                    for (f = d + 1; f < v; f++) a[f].labelQuarter == c && (e = this.checkOverlappingReal(g, a[f], c)) && (f = v);
                else
                    for (f = d - 1; 0 <= f; f--) a[f].labelQuarter == c && (e = this.checkOverlappingReal(g, a[f], c)) && (f = 0);
                !0 === e && 100 > l && isNaN(g.labelRadius) && (e = g.ty + 3 * g.iy, g.ty = e, m.translate(g.textX, e), g.hitRect && (m = m.getBBox(), g.hitRect.translate(g.tx2, e + m.y)), this.checkOverlapping(d, g, c, b, l + 1))
            }
        },
        checkOverlappingReal: function(d, g, c) {
            var b = !1,
                n = d.label,
                e = g.label;
            d.labelQuarter != c || d.hidden || g.hidden || !e || (n = n.getBBox(), c = {}, c.width = n.width, c.height = n.height, c.y = d.ty, c.x = d.tx, d = e.getBBox(), e = {}, e.width = d.width, e.height = d.height, e.y = g.ty, e.x = g.tx, l.hitTest(c, e) && (b = !0));
            return b
        }
    })
})();;;;
AmCharts.translations["export"] || (AmCharts.translations["export"] = {}), AmCharts.translations["export"].en || (AmCharts.translations["export"].en = {
        "fallback.save.text": "CTRL + C to copy the data into the clipboard.",
        "fallback.save.image": "Rightclick -> Save picture as... to save the image.",
        "capturing.delayed.menu.label": "{{duration}}",
        "capturing.delayed.menu.title": "Click to cancel",
        "menu.label.print": "Print",
        "menu.label.undo": "Undo",
        "menu.label.redo": "Redo",
        "menu.label.cancel": "Cancel",
        "menu.label.save.image": "Download as ...",
        "menu.label.save.data": "Save as ...",
        "menu.label.draw": "Annotate ...",
        "menu.label.draw.change": "Change ...",
        "menu.label.draw.add": "Add ...",
        "menu.label.draw.shapes": "Shape ...",
        "menu.label.draw.colors": "Color ...",
        "menu.label.draw.widths": "Size ...",
        "menu.label.draw.opacities": "Opacity ...",
        "menu.label.draw.text": "Text",
        "menu.label.draw.modes": "Mode ...",
        "menu.label.draw.modes.pencil": "Pencil",
        "menu.label.draw.modes.line": "Line",
        "menu.label.draw.modes.arrow": "Arrow"
    }),
    function() {
        AmCharts["export"] = function(a, b) {
            var c = {
                name: "export",
                version: "1.4.7",
                libs: {
                    async: !0,
                    autoLoad: !0,
                    reload: !1,
                    resources: [{
                        "pdfmake/pdfmake.js": ["pdfmake/vfs_fonts.js"],
                        "jszip/jszip.js": ["xlsx/xlsx.js"]
                    }, "fabric.js/fabric.js", "FileSaver.js/FileSaver.js"],
                    namespaces: {
                        "pdfmake.js": "pdfMake",
                        "jszip.js": "JSZip",
                        "xlsx.js": "XLSX",
                        "fabric.js": "fabric",
                        "FileSaver.js": "saveAs"
                    }
                },
                config: {},
                setup: {
                    chart: a,
                    hasBlob: !1,
                    wrapper: !1
                },
                drawing: {
                    enabled: !1,
                    undos: [],
                    redos: [],
                    buffer: {
                        position: {
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 0,
                            xD: 0,
                            yD: 0
                        }
                    },
                    handler: {
                        undo: function(a, b) {
                            var d = c.drawing.undos.pop();
                            if (d) {
                                d.selectable = !0, c.drawing.redos.push(d), "added" == d.action && c.setup.fabric.remove(d.target);
                                var e = JSON.parse(d.state);
                                d.target.set(e), d.target instanceof fabric.Group && c.drawing.handler.change({
                                    color: e.cfg.color,
                                    width: e.cfg.width,
                                    opacity: e.cfg.opacity
                                }, !0, d.target), c.setup.fabric.renderAll(), d.state != d.target.recentState || b || c.drawing.handler.undo(d, !0)
                            }
                        },
                        redo: function(a, b) {
                            var d = c.drawing.redos.pop();
                            if (d) {
                                d.selectable = !0, c.drawing.undos.push(d), "added" == d.action && c.setup.fabric.add(d.target);
                                var e = JSON.parse(d.state);
                                d.target.recentState = d.state, d.target.set(e), d.target instanceof fabric.Group && c.drawing.handler.change({
                                    color: e.cfg.color,
                                    width: e.cfg.width,
                                    opacity: e.cfg.opacity
                                }, !0, d.target), c.setup.fabric.renderAll(), "addified" == d.action && c.drawing.handler.redo()
                            }
                        },
                        done: function(a) {
                            c.drawing.buffer.enabled = !1, c.drawing.undos = [], c.drawing.redos = [], c.createMenu(c.config.menu), c.setup.fabric.deactivateAll(), c.setup.wrapper && (c.setup.chart.containerDiv.removeChild(c.setup.wrapper), c.setup.wrapper = !1)
                        },
                        add: function(a) {
                            var b = c.deepMerge({
                                    top: c.setup.fabric.height / 2,
                                    left: c.setup.fabric.width / 2
                                }, a || {}),
                                d = -1 != b.url.indexOf(".svg") ? fabric.loadSVGFromURL : fabric.Image.fromURL;
                            d(b.url, function(a, d) {
                                var e = void 0 !== d ? fabric.util.groupSVGElements(a, d) : a,
                                    f = !1;
                                (e.height > c.setup.fabric.height || e.width > c.setup.fabric.width) && (f = c.setup.fabric.height / 2 / e.height), b.top > c.setup.fabric.height && (b.top = c.setup.fabric.height / 2), b.left > c.setup.fabric.width && (b.left = c.setup.fabric.width / 2), e.set({
                                    originX: "center",
                                    originY: "center",
                                    top: b.top,
                                    left: b.left,
                                    width: f ? e.width * f : e.width,
                                    height: f ? e.height * f : e.height,
                                    fill: c.drawing.color
                                }), c.setup.fabric.add(e)
                            })
                        },
                        change: function(a, b, d) {
                            var f, g, h, e = c.deepMerge({}, a || {}),
                                i = d || c.drawing.buffer.target,
                                j = i ? i._objects ? i._objects : [i] : null;
                            if (e.mode && (c.drawing.mode = e.mode), e.width && (c.drawing.width = e.width, c.drawing.fontSize = 3 * e.width), e.fontSize && (c.drawing.fontSize = e.fontSize), e.color && (c.drawing.color = e.color), e.opacity && (c.drawing.opacity = e.opacity), h = new fabric.Color(c.drawing.color).getSource(), h.pop(), h.push(c.drawing.opacity), c.drawing.color = "rgba(" + h.join() + ")", c.setup.fabric.freeDrawingBrush.color = c.drawing.color, c.setup.fabric.freeDrawingBrush.width = c.drawing.width, i) {
                                for (f = JSON.parse(i.recentState).cfg, f && (e.color = e.color || f.color, e.width = e.width || f.width, e.opacity = e.opacity || f.opacity, e.fontSize = e.fontSize || 3 * e.width, h = new fabric.Color(e.color).getSource(), h.pop(), h.push(e.opacity), e.color = "rgba(" + h.join() + ")"), g = 0; g < j.length; g++) j[g] instanceof fabric.Text || j[g] instanceof fabric.PathGroup || j[g] instanceof fabric.Triangle ? ((e.color || e.opacity) && j[g].set({
                                    fill: e.color
                                }), e.fontSize && j[g].set({
                                    fontSize: e.fontSize
                                })) : (j[g] instanceof fabric.Path || j[g] instanceof fabric.Line) && (i instanceof fabric.Group ? (e.color || e.opacity) && j[g].set({
                                    stroke: e.color
                                }) : ((e.color || e.opacity) && j[g].set({
                                    stroke: e.color
                                }), e.width && j[g].set({
                                    strokeWidth: e.width
                                })));
                                b || (f = JSON.stringify(c.deepMerge(i.saveState().originalState, {
                                    cfg: {
                                        color: e.color,
                                        width: e.width,
                                        opacity: e.opacity
                                    }
                                })), i.recentState = f, c.drawing.redos = [], c.drawing.undos.push({
                                    action: "modified",
                                    target: i,
                                    state: f
                                })), c.setup.fabric.renderAll()
                            }
                        },
                        text: function(a) {
                            var b = c.deepMerge({
                                text: c.i18l("menu.label.draw.text"),
                                top: c.setup.fabric.height / 2,
                                left: c.setup.fabric.width / 2,
                                fontSize: c.drawing.fontSize,
                                fontFamily: c.setup.chart.fontFamily || "Verdana",
                                fill: c.drawing.color
                            }, a || {});
                            b.click = function() {};
                            var d = new fabric.IText(b.text, b);
                            return c.setup.fabric.add(d), c.setup.fabric.setActiveObject(d), d.selectAll(), d.enterEditing(), d
                        },
                        line: function(a) {
                            var d, e, f, g, b = c.deepMerge({
                                    x1: c.setup.fabric.width / 2 - c.setup.fabric.width / 10,
                                    x2: c.setup.fabric.width / 2 + c.setup.fabric.width / 10,
                                    y1: c.setup.fabric.height / 2,
                                    y2: c.setup.fabric.height / 2,
                                    angle: 90,
                                    strokeLineCap: c.drawing.lineCap,
                                    arrow: c.drawing.arrow,
                                    color: c.drawing.color,
                                    width: c.drawing.width,
                                    group: []
                                }, a || {}),
                                h = new fabric.Line([b.x1, b.y1, b.x2, b.y2], {
                                    stroke: b.color,
                                    strokeWidth: b.width,
                                    strokeLineCap: b.strokeLineCap
                                });
                            if (b.group.push(h), b.arrow && (b.angle = b.angle ? b.angle : c.getAngle(b.x1, b.y1, b.x2, b.y2), "start" == b.arrow ? (f = b.y1 + b.width / 2, g = b.x1 + b.width / 2) : "middle" == b.arrow ? (f = b.y2 + b.width / 2 - (b.y2 - b.y1) / 2, g = b.x2 + b.width / 2 - (b.x2 - b.x1) / 2) : (f = b.y2 + b.width / 2, g = b.x2 + b.width / 2), e = new fabric.Triangle({
                                    top: f,
                                    left: g,
                                    fill: b.color,
                                    height: 7 * b.width,
                                    width: 7 * b.width,
                                    angle: b.angle,
                                    originX: "center",
                                    originY: "bottom"
                                }), b.group.push(e)), "config" != b.action) {
                                if (b.arrow) {
                                    var i = new fabric.Group(b.group);
                                    return i.set({
                                        cfg: b,
                                        fill: b.color,
                                        action: b.action,
                                        selectable: !0,
                                        known: "change" == b.action
                                    }), "change" == b.action && c.setup.fabric.setActiveObject(i), c.setup.fabric.add(i), i
                                }
                                return c.setup.fabric.add(h), h
                            }
                            for (d = 0; d < b.group.length; d++) b.group[d].noUndo = !0, c.setup.fabric.add(b.group[d]);
                            return b
                        }
                    }
                },
                defaults: {
                    position: "top-right",
                    fileName: "amCharts",
                    action: "download",
                    overflow: !0,
                    path: (a.path || "") + "plugins/export/",
                    formats: {
                        JPG: {
                            mimeType: "image/jpg",
                            extension: "jpg",
                            capture: !0
                        },
                        PNG: {
                            mimeType: "image/png",
                            extension: "png",
                            capture: !0
                        },
                        SVG: {
                            mimeType: "text/xml",
                            extension: "svg",
                            capture: !0
                        },
                        PDF: {
                            mimeType: "application/pdf",
                            extension: "pdf",
                            capture: !0
                        },
                        CSV: {
                            mimeType: "text/plain",
                            extension: "csv"
                        },
                        JSON: {
                            mimeType: "text/plain",
                            extension: "json"
                        },
                        XLSX: {
                            mimeType: "application/octet-stream",
                            extension: "xlsx"
                        }
                    },
                    fabric: {
                        backgroundColor: "#FFFFFF",
                        removeImages: !0,
                        selection: !1,
                        drawing: {
                            enabled: !0,
                            arrow: "end",
                            lineCap: "butt",
                            mode: "pencil",
                            modes: ["pencil", "line", "arrow"],
                            color: "#000000",
                            colors: ["#000000", "#FFFFFF", "#FF0000", "#00FF00", "#0000FF"],
                            shapes: ["11.svg", "14.svg", "16.svg", "17.svg", "20.svg", "27.svg"],
                            width: 1,
                            fontSize: 11,
                            widths: [1, 5, 10, 15],
                            opacity: 1,
                            opacities: [1, .8, .6, .4, .2],
                            menu: void 0,
                            autoClose: !0
                        }
                    },
                    pdfMake: {
                        pageSize: "A4",
                        pageOrientation: "portrait",
                        images: {},
                        content: ["Saved from:", window.location.href, {
                            image: "reference",
                            fit: [523.28, 769.89]
                        }]
                    },
                    menu: void 0,
                    divId: null,
                    menuReviver: null,
                    menuWalker: null,
                    fallback: !0,
                    keyListener: !0,
                    fileListener: !0
                },
                i18l: function(a, b) {
                    var d = b ? langugage : c.setup.chart.language ? c.setup.chart.language : "en",
                        e = AmCharts.translations[c.name][d] || AmCharts.translations[c.name].en;
                    return e[a] || a
                },
                download: function(a, b, d) {
                    if (window.saveAs && c.setup.hasBlob) {
                        c.toBlob({
                            data: a,
                            type: b
                        }, function(a) {
                            saveAs(a, d)
                        })
                    } else if (c.config.fallback && "text/plain" == b) {
                        var f = document.createElement("div"),
                            g = document.createElement("div"),
                            h = document.createElement("textarea");
                        g.innerHTML = c.i18l("fallback.save.text"), f.appendChild(g), f.appendChild(h), g.setAttribute("class", "amcharts-export-fallback-message"), f.setAttribute("class", "amcharts-export-fallback"), c.setup.chart.containerDiv.appendChild(f), h.setAttribute("readonly", ""), h.value = a, h.focus(), h.select(), c.createMenu([{
                            "class": "export-main export-close",
                            label: "Done",
                            click: function() {
                                c.createMenu(c.config.menu), c.setup.chart.containerDiv.removeChild(f)
                            }
                        }])
                    } else {
                        if (!c.config.fallback || "image" != b.split("/")[0]) throw new Error("Unable to create file. Ensure saveAs (FileSaver.js) is supported.");
                        var f = document.createElement("div"),
                            g = document.createElement("div"),
                            i = c.toImage({
                                data: a
                            });
                        g.innerHTML = c.i18l("fallback.save.image"), f.appendChild(g), f.appendChild(i), g.setAttribute("class", "amcharts-export-fallback-message"), f.setAttribute("class", "amcharts-export-fallback"), c.setup.chart.containerDiv.appendChild(f), c.createMenu([{
                            "class": "export-main export-close",
                            label: "Done",
                            click: function() {
                                c.createMenu(c.config.menu), c.setup.chart.containerDiv.removeChild(f)
                            }
                        }])
                    }
                    return a
                },
                loadResource: function(a, b) {
                    function k() {
                        if (b)
                            for (d = 0; d < b.length; d++) c.loadResource(b[d])
                    }
                    var d, e, f, g, h, i, j = -1 != a.indexOf("//") ? a : [c.libs.path, a].join("");
                    for (-1 != a.indexOf(".js") ? (f = document.createElement("script"), f.setAttribute("type", "text/javascript"), f.setAttribute("src", j), c.libs.async && f.setAttribute("async", "")) : -1 != a.indexOf(".css") && (f = document.createElement("link"), f.setAttribute("type", "text/css"), f.setAttribute("rel", "stylesheet"), f.setAttribute("href", j)), d = 0; d < document.head.childNodes.length; d++)
                        if (g = document.head.childNodes[d], h = g ? g.src || g.href : !1, i = g ? g.tagName : !1, g && h && -1 != h.indexOf(a)) {
                            c.libs.reload && document.head.removeChild(g), e = !0;
                            break
                        }
                    for (d in c.libs.namespaces) {
                        var l = c.libs.namespaces[d],
                            h = a.toLowerCase(),
                            g = d.toLowerCase();
                        if (-1 != h.indexOf(g) && void 0 !== window[l]) {
                            e = !0;
                            break
                        }
                    }(!e || c.libs.reload) && (f.addEventListener("load", k), document.head.appendChild(f))
                },
                loadDependencies: function() {
                    var a, b;
                    if (c.libs.autoLoad)
                        for (a = 0; a < c.libs.resources.length; a++)
                            if (c.libs.resources[a] instanceof Object)
                                for (b in c.libs.resources[a]) c.loadResource(b, c.libs.resources[a][b]);
                            else c.loadResource(c.libs.resources[a])
                },
                pxToNumber: function(a, b) {
                    return !a && b ? void 0 : Number(String(a).replace("px", "")) || 0
                },
                numberToPx: function(a) {
                    return String(a) + "px"
                },
                deepMerge: function(a, b, d) {
                    var e, f, g = b instanceof Array ? "array" : "object";
                    for (e in b) "array" == g && isNaN(e) || (f = b[e], (void 0 == a[e] || d) && (f instanceof Array ? a[e] = new Array : f instanceof Function ? a[e] = new Function : f instanceof Date ? a[e] = new Date : f instanceof Object ? a[e] = new Object : f instanceof Number ? a[e] = new Number : f instanceof String && (a[e] = new String)), (a instanceof Object || a instanceof Array) && (f instanceof Object || f instanceof Array) && !(f instanceof Function || f instanceof Date || c.isElement(f)) && "chart" != e ? c.deepMerge(a[e], f, d) : a instanceof Array && !d ? a.push(f) : a[e] = f);
                    return a
                },
                isElement: function(a) {
                    return a instanceof Object && a && 1 === a.nodeType
                },
                isHashbanged: function(a) {
                    var b = String(a);
                    return "url" == b.slice(0, 3) ? b.slice(b.indexOf("#") + 1, b.length - 1) : !1
                },
                isPressed: function(a) {
                    return "mousemove" == a.type && 1 === a.which || ("touchmove" == a.type || 1 === a.buttons || 1 === a.button || 1 === a.which ? c.drawing.buffer.isPressed = !0 : c.drawing.buffer.isPressed = !1), c.drawing.buffer.isPressed
                },
                isTainted: function(a) {
                    var b = String(window.location.origin || window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : ""));
                    return a && -1 != a.indexOf("//") && -1 == a.indexOf(b.replace(/.*:/, "")) ? !0 : !1
                },
                isSupported: function() {
                    return c.config.enabled && (!(AmCharts.isIE && AmCharts.IEversion <= 9) || Array.prototype.indexOf && document.head && c.config.fallback !== !1) ? !0 : !1
                },
                getAngle: function(a, b, c, d) {
                    var g, e = c - a,
                        f = d - b;
                    return g = 0 == e ? 0 == f ? 0 : f > 0 ? Math.PI / 2 : 3 * Math.PI / 2 : 0 == f ? e > 0 ? 0 : Math.PI : 0 > e ? Math.atan(f / e) + Math.PI : 0 > f ? Math.atan(f / e) + 2 * Math.PI : Math.atan(f / e), 180 * g / Math.PI
                },
                gatherAttribute: function(a, b, d, e) {
                    var f, e = e ? e : 0,
                        d = d ? d : 3;
                    return a && (f = a.getAttribute(b), !f && d > e) ? c.gatherAttribute(a.parentNode, b, d, e + 1) : f
                },
                gatherClassName: function(a, b, d, e) {
                    var f, e = e ? e : 0,
                        d = d ? d : 3;
                    if (c.isElement(a)) {
                        if (f = -1 != (a.getAttribute("class") || "").split(" ").indexOf(b), !f && d > e) return c.gatherClassName(a.parentNode, b, d, e + 1);
                        f && (f = a)
                    }
                    return f
                },
                gatherElements: function(a, b, d) {
                    var e, f;
                    for (e = 0; e < a.children.length; e++) {
                        var g = a.children[e];
                        if ("clipPath" == g.tagName) {
                            for (f = 0; f < g.childNodes.length; f++) g.childNodes[f].setAttribute("fill", "transparent");
                            a.clippings[g.id] = g
                        } else if ("pattern" == g.tagName) {
                            var h = {
                                node: g,
                                source: g.getAttribute("xlink:href"),
                                width: Number(g.getAttribute("width")),
                                height: Number(g.getAttribute("height")),
                                repeat: "repeat"
                            };
                            for (f = 0; f < g.childNodes.length; f++) "rect" == g.childNodes[f].tagName && (h.fill = g.childNodes[f].getAttribute("fill"));
                            b.removeImages && c.isTainted(h.source) ? a.patterns[g.id] = h.fill ? h.fill : "transparent" : (d.included++, a.patterns[h.node.id] = h)
                        } else "image" == g.tagName && (d.included++, fabric.Image.fromURL(g.getAttribute("xlink:href"), function(a) {
                            d.loaded++
                        }))
                    }
                    return a
                },
                gatherPosition: function(a, b) {
                    var f, d = c.drawing.buffer.position,
                        e = fabric.util.invertTransform(c.setup.fabric.viewportTransform);
                    return "touchmove" == a.type && ("touches" in a ? a = a.touches[0] : "changedTouches" in a && (a = a.changedTouches[0])), f = fabric.util.transformPoint(c.setup.fabric.getPointer(a, !0), e), 1 == b && (d.x1 = f.x, d.y1 = f.y), d.x2 = f.x, d.y2 = f.y, d.xD = d.x1 - d.x2 < 0 ? -1 * (d.x1 - d.x2) : d.x1 - d.x2, d.yD = d.y1 - d.y2 < 0 ? -1 * (d.y1 - d.y2) : d.y1 - d.y2, d
                },
                capture: function(a, b) {
                    var d, e = c.deepMerge(c.deepMerge({}, c.config.fabric), a || {}),
                        f = [],
                        g = {
                            x: 0,
                            y: 0,
                            pX: 0,
                            pY: 0,
                            width: c.setup.chart.divRealWidth,
                            height: c.setup.chart.divRealHeight
                        },
                        h = {
                            loaded: 0,
                            included: 0
                        };
                    fabric.ElementsParser.prototype.resolveGradient = function(a, b) {
                        var c = a.get(b);
                        if (/^url\(/.test(c)) {
                            var d = c.slice(c.indexOf("#") + 1, c.length - 1);
                            fabric.gradientDefs[this.svgUid][d] && a.set(b, fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][d], a))
                        }
                    }, c.handleCallback(e.beforeCapture, e);
                    var i = c.setup.chart.containerDiv.getElementsByTagName("svg");
                    for (d = 0; d < i.length; d++) {
                        var j = {
                            svg: i[d],
                            parent: i[d].parentNode,
                            children: i[d].getElementsByTagName("*"),
                            offset: {
                                x: 0,
                                y: 0
                            },
                            patterns: {},
                            clippings: {}
                        };
                        j = c.gatherElements(j, e, h), f.push(j)
                    }
                    if (c.config.legend && c.setup.chart.legend && "outside" == c.setup.chart.legend.position) {
                        var j = {
                            svg: c.setup.chart.legend.container.container,
                            parent: c.setup.chart.legend.container.container.parentNode,
                            children: c.setup.chart.legend.container.container.getElementsByTagName("*"),
                            offset: {
                                x: 0,
                                y: 0
                            },
                            legend: {
                                type: -1 != ["top", "left"].indexOf(c.config.legend.position) ? "unshift" : "push",
                                position: c.config.legend.position,
                                width: c.config.legend.width ? c.config.legend.width : c.setup.chart.legend.container.width,
                                height: c.config.legend.height ? c.config.legend.height : c.setup.chart.legend.container.height
                            },
                            patterns: {},
                            clippings: {}
                        }; - 1 != ["left", "right"].indexOf(j.legend.position) ? (g.width += j.legend.width, g.height = j.legend.height > g.height ? j.legend.height : g.height) : -1 != ["top", "bottom"].indexOf(j.legend.position) && (g.height += j.legend.height), j = c.gatherElements(j, e, h), f[j.legend.type](j)
                    }
                    if (c.drawing.buffer.enabled = "draw" == e.action, c.setup.wrapper = document.createElement("div"), c.setup.wrapper.setAttribute("class", c.setup.chart.classNamePrefix + "-export-canvas"), c.setup.chart.containerDiv.appendChild(c.setup.wrapper), "stock" == c.setup.chart.type) {
                        var k = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        };
                        c.setup.chart.leftContainer && (g.width -= c.setup.chart.leftContainer.offsetWidth, k.left = c.setup.chart.leftContainer.offsetWidth + 2 * c.setup.chart.panelsSettings.panelSpacing), c.setup.chart.rightContainer && (g.width -= c.setup.chart.rightContainer.offsetWidth, k.right = c.setup.chart.rightContainer.offsetWidth + 2 * c.setup.chart.panelsSettings.panelSpacing), c.setup.chart.periodSelector && -1 != ["top", "bottom"].indexOf(c.setup.chart.periodSelector.position) && (g.height -= c.setup.chart.periodSelector.offsetHeight + c.setup.chart.panelsSettings.panelSpacing, k[c.setup.chart.periodSelector.position] += c.setup.chart.periodSelector.offsetHeight + c.setup.chart.panelsSettings.panelSpacing), c.setup.chart.dataSetSelector && -1 != ["top", "bottom"].indexOf(c.setup.chart.dataSetSelector.position) && (g.height -= c.setup.chart.dataSetSelector.offsetHeight, k[c.setup.chart.dataSetSelector.position] += c.setup.chart.dataSetSelector.offsetHeight), c.setup.wrapper.style.paddingTop = c.numberToPx(k.top), c.setup.wrapper.style.paddingRight = c.numberToPx(k.right), c.setup.wrapper.style.paddingBottom = c.numberToPx(k.bottom), c.setup.wrapper.style.paddingLeft = c.numberToPx(k.left)
                    }
                    for (c.setup.canvas = document.createElement("canvas"), c.setup.wrapper.appendChild(c.setup.canvas), c.setup.fabric = new fabric.Canvas(c.setup.canvas, c.deepMerge({
                            width: g.width,
                            height: g.height,
                            isDrawingMode: !0
                        }, e)), c.deepMerge(c.setup.fabric, e), c.deepMerge(c.setup.fabric.freeDrawingBrush, e.drawing), c.deepMerge(c.drawing, e.drawing), c.drawing.handler.change(e.drawing), c.setup.fabric.on("mouse:down", function(a) {
                            c.gatherPosition(a.e, 1);
                            c.drawing.buffer.pressedTS = Number(new Date), c.isPressed(a.e)
                        }), c.setup.fabric.on("mouse:move", function(a) {
                            var b = c.gatherPosition(a.e, 2);
                            if (c.isPressed(a.e), c.drawing.buffer.isPressed && !c.drawing.buffer.line && !c.drawing.buffer.isSelected && "pencil" != c.drawing.mode && (b.xD > 5 || b.xD > 5) && (c.drawing.buffer.hasLine = !0, c.setup.fabric.isDrawingMode = !1, c.setup.fabric._onMouseUpInDrawingMode(a), c.drawing.buffer.line = c.drawing.handler.line({
                                    x1: b.x1,
                                    y1: b.y1,
                                    x2: b.x2,
                                    y2: b.y2,
                                    arrow: "line" == c.drawing.mode ? !1 : c.drawing.arrow,
                                    action: "config"
                                })), c.drawing.buffer.line) {
                                var e, f, g, h = c.drawing.buffer.line;
                                for (h.x2 = b.x2, h.y2 = b.y2, d = 0; d < h.group.length; d++) e = h.group[d], e instanceof fabric.Line ? e.set({
                                    x2: h.x2,
                                    y2: h.y2
                                }) : e instanceof fabric.Triangle && (h.angle = c.getAngle(h.x1, h.y1, h.x2, h.y2) + 90, "start" == h.arrow ? (f = h.y1 + h.width / 2, g = h.x1 + h.width / 2) : "middle" == h.arrow ? (f = h.y2 + h.width / 2 - (h.y2 - h.y1) / 2, g = h.x2 + h.width / 2 - (h.x2 - h.x1) / 2) : (f = h.y2 + h.width / 2, g = h.x2 + h.width / 2), e.set({
                                    top: f,
                                    left: g,
                                    angle: h.angle
                                }));
                                c.setup.fabric.renderAll()
                            }
                        }), c.setup.fabric.on("mouse:up", function(a) {
                            if (Number(new Date) - c.drawing.buffer.pressedTS < 200) {
                                var b = c.setup.fabric.findTarget(a.e);
                                b && b.selectable && c.setup.fabric.setActiveObject(b)
                            }
                            if (c.drawing.buffer.line) {
                                for (d = 0; d < c.drawing.buffer.line.group.length; d++) c.drawing.buffer.line.group[d].remove();
                                delete c.drawing.buffer.line.action, delete c.drawing.buffer.line.group, c.drawing.handler.line(c.drawing.buffer.line)
                            }
                            c.drawing.buffer.line = !1, c.drawing.buffer.hasLine = !1, c.drawing.buffer.isPressed = !1
                        }), c.setup.fabric.on("object:selected", function(a) {
                            c.drawing.buffer.isSelected = !0, c.drawing.buffer.target = a.target, c.setup.fabric.isDrawingMode = !1
                        }), c.setup.fabric.on("selection:cleared", function(a) {
                            c.drawing.buffer.onMouseDown = c.setup.fabric.freeDrawingBrush.onMouseDown, c.drawing.buffer.target = !1, c.drawing.buffer.isSelected && (c.setup.fabric._isCurrentlyDrawing = !1, c.setup.fabric.freeDrawingBrush.onMouseDown = function() {}), setTimeout(function() {
                                c.drawing.buffer.isSelected = !1, c.setup.fabric.isDrawingMode = !0, c.setup.fabric.freeDrawingBrush.onMouseDown = c.drawing.buffer.onMouseDown
                            }, 10)
                        }), c.setup.fabric.on("path:created", function(a) {
                            var b = a.path;
                            return Number(new Date) - c.drawing.buffer.pressedTS < 200 || c.drawing.buffer.hasLine ? (c.setup.fabric.remove(b), void c.setup.fabric.renderAll()) : void 0
                        }), c.setup.fabric.on("object:added", function(a) {
                            var b = a.target,
                                d = c.deepMerge(b.saveState().originalState, {
                                    cfg: {
                                        color: c.drawing.color,
                                        width: c.drawing.width,
                                        opacity: c.drawing.opacity,
                                        fontSize: c.drawing.fontSize
                                    }
                                });
                            return Number(new Date) - c.drawing.buffer.pressedTS < 200 && !b.noUndo ? (c.setup.fabric.remove(b), void c.setup.fabric.renderAll()) : (d = JSON.stringify(d), b.recentState = d, !b.selectable || b.known || b.noUndo || (c.drawing.undos.push({
                                action: "added",
                                target: b,
                                state: d
                            }), c.drawing.undos.push({
                                action: "addified",
                                target: b,
                                state: d
                            }), c.drawing.redos = []), b.known = !0, void(c.setup.fabric.isDrawingMode = !0))
                        }), c.setup.fabric.on("object:modified", function(a) {
                            var b = a.target,
                                d = JSON.parse(b.recentState),
                                e = c.deepMerge(b.saveState().originalState, {
                                    cfg: d.cfg
                                });
                            e = JSON.stringify(e), b.recentState = e, c.drawing.undos.push({
                                action: "modified",
                                target: b,
                                state: e
                            }), c.drawing.redos = []
                        }), c.setup.fabric.on("text:changed", function(a) {
                            var b = a.target;
                            clearTimeout(b.timer), b.timer = setTimeout(function() {
                                var a = JSON.stringify(b.saveState().originalState);
                                b.recentState = a, c.drawing.redos = [], c.drawing.undos.push({
                                    action: "modified",
                                    target: b,
                                    state: a
                                })
                            }, 250)
                        }), c.drawing.buffer.enabled ? (c.setup.wrapper.setAttribute("class", c.setup.chart.classNamePrefix + "-export-canvas active"), c.setup.wrapper.style.backgroundColor = e.backgroundColor, c.setup.wrapper.style.display = "block") : (c.setup.wrapper.setAttribute("class", c.setup.chart.classNamePrefix + "-export-canvas"), c.setup.wrapper.style.display = "none"), d = 0; d < f.length; d++) {
                        var j = f[d],
                            l = c.gatherClassName(j.parent, c.setup.chart.classNamePrefix + "-legend-div", 1),
                            m = c.gatherClassName(j.parent, c.setup.chart.classNamePrefix + "-stock-panel-div"),
                            n = c.gatherClassName(j.parent, c.setup.chart.classNamePrefix + "-scrollbar-chart-div");
                        "stock" == c.setup.chart.type && c.setup.chart.legendSettings.position ? -1 != ["top", "bottom"].indexOf(c.setup.chart.legendSettings.position) ? j.parent.style.top && j.parent.style.left ? (j.offset.y = c.pxToNumber(j.parent.style.top), j.offset.x = c.pxToNumber(j.parent.style.left)) : (j.offset.x = g.x, j.offset.y = g.y, g.y += c.pxToNumber(j.parent.style.height), m ? (g.pY = c.pxToNumber(m.style.marginTop), j.offset.y += g.pY) : n && (j.offset.y += g.pY)) : -1 != ["left", "right"].indexOf(c.setup.chart.legendSettings.position) && (j.offset.y = c.pxToNumber(j.parent.style.top) + g.pY, j.offset.x = c.pxToNumber(j.parent.style.left) + g.pX, l ? g.pY += c.pxToNumber(m.style.height) + c.setup.chart.panelsSettings.panelSpacing : n && (j.offset.y -= c.setup.chart.panelsSettings.panelSpacing)) : ("absolute" == j.parent.style.position ? (j.offset.absolute = !0, j.offset.top = c.pxToNumber(j.parent.style.top), j.offset.right = c.pxToNumber(j.parent.style.right, !0), j.offset.bottom = c.pxToNumber(j.parent.style.bottom, !0), j.offset.left = c.pxToNumber(j.parent.style.left), j.offset.width = c.pxToNumber(j.parent.style.width), j.offset.height = c.pxToNumber(j.parent.style.height)) : j.parent.style.top && j.parent.style.left ? (j.offset.y = c.pxToNumber(j.parent.style.top), j.offset.x = c.pxToNumber(j.parent.style.left)) : j.legend ? "left" == j.legend.position ? g.x += j.legend.width : "right" == j.legend.position ? j.offset.x += g.width - j.legend.width : "top" == j.legend.position ? g.y += j.legend.height : "bottom" == j.legend.position && (j.offset.y += g.height - j.legend.height) : (j.offset.x = g.x, j.offset.y = g.y + g.pY, g.y += c.pxToNumber(j.parent.style.height)), l && m && m.style.marginTop && (g.y += c.pxToNumber(m.style.marginTop), j.offset.y += c.pxToNumber(m.style.marginTop))), fabric.parseSVGDocument(j.svg, function(a) {
                            return function(d, i) {
                                var j, k = fabric.util.groupSVGElements(d, i),
                                    l = {
                                        selectable: !1
                                    };
                                for (a.offset.absolute ? (void 0 !== a.offset.bottom ? l.top = g.height - a.offset.height - a.offset.bottom : l.top = a.offset.top, void 0 !== a.offset.right ? l.left = g.width - a.offset.width - a.offset.right : l.left = a.offset.left) : (l.top = a.offset.y, l.left = a.offset.x), j = 0; j < k.paths.length; j++) {
                                    var m = null;
                                    if (k.paths[j]) {
                                        if (e.removeImages && c.isTainted(k.paths[j]["xlink:href"])) {
                                            k.paths.splice(j, 1);
                                            continue
                                        }
                                        if (k.paths[j].fill instanceof Object) "radial" == k.paths[j].fill.type && (k.paths[j].fill.coords.r2 = -1 * k.paths[j].fill.coords.r1, k.paths[j].fill.coords.r1 = 0), k.paths[j].set({
                                            opacity: k.paths[j].fillOpacity
                                        });
                                        else if ((m = c.isHashbanged(k.paths[j].fill)) && a.patterns && a.patterns[m]) {
                                            var n = a.patterns[m];
                                            fabric.Image.fromURL(n.source, function(a, b) {
                                                return function(c) {
                                                    h.loaded++;
                                                    var d = null,
                                                        e = new fabric.StaticCanvas(void 0, {
                                                            backgroundColor: a.fill
                                                        });
                                                    e.add(c), d = new fabric.Pattern({
                                                        source: function() {
                                                            return e.setDimensions({
                                                                width: a.width,
                                                                height: a.height
                                                            }), e.getElement()
                                                        },
                                                        repeat: "repeat"
                                                    }), k.paths[b].set({
                                                        fill: d,
                                                        opacity: k.paths[b].fillOpacity
                                                    })
                                                }
                                            }(n, j))
                                        }
                                        if ((m = c.isHashbanged(k.paths[j].clipPath)) && a.clippings[m] && k.paths[j].set({
                                                clipTo: function(b, c) {
                                                    return function(d) {
                                                        var e = a.clippings[c].childNodes[0],
                                                            f = Number(e.getAttribute("width") || "0"),
                                                            g = Number(e.getAttribute("height") || "0"),
                                                            h = Number(e.getAttribute("x") || "0"),
                                                            i = Number(e.getAttribute("y") || "0"),
                                                            j = k.paths[b].svg.getAttribute("transform") || "translate(0,0)",
                                                            l = k.paths[b].svg.tagName;
                                                        j = j.slice(10, -1).split(","), -1 != ["circle", "text"].indexOf(l) ? d.rect(-1 * Number(j[0]), -1 * Number(j[1]), f, g) : d.rect(-1 * Number(j[0]) + h, -1 * Number(j[1]) + i, f, g)
                                                    }
                                                }(j, m)
                                            }), k.paths[j].TSPANWORKAROUND) {
                                            for (var o = fabric.parseAttributes(k.paths[j].svg, fabric.Text.ATTRIBUTE_NAMES), i = fabric.util.object.extend({}, o), p = [], q = 0; q < k.paths[j].svg.childNodes.length; q++) {
                                                var r = k.paths[j].svg.childNodes[q],
                                                    s = fabric.Text.fromElement(r, i);
                                                s.set({
                                                    left: 0
                                                }), p.push(s)
                                            }
                                            k.paths[j].set({
                                                opacity: 0
                                            });
                                            var t = new fabric.Group(p, {
                                                top: -1 * k.paths[j].top
                                            });
                                            c.setup.fabric.add(t)
                                        }
                                    }
                                }
                                if (k.set(l), c.setup.fabric.add(k), a.svg.parentNode && a.svg.parentNode.getElementsByTagName) {
                                    var u = a.svg.parentNode.getElementsByClassName(c.setup.chart.classNamePrefix + "-balloon-div");
                                    for (j = 0; j < u.length; j++)
                                        if (e.balloonFunction instanceof Function) e.balloonFunction.apply(c, [u[j], a]);
                                        else {
                                            var v = u[j],
                                                w = fabric.parseStyleAttribute(v),
                                                x = fabric.parseStyleAttribute(v.childNodes[0]),
                                                y = new fabric.Text(v.innerText || v.innerHTML, {
                                                    selectable: !1,
                                                    top: w.top + a.offset.y,
                                                    left: w.left + a.offset.x,
                                                    fill: x.color,
                                                    fontSize: x.fontSize,
                                                    fontFamily: x.fontFamily,
                                                    textAlign: x["text-align"]
                                                });
                                            c.setup.fabric.add(y)
                                        }
                                }
                                if (a.svg.nextSibling && "A" == a.svg.nextSibling.tagName) {
                                    var v = a.svg.nextSibling,
                                        w = fabric.parseStyleAttribute(v),
                                        y = new fabric.Text(v.innerText || v.innerHTML, {
                                            selectable: !1,
                                            top: w.top + a.offset.y,
                                            left: w.left + a.offset.x,
                                            fill: w.color,
                                            fontSize: w.fontSize,
                                            fontFamily: w.fontFamily,
                                            opacity: w.opacity
                                        });
                                    c.setup.fabric.add(y)
                                }
                                if (f.pop(), !f.length) var z = setInterval(function() {
                                    h.loaded == h.included && (clearTimeout(z), c.handleCallback(e.afterCapture, e), c.setup.fabric.renderAll(), c.handleCallback(b, e))
                                }, AmCharts.updateRate)
                            }
                        }(j), function(a, b) {
                            var d, f = c.gatherAttribute(a, "class"),
                                g = c.gatherAttribute(a, "visibility"),
                                h = c.gatherAttribute(a, "clip-path");
                            if (b.className = String(f), b.classList = String(f).split(" "), b.clipPath = h, b.svg = a, "text" == a.tagName && a.childNodes.length > 1 && (b.TSPANWORKAROUND = !0), "hidden" == g) b.opacity = 0;
                            else {
                                var i = ["fill", "stroke"];
                                for (d = 0; d < i.length; d++) {
                                    var j = i[d],
                                        k = String(a.getAttribute(j) || ""),
                                        l = Number(a.getAttribute(j + "-opacity") || "1"),
                                        m = fabric.Color.fromHex(k).getSource(); - 1 == b.classList.indexOf(c.setup.chart.classNamePrefix + "-guide-fill") || k || (l = 0, m = fabric.Color.fromHex("#000000").getSource()), m && (m.pop(), m.push(l), b[j] = "rgba(" + m.join() + ")", b[j + c.capitalize("opacity")] = l)
                                }
                            }
                            c.handleCallback(e.reviver, b, a)
                        })
                    }
                },
                toCanvas: function(a, b) {
                    var e = (c.deepMerge({}, a || {}), c.setup.canvas);
                    return c.handleCallback(b, e), e
                },
                toImage: function(a, b) {
                    var d = c.deepMerge({
                            format: "png",
                            quality: 1,
                            multiplier: 1
                        }, a || {}),
                        e = d.data,
                        f = document.createElement("img");
                    return d.data || (e = d.lossless || "svg" == d.format ? c.toSVG(c.deepMerge(d, {
                        getBase64: !0
                    })) : c.setup.fabric.toDataURL(d)), f.setAttribute("src", e), c.handleCallback(b, f), f
                },
                toBlob: function(a, b) {
                    var e, d = c.deepMerge({
                            data: "empty",
                            type: "text/plain"
                        }, a || {}),
                        f = /^data:.+;base64,(.*)$/.exec(d.data);
                    return f && (d.data = f[0], d.type = d.data.slice(5, d.data.indexOf(",") - 7), d.data = c.toByteArray({
                        data: d.data.slice(d.data.indexOf(",") + 1, d.data.length)
                    })), e = d.getByteArray ? d.data : new Blob([d.data], {
                        type: d.type
                    }), c.handleCallback(b, e), e
                },
                toJPG: function(a, b) {
                    var d = c.deepMerge({
                        format: "jpeg",
                        quality: 1,
                        multiplier: 1
                    }, a || {});
                    d.format = d.format.toLowerCase();
                    var e = c.setup.fabric.toDataURL(d);
                    return c.handleCallback(b, e), e
                },
                toPNG: function(a, b) {
                    var d = c.deepMerge({
                            format: "png",
                            quality: 1,
                            multiplier: 1
                        }, a || {}),
                        e = c.setup.fabric.toDataURL(d);
                    return c.handleCallback(b, e), e
                },
                toSVG: function(a, b) {
                    var d = c.deepMerge({
                            reviver: function(a) {
                                var b = new RegExp(/\bstyle=(['"])(.*?)\1/),
                                    c = b.exec(a)[0].slice(7, -1),
                                    d = c.split(";"),
                                    e = [];
                                for (i1 = 0; i1 < d.length; i1++)
                                    if (d[i1]) {
                                        var f = d[i1].replace(/\s/g, "").split(":"),
                                            g = f[0],
                                            h = f[1];
                                        if (-1 != ["fill", "stroke"].indexOf(g))
                                            if (h = fabric.Color.fromRgba(h), h && h._source) {
                                                var i = "#" + h.toHex(),
                                                    j = h._source[3];
                                                e.push([g, i].join(":")), e.push([g + "-opacity", j].join(":"))
                                            } else e.push(d[i1]);
                                        else "opactiy" != g && e.push(d[i1])
                                    }
                                return a.replace(c, e.join(";"))
                            }
                        }, a || {}),
                        e = c.setup.fabric.toSVG(d, d.reviver);
                    return d.getBase64 && (e = "data:image/svg+xml;base64," + btoa(e)), c.handleCallback(b, e), e
                },
                toPDF: function(a, b) {
                    var d = c.deepMerge(c.deepMerge({
                        multiplier: 2
                    }, c.config.pdfMake), a || {}, !0);
                    d.images.reference = c.toPNG(d);
                    var e = new pdfMake.createPdf(d);
                    return b && e.getDataUrl(function(a) {
                        return function() {
                            a.apply(c, arguments)
                        }
                    }(b)), e
                },
                toPRINT: function(a, b) {
                    var d, e = c.deepMerge({
                            delay: 1,
                            lossless: !1
                        }, a || {}),
                        f = c.toImage(e),
                        g = [],
                        h = document.body.childNodes;
                    for (f.setAttribute("style", "width: 100%; max-height: 100%;"), d = 0; d < h.length; d++) c.isElement(h[d]) && (g[d] = h[d].style.display, h[d].style.display = "none");
                    return document.body.appendChild(f), window.print(), setTimeout(function() {
                        for (d = 0; d < h.length; d++) c.isElement(h[d]) && (h[d].style.display = g[d]);
                        document.body.removeChild(f), c.handleCallback(b, f)
                    }, e.delay), f
                },
                toJSON: function(a, b) {
                    var d = c.deepMerge({
                        dateFormat: c.config.dateFormat || "dateObject"
                    }, a || {}, !0);
                    d.data = d.data ? d.data : c.getChartData(d);
                    var e = JSON.stringify(d.data, void 0, " ");
                    return c.handleCallback(b, e), e
                },
                toCSV: function(a, b) {
                    function j(a, b) {
                        return "string" == typeof a && (f.escape && (a = a.replace('"', '""')), f.quotes && (a = ['"', a, '"'].join(""))), a
                    }
                    var d, e, f = c.deepMerge({
                            data: c.getChartData(a),
                            delimiter: ",",
                            quotes: !0,
                            escape: !0
                        }, a || {}, !0),
                        g = "",
                        h = [],
                        i = [];
                    for (l in f.data[0]) i.push(j(l)), h.push(l);
                    g += i.join(f.delimiter) + "\n";
                    for (d in f.data)
                        if (i = [], !isNaN(d)) {
                            for (e in h)
                                if (!isNaN(e)) {
                                    var k = h[e],
                                        l = f.data[d][k];
                                    i.push(j(l, k))
                                }
                            g += i.join(f.delimiter) + "\n"
                        }
                    return c.handleCallback(b, g), g
                },
                toXLSX: function(a, b) {
                    function g(a, b) {
                        b && (a += 1462);
                        var c = Date.parse(a);
                        return (c - new Date(Date.UTC(1899, 11, 30))) / 864e5
                    }

                    function h(a, b) {
                        for (var c = {}, d = {
                                s: {
                                    c: 1e7,
                                    r: 1e7
                                },
                                e: {
                                    c: 0,
                                    r: 0
                                }
                            }, e = 0; e != a.length; ++e)
                            for (var f = 0; f != a[e].length; ++f) {
                                d.s.r > e && (d.s.r = e), d.s.c > f && (d.s.c = f), d.e.r < e && (d.e.r = e), d.e.c < f && (d.e.c = f);
                                var h = {
                                    v: a[e][f]
                                };
                                if (null != h.v) {
                                    var i = XLSX.utils.encode_cell({
                                        c: f,
                                        r: e
                                    });
                                    "number" == typeof h.v ? h.t = "n" : "boolean" == typeof h.v ? h.t = "b" : h.v instanceof Date ? (h.t = "n", h.z = XLSX.SSF._table[14], h.v = g(h.v)) : h.t = "s", c[i] = h
                                }
                            }
                        return d.s.c < 1e7 && (c["!ref"] = XLSX.utils.encode_range(d)), c
                    }
                    var d = c.deepMerge({
                            name: "amCharts",
                            dateFormat: c.config.dateFormat || "dateObject",
                            withHeader: !0,
                            stringify: !1
                        }, a || {}, !0),
                        e = "",
                        f = {
                            SheetNames: [],
                            Sheets: {}
                        };
                    return d.data = d.data ? d.data : c.getChartData(d), f.SheetNames.push(d.name), f.Sheets[d.name] = h(c.toArray(d)), e = XLSX.write(f, {
                        bookType: "xlsx",
                        bookSST: !0,
                        type: "base64"
                    }), e = "data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64," + e, c.handleCallback(b, e), e
                },
                toArray: function(a, b) {
                    var d, e, f = c.deepMerge({
                            data: c.getChartData(a),
                            withHeader: !1,
                            stringify: !0
                        }, a || {}, !0),
                        g = [],
                        h = [];
                    for (e in f.data[0]) h.push(e);
                    f.withHeader && g.push(h);
                    for (d in f.data) {
                        var i = [];
                        if (!isNaN(d)) {
                            for (e in h)
                                if (!isNaN(e)) {
                                    var e = h[e],
                                        j = f.data[d][e];
                                    j = null == j ? "" : f.stringify ? String(j) : j, i.push(j)
                                }
                            g.push(i)
                        }
                    }
                    return c.handleCallback(b, g), g
                },
                toByteArray: function(a, b) {
                    function l(a) {
                        var b = a.charCodeAt(0);
                        return b === f ? 62 : b === g ? 63 : h > b ? -1 : h + 10 > b ? b - h + 26 + 26 : j + 26 > b ? b - j : i + 26 > b ? b - i + 26 : void 0
                    }

                    function m(a) {
                        function k(a) {
                            h[j++] = a
                        }
                        var b, c, d, f, g, h;
                        if (a.length % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                        var i = a.length;
                        g = "=" === a.charAt(i - 2) ? 2 : "=" === a.charAt(i - 1) ? 1 : 0, h = new e(3 * a.length / 4 - g), d = g > 0 ? a.length - 4 : a.length;
                        var j = 0;
                        for (b = 0, c = 0; d > b; b += 4, c += 3) f = l(a.charAt(b)) << 18 | l(a.charAt(b + 1)) << 12 | l(a.charAt(b + 2)) << 6 | l(a.charAt(b + 3)), k((16711680 & f) >> 16), k((65280 & f) >> 8), k(255 & f);
                        return 2 === g ? (f = l(a.charAt(b)) << 2 | l(a.charAt(b + 1)) >> 4, k(255 & f)) : 1 === g && (f = l(a.charAt(b)) << 10 | l(a.charAt(b + 1)) << 4 | l(a.charAt(b + 2)) >> 2, k(f >> 8 & 255), k(255 & f)), h
                    }
                    var d = c.deepMerge({}, a || {}),
                        e = "undefined" != typeof Uint8Array ? Uint8Array : Array,
                        f = "+".charCodeAt(0),
                        g = "/".charCodeAt(0),
                        h = "0".charCodeAt(0),
                        i = "a".charCodeAt(0),
                        j = "A".charCodeAt(0),
                        k = m(d.data);
                    return c.handleCallback(b, k), k
                },
                handleCallback: function(a) {
                    var b, d = Array();
                    if (a && a instanceof Function) {
                        for (b = 0; b < arguments.length; b++) b > 0 && d.push(arguments[b]);
                        a.apply(c, d)
                    }
                },
                handleDropbox: function(a) {
                    if (c.drawing.buffer.enabled)
                        if (a.preventDefault(), a.stopPropagation(), "dragover" == a.type) c.setup.wrapper.setAttribute("class", c.setup.chart.classNamePrefix + "-export-canvas active dropbox");
                        else if (c.setup.wrapper.setAttribute("class", c.setup.chart.classNamePrefix + "-export-canvas active"), "drop" == a.type && a.dataTransfer.files.length)
                        for (var b = 0; b < a.dataTransfer.files.length; b++) {
                            var d = new FileReader;
                            d.onloadend = function(b) {
                                return function() {
                                    c.drawing.handler.add({
                                        url: d.result,
                                        top: a.layerY - 10 * b,
                                        left: a.layerX - 10 * b
                                    })
                                }
                            }(b), d.readAsDataURL(a.dataTransfer.files[b])
                        }
                },
                getChartData: function(a) {
                    function i(a, e, f) {
                        function g(a, c) {
                            return -1 != b.dataFields.indexOf(a) ? g([a, ".", c].join("")) : a
                        }
                        a && b.exportTitles && "gantt" != c.setup.chart.type && (d = g(a, f), b.dataFieldsMap[d] = a, b.dataFields.push(d), b.titles[d] = e || d)
                    }
                    var d, e, f, g, b = c.deepMerge({
                            data: [],
                            titles: {},
                            dateFields: [],
                            dataFields: [],
                            dataFieldsMap: {},
                            exportTitles: c.config.exportTitles,
                            exportFields: c.config.exportFields,
                            exportSelection: c.config.exportSelection,
                            columnNames: c.config.columnNames
                        }, a || {}, !0),
                        h = ["valueField", "openField", "closeField", "highField", "lowField", "xField", "yField"];
                    if (0 == b.data.length)
                        if ("stock" == c.setup.chart.type) {
                            for (b.data = c.setup.chart.mainDataSet.dataProvider, i(c.setup.chart.mainDataSet.categoryField), b.dateFields.push(c.setup.chart.mainDataSet.categoryField), e = 0; e < c.setup.chart.mainDataSet.fieldMappings.length; e++) {
                                var j = c.setup.chart.mainDataSet.fieldMappings[e];
                                for (f = 0; f < c.setup.chart.panels.length; f++) {
                                    var k = c.setup.chart.panels[f];
                                    for (g = 0; g < k.stockGraphs.length; g++) {
                                        var l = k.stockGraphs[g];
                                        for (i4 = 0; i4 < h.length; i4++) l[h[i4]] == j.toField && i(j.fromField, l.title, h[i4])
                                    }
                                }
                            }
                            for (e = 0; e < c.setup.chart.comparedGraphs.length; e++) {
                                var l = c.setup.chart.comparedGraphs[e];
                                for (f = 0; f < l.dataSet.dataProvider.length; f++)
                                    for (g = 0; g < l.dataSet.fieldMappings.length; g++) {
                                        var j = l.dataSet.fieldMappings[g],
                                            d = l.dataSet.id + "_" + j.toField;
                                        f < b.data.length && (b.data[f][d] = l.dataSet.dataProvider[f][j.fromField], b.titles[d] || i(d, l.dataSet.title))
                                    }
                            }
                        } else if ("gantt" == c.setup.chart.type) {
                        i(c.setup.chart.categoryField), b.dateFields.push(c.setup.chart.categoryField);
                        var m = c.setup.chart.segmentsField;
                        for (e = 0; e < c.setup.chart.dataProvider.length; e++) {
                            var n = c.setup.chart.dataProvider[e];
                            if (n[m])
                                for (f = 0; f < n[m].length; f++) n[m][f][c.setup.chart.categoryField] = n[c.setup.chart.categoryField], b.data.push(n[m][f])
                        }
                        for (e = 0; e < c.setup.chart.graphs.length; e++) {
                            var l = c.setup.chart.graphs[e];
                            for (f = 0; f < h.length; f++) {
                                var o = h[f],
                                    p = l[o];
                                l.title;
                                i(p, l.title, o)
                            }
                        }
                    } else if (-1 != ["pie", "funnel"].indexOf(c.setup.chart.type)) b.data = c.setup.chart.dataProvider, i(c.setup.chart.titleField), b.dateFields.push(c.setup.chart.titleField), i(c.setup.chart.valueField);
                    else if ("map" != c.setup.chart.type)
                        for (b.data = c.setup.chart.dataProvider, c.setup.chart.categoryAxis && (i(c.setup.chart.categoryField, c.setup.chart.categoryAxis.title), c.setup.chart.categoryAxis.parseDates !== !1 && b.dateFields.push(c.setup.chart.categoryField)), e = 0; e < c.setup.chart.graphs.length; e++) {
                            var l = c.setup.chart.graphs[e];
                            for (f = 0; f < h.length; f++) {
                                var o = h[f],
                                    p = l[o];
                                i(p, l.title, o)
                            }
                        }
                    return c.processData(b)
                },
                processData: function(b) {
                    var e, f, d = c.deepMerge({
                        data: [],
                        titles: {},
                        dateFields: [],
                        dataFields: [],
                        dataFieldsMap: {},
                        dataDateFormat: c.setup.chart.dataDateFormat,
                        dateFormat: c.config.dateFormat || c.setup.chart.dataDateFormat || "YYYY-MM-DD",
                        exportTitles: c.config.exportTitles,
                        exportFields: c.config.exportFields,
                        exportSelection: c.config.exportSelection,
                        columnNames: c.config.columnNames
                    }, b || {}, !0);
                    if (d.data.length) {
                        for (e = 0; e < d.data.length; e++)
                            for (f in d.data[e]) - 1 == d.dataFields.indexOf(f) && (d.dataFields.push(f), d.dataFieldsMap[f] = f);
                        void 0 !== d.exportFields && (d.dataFields = d.dataFields.filter(function(a) {
                            return -1 != d.exportFields.indexOf(a)
                        }));
                        var g = [];
                        for (e = 0; e < d.data.length; e++) {
                            var h = {},
                                i = !1;
                            for (f = 0; f < d.dataFields.length; f++) {
                                var j = d.dataFields[f],
                                    k = d.dataFieldsMap[j],
                                    l = d.columnNames && d.columnNames[j] || d.titles[j] || j,
                                    m = d.data[e][k];
                                null == m && (m = void 0), d.exportTitles && "gantt" != c.setup.chart.type && l in h && (l += ["( ", j, " )"].join("")), -1 != d.dateFields.indexOf(k) && (d.dataDateFormat && (m instanceof String || "string" == typeof m) ? m = AmCharts.stringToDate(m, d.dataDateFormat) : d.dateFormat && (m instanceof Number || "number" == typeof m) && (m = new Date(m)), d.exportSelection && (m instanceof Date ? (m < a.startDate || m > a.endDate) && (i = !0) : (e < a.startIndex || e > a.endIndex) && (i = !0)), d.dateFormat && "dateObject" != d.dateFormat && m instanceof Date && (m = AmCharts.formatDate(m, d.dateFormat))), h[l] = m
                            }
                            i || g.push(h)
                        }
                        d.data = g
                    }
                    return d.data
                },
                capitalize: function(a) {
                    return a.charAt(0).toUpperCase() + a.slice(1).toLowerCase()
                },
                createMenu: function(b, d) {
                    function f(b, d) {
                        var e, g, h = document.createElement("ul");
                        for (e = 0; e < b.length; e++) {
                            var i = "string" == typeof b[e] ? {
                                    format: b[e]
                                } : b[e],
                                j = document.createElement("li"),
                                k = document.createElement("a"),
                                l = document.createElement("img"),
                                m = document.createElement("span"),
                                n = String(i.action ? i.action : i.format).toLowerCase();
                            if (i.format = String(i.format).toUpperCase(), c.config.formats[i.format] ? i = c.deepMerge({
                                    label: i.icon ? "" : i.format,
                                    format: i.format,
                                    mimeType: c.config.formats[i.format].mimeType,
                                    extension: c.config.formats[i.format].extension,
                                    capture: c.config.formats[i.format].capture,
                                    action: c.config.action,
                                    fileName: c.config.fileName
                                }, i) : i.label || (i.label = i.label ? i.label : c.i18l("menu.label." + n)), (-1 == ["CSV", "JSON", "XLSX"].indexOf(i.format) || -1 == ["map", "gauge"].indexOf(c.setup.chart.type)) && (c.setup.hasBlob || "UNDEFINED" == i.format || !i.mimeType || "image" == i.mimeType.split("/")[0] || "text/plain" == i.mimeType)) {
                                if ("draw" == i.action) c.config.fabric.drawing.enabled ? (i.menu = i.menu ? i.menu : c.config.fabric.drawing.menu, i.click = function(a) {
                                    return function() {
                                        this.capture(a, function() {
                                            this.createMenu(a.menu)
                                        })
                                    }
                                }(i)) : i.menu = [];
                                else if (!i.populated && i.action && -1 != i.action.indexOf("draw.")) {
                                    var o = i.action.split(".")[1],
                                        p = i[o] || c.config.fabric.drawing[o] || [];
                                    for (i.menu = [], i.populated = !0, g = 0; g < p.length; g++) {
                                        var q = {
                                            label: p[g]
                                        };
                                        if ("shapes" == o) {
                                            var r = -1 == p[g].indexOf("//"),
                                                s = (r ? c.config.path + "shapes/" : "") + p[g];
                                            q.action = "add", q.url = s, q.icon = s, q.ignore = r, q["class"] = "export-drawing-shape"
                                        } else "colors" == o ? (q.style = "background-color: " + p[g], q.action = "change", q.color = p[g], q["class"] = "export-drawing-color") : "widths" == o ? (q.action = "change", q.width = p[g], q.label = document.createElement("span"), q.label.style.width = c.numberToPx(p[g]), q.label.style.height = c.numberToPx(p[g]), q["class"] = "export-drawing-width") : "opacities" == o ? (q.style = "opacity: " + p[g], q.action = "change", q.opacity = p[g], q.label = 100 * p[g] + "%", q["class"] = "export-drawing-opacity") : "modes" == o && (q.label = c.i18l("menu.label.draw.modes." + p[g]), q.click = function(a) {
                                            return function() {
                                                c.drawing.mode = a
                                            }
                                        }(p[g]), q["class"] = "export-drawing-mode");
                                        i.menu.push(q)
                                    }
                                } else i.click || i.menu || i.items || (c.drawing.handler[n] instanceof Function ? (i.action = n, i.click = function(a) {
                                    return function() {
                                        this.drawing.handler[a.action](a)
                                    }
                                }(i)) : c.drawing.buffer.enabled ? i.click = function(a) {
                                    return function() {
                                        this.config.drawing.autoClose && this.drawing.handler.done(), this["to" + a.format](a, function(b) {
                                            "download" == a.action && this.download(b, a.mimeType, [a.fileName, a.extension].join("."))
                                        })
                                    }
                                }(i) : "UNDEFINED" != i.format && (i.click = function(a) {
                                    return function() {
                                        if (a.capture || "print" == a.action || "PRINT" == a.format) this.capture(a, function() {
                                            this.config.drawing.autoClose && this.drawing.handler.done(), this["to" + a.format](a, function(b) {
                                                "download" == a.action && this.download(b, a.mimeType, [a.fileName, a.extension].join("."))
                                            })
                                        });
                                        else {
                                            if (!this["to" + a.format]) throw new Error("Invalid format. Could not determine output type.");
                                            this["to" + a.format](a, function(b) {
                                                this.download(b, a.mimeType, [a.fileName, a.extension].join("."))
                                            })
                                        }
                                    }
                                }(i)));
                                (void 0 === i.menu || i.menu.length) && (k.setAttribute("href", "#"), k.addEventListener("click", function(a, b) {
                                    return function(d) {
                                        d.preventDefault();
                                        var e = [d, b];
                                        return ("draw" == b.action || "PRINT" == b.format || "UNDEFINED" != b.format && b.capture) && !c.drawing.enabled && (b.delay = b.delay ? b.delay : c.config.delay, b.delay) ? void c.delay(b, a) : void a.apply(c, e)
                                    }
                                }(i.click || function(a) {
                                    a.preventDefault()
                                }, i)), j.appendChild(k), c.isElement(i.label) ? m.appendChild(i.label) : m.innerHTML = i.label, i["class"] && (j.className = i["class"]), i.style && j.setAttribute("style", i.style), i.icon && (l.setAttribute("src", (i.ignore || -1 != i.icon.slice(0, 10).indexOf("//") ? "" : a.pathToImages) + i.icon), k.appendChild(l)), i.label && k.appendChild(m), i.title && k.setAttribute("title", i.title), c.config.menuReviver && (j = c.config.menuReviver.apply(c, [i, j])), i.elements = {
                                    li: j,
                                    a: k,
                                    img: l,
                                    span: m
                                }, (i.menu || i.items) && "draw" != i.action ? f(i.menu || i.items, j).childNodes.length && h.appendChild(j) : h.appendChild(j))
                            }
                        }
                        return h.childNodes.length && d.appendChild(h), h
                    }
                    return d || ("string" == typeof c.config.divId ? c.config.divId = d = document.getElementById(c.config.divId) : d = c.isElement(c.config.divId) ? c.config.divId : c.setup.chart.containerDiv), c.isElement(c.setup.menu) ? c.setup.menu.innerHTML = "" : c.setup.menu = document.createElement("div"), c.setup.menu.setAttribute("class", c.setup.chart.classNamePrefix + "-export-menu " + c.setup.chart.classNamePrefix + "-export-menu-" + c.config.position + " amExportButton"), c.config.menuWalker && (f = c.config.menuWalker), f.apply(this, [b, c.setup.menu]), c.setup.menu.childNodes.length && d.appendChild(c.setup.menu), c.setup.menu
                },
                delay: function(a, b) {
                    var e, f, d = c.deepMerge({
                            delay: 3,
                            precision: 2
                        }, a || {}),
                        g = Number(new Date),
                        h = c.createMenu([{
                            label: c.i18l("capturing.delayed.menu.label").replace("{{duration}}", AmCharts.toFixed(d.delay, d.precision)),
                            title: c.i18l("capturing.delayed.menu.title"),
                            "class": "export-delayed-capturing",
                            click: function() {
                                clearTimeout(e), clearTimeout(f), c.createMenu(c.config.menu)
                            }
                        }]),
                        i = h.getElementsByTagName("a")[0];
                    e = setInterval(function() {
                        var a = d.delay - (Number(new Date) - g) / 1e3;
                        0 >= a ? (clearTimeout(e), "draw" != d.action && c.createMenu(c.config.menu)) : i && (i.innerHTML = c.i18l("capturing.delayed.menu.label").replace("{{duration}}", AmCharts.toFixed(a, 2)))
                    }, 10), f = setTimeout(function() {
                        b.apply(c, arguments)
                    }, 1e3 * d.delay)
                },
                migrateSetup: function(a) {
                    function c(a) {
                        var d;
                        for (d in a) {
                            var e = a[d];
                            "export" == d.slice(0, 6) && e ? b.menu.push(d.slice(6)) : "userCFG" == d ? c(e) : "menuItems" == d ? b.menu = e : "libs" == d ? b.libs = e : "string" == typeof d && (b[d] = e)
                        }
                    }
                    var b = {
                        enabled: !0,
                        migrated: !0,
                        libs: {
                            autoLoad: !0
                        },
                        menu: []
                    };
                    return c(a), b
                },
                loadListeners: function() {
                    function a(a) {
                        a && (a.set({
                            top: a.top + 10,
                            left: a.left + 10
                        }), c.setup.fabric.add(a))
                    }
                    c.config.keyListener && "attached" != c.config.keyListener && (c.config.keyListener = "attached", document.addEventListener("keydown", function(b) {
                        var d = c.drawing.buffer.target;
                        8 != b.keyCode && 46 != b.keyCode || !d ? 27 == b.keyCode && c.drawing.enabled ? (b.preventDefault(), c.drawing.handler.done()) : 67 == b.keyCode && (b.metaKey || b.ctrlKey) && d ? c.drawing.buffer.copy = d : 88 == b.keyCode && (b.metaKey || b.ctrlKey) && d ? (c.drawing.buffer.copy = d, c.setup.fabric.remove(d)) : 86 == b.keyCode && (b.metaKey || b.ctrlKey) ? c.drawing.buffer.copy && a(c.drawing.buffer.copy.clone(a)) : 90 == b.keyCode && (b.metaKey || b.ctrlKey) && (b.preventDefault(), b.shiftKey ? c.drawing.handler.redo() : c.drawing.handler.undo()) : (b.preventDefault(), c.setup.fabric.remove(d))
                    })), c.config.fileListener && (c.setup.chart.containerDiv.addEventListener("dragover", c.handleDropbox), c.setup.chart.containerDiv.addEventListener("dragleave", c.handleDropbox), c.setup.chart.containerDiv.addEventListener("drop", c.handleDropbox))
                },
                init: function() {
                    clearTimeout(c.timer), c.timer = setInterval(function() {
                        c.setup.chart.containerDiv && (clearTimeout(c.timer), c.config.enabled && (c.setup.chart.AmExport = c, c.config.overflow && (c.setup.chart.div.style.overflow = "visible"), c.loadListeners(), c.createMenu(c.config.menu)))
                    }, AmCharts.updateRate)
                },
                construct: function() {
                    c.drawing.handler.cancel = c.drawing.handler.done;
                    try {
                        c.setup.hasBlob = !!new Blob
                    } catch (a) {}
                    window.safari = window.safari ? window.safari : {}, c.defaults.fabric.drawing.fontSize = c.setup.chart.fontSize || 11, c.config.drawing = c.deepMerge(c.defaults.fabric.drawing, c.config.drawing || {}, !0), c.deepMerge(c.defaults.fabric, c.config, !0), c.deepMerge(c.defaults.fabric, c.config.fabric || {}, !0), c.deepMerge(c.defaults.pdfMake, c.config, !0), c.deepMerge(c.defaults.pdfMake, c.config.pdfMake || {}, !0), c.deepMerge(c.libs, c.config.libs || {}, !0), c.config.drawing = c.defaults.fabric.drawing, c.config.fabric = c.defaults.fabric, c.config.pdfMake = c.defaults.pdfMake, c.config = c.deepMerge(c.defaults, c.config, !0), c.config.fabric.drawing.enabled && void 0 === c.config.fabric.drawing.menu && (c.config.fabric.drawing.menu = [], c.deepMerge(c.config.fabric.drawing.menu, [{
                        "class": "export-drawing",
                        menu: [{
                            label: c.i18l("menu.label.draw.add"),
                            menu: [{
                                label: c.i18l("menu.label.draw.shapes"),
                                action: "draw.shapes"
                            }, {
                                label: c.i18l("menu.label.draw.text"),
                                action: "text"
                            }]
                        }, {
                            label: c.i18l("menu.label.draw.change"),
                            menu: [{
                                label: c.i18l("menu.label.draw.modes"),
                                action: "draw.modes"
                            }, {
                                label: c.i18l("menu.label.draw.colors"),
                                action: "draw.colors"
                            }, {
                                label: c.i18l("menu.label.draw.widths"),
                                action: "draw.widths"
                            }, {
                                label: c.i18l("menu.label.draw.opacities"),
                                action: "draw.opacities"
                            }, "UNDO", "REDO"]
                        }, {
                            label: c.i18l("menu.label.save.image"),
                            menu: ["PNG", "JPG", "SVG", "PDF"]
                        }, "PRINT", "CANCEL"]
                    }])), void 0 === c.config.menu && (c.config.menu = [], c.deepMerge(c.config, {
                        menu: [{
                            "class": "export-main",
                            menu: [{
                                label: c.i18l("menu.label.save.image"),
                                menu: ["PNG", "JPG", "SVG", "PDF"]
                            }, {
                                label: c.i18l("menu.label.save.data"),
                                menu: ["CSV", "XLSX", "JSON"]
                            }, {
                                label: c.i18l("menu.label.draw"),
                                action: "draw",
                                menu: c.config.fabric.drawing.menu
                            }, {
                                format: "PRINT",
                                label: c.i18l("menu.label.print")
                            }]
                        }]
                    })), c.libs.path || (c.libs.path = c.config.path + "libs/"), c.isSupported() && (c.loadDependencies(c.libs.resources, c.libs.reload), c.setup.chart.addClassNames = !0, c.setup.chart[c.name] = c, c.init())
                }
            };
            if (b) c.config = b;
            else if (c.setup.chart[c.name]) c.config = c.setup.chart[c.name];
            else {
                if (!c.setup.chart.amExport && !c.setup.chart.exportConfig) return;
                c.config = c.migrateSetup(c.setup.chart.amExport || c.setup.chart.exportConfig)
            }
            return c.construct(), c.deepMerge(this, c)
        }
    }(), AmCharts.addInitHandler(function(a) {
        new AmCharts["export"](a)
    }, ["pie", "serial", "xy", "funnel", "radar", "gauge", "stock", "map", "gantt"]);;;;
angular.module('ccc-app').factory('chartIndicators', [function chartIndicatorsFactory() {
    var util = CCC.STATIC.UTIL;
    var colorOptions = util.chartColors;
    return {
        getColorOptions: function() {
            return colorOptions;
        },
        addOverlayChart: function(dataSet, panel, settings) {
            dataSet.fieldMappings.push({
                fromField: settings.type,
                toField: settings.type
            });
            panel.valueAxes.push({
                id: "a2",
                title: settings.name,
                position: "right",
                gridAlpha: 0,
                axisAlpha: 0.7,
                labelsEnabled: true
            });
            var socialDataGraph = {
                valueField: settings.type,
                valueAxis: "a2",
                lineColor: colorOptions.DarkGreen.Hex,
                lineThickness: 1,
                balloonText: settings.name + ":<b>[[" + settings.type + "]]</b>",
                bullet: "none",
                title: settings.name,
                useDataSetColors: false,
                visibleInLegend: false,
                legendValueText: "[[" + settings.type + "]]"
            }
            panel.stockGraphs.push(socialDataGraph);
        },
        bottomOBV: function(dataSet, panel, dataSetForIndicators, settings) {
            var volumeField = "volumefrom";
            var volumeColumnColor = settings.type + "VolumeColumnColor";
            dataSet.fieldMappings.push({
                fromField: volumeField,
                toField: volumeField
            });
            dataSet.fieldMappings.push({
                fromField: settings.type,
                toField: settings.type
            });
            panel.title = settings.fullName;
            var dataSetProvider = dataSet.dataProvider;
            var currentPoint = dataSetProvider[0];
            if (currentPoint["open"] == currentPoint["close"]) {
                dataSetProvider[0][settings.type] = 0;
                dataSetProvider[0][volumeColumnColor] = colorOptions.Blue.Hex;
            } else if (currentPoint["open"] > currentPoint["close"]) {
                dataSetProvider[0][settings.type] = -util.reduceFloatVal(currentPoint["volumefrom"]);
                dataSetProvider[0][volumeColumnColor] = colorOptions.Red.Hex;
            } else {
                dataSetProvider[0][settings.type] = util.reduceFloatVal(currentPoint["volumefrom"]);
                dataSetProvider[0][volumeColumnColor] = colorOptions.Green.Hex;
            }
            for (var i = 1; i < dataSetProvider.length; i++) {
                var currentPoint = dataSetProvider[i];
                if (currentPoint["open"] == currentPoint["close"]) {
                    dataSetProvider[i][volumeColumnColor] = colorOptions.Blue.Hex;
                    dataSetProvider[i][settings.type] = dataSetProvider[i - 1][settings.type];
                } else if (currentPoint["open"] > currentPoint["close"]) {
                    dataSetProvider[i][settings.type] = util.reduceFloatVal(dataSetProvider[i - 1][settings.type] - currentPoint["volumefrom"]);
                    dataSetProvider[i][volumeColumnColor] = colorOptions.Red.Hex;
                } else {
                    dataSetProvider[i][settings.type] = util.reduceFloatVal(dataSetProvider[i - 1][settings.type] + currentPoint["volumefrom"]);
                    dataSetProvider[i][volumeColumnColor] = colorOptions.Green.Hex;
                }
            }
            panel.valueAxes = [];
            panel.valueAxes.push({
                id: "a1",
                title: "Volume",
                position: "left",
                gridAlpha: 0,
                axisAlpha: 1,
                labelsEnabled: true
            });
            panel.valueAxes.push({
                id: "a2",
                title: "OBV",
                position: "right",
                gridAlpha: 0,
                axisAlpha: 1,
                labelsEnabled: true
            });
            var volumeFromGraph = {
                valueField: volumeField,
                valueAxis: "a1",
                useDataSetColors: false,
                balloonText: "Volume: <b>[[" + volumeField + "]]</b>",
                type: "column",
                fillAlphas: 0.4,
                lineAlpha: 0.7,
                title: "Volume",
                lineColorField: volumeColumnColor,
                fillColorsField: volumeColumnColor,
                fillAlphas: 0.4,
                lineAlpha: 0.7
            };
            var obvGraph = {
                valueField: settings.type,
                valueAxis: "a2",
                lineColor: colorOptions.Black.Hex,
                lineThickness: 1,
                balloonText: "On Balance Volume:<b>[[" + settings.type + "]]</b>",
                bullet: "none",
                title: "OBV",
                useDataSetColors: false
            }
            panel.stockGraphs.push(volumeFromGraph);
            panel.stockGraphs.push(obvGraph);
            dataSet.dataProvider = dataSetProvider;
        },
        bottomAroon: function(dataSet, panel, dataSetForIndicators, settings) {
            var aroonDown = settings.type + "Down";
            var aroonUp = settings.type + "Up";
            dataSet.fieldMappings.push({
                fromField: aroonDown,
                toField: aroonDown
            });
            dataSet.fieldMappings.push({
                fromField: aroonUp,
                toField: aroonUp
            });
            panel.title = settings.fullName;
            panel.stockGraphs = [{
                valueField: aroonDown,
                lineColor: colorOptions.Red.Hex,
                lineThickness: 1,
                balloonText: "Aaron Down:<b>[[" + aroonDown + "]]</b>",
                bullet: "none",
                title: "Aroon Down",
                useDataSetColors: false
            }, {
                valueField: aroonUp,
                lineColor: colorOptions.Green.Hex,
                lineThickness: 1,
                balloonText: "Aaron Up:<b>[[" + aroonUp + "]]</b>",
                bullet: "none",
                title: "Aroon Up",
                useDataSetColors: false
            }];
            var dataSetProvider = dataSet.dataProvider;
            dataSetProvider = dataSetForIndicators.concat(dataSetProvider);
            for (var i = 0; i < dataSetProvider.length; i++) {
                var highIndex = i;
                var lowIndex = i;
                var lowValue = dataSetProvider[i]['low'];
                var highValue = dataSetProvider[i]['high'];
                if (i >= settings.period) {
                    for (var j = i - (settings.period - 1); j <= i; j++) {
                        if (dataSetProvider[j]['low'] <= lowValue) {
                            lowValue = dataSetProvider[j]['low'];
                            lowIndex = j;
                        }
                        if (dataSetProvider[j]['high'] >= highValue) {
                            highValue = dataSetProvider[j]['high'];
                            highIndex = j;
                        }
                    }
                } else {
                    for (var j = 0; j <= i; j++) {
                        if (dataSetProvider[j]['low'] <= lowValue) {
                            lowValue = dataSetProvider[j]['low'];
                            lowIndex = j;
                        }
                        if (dataSetProvider[j]['high'] >= highValue) {
                            highValue = dataSetProvider[j]['high'];
                            highIndex = j;
                        }
                    }
                }
                dataSetProvider[i][aroonDown] = util.reduceFloatVal(((settings.period - (i - lowIndex)) / settings.period) * 100);
                dataSetProvider[i][aroonUp] = util.reduceFloatVal(((settings.period - (i - highIndex)) / settings.period) * 100);
            }
            dataSet.dataProvider = dataSetProvider.slice(dataSetForIndicators.length);
        },
        bottomStochasticO: function(dataSet, panel, dataSetForIndicators, settings) {
            var fieldK = settings.type + "K";
            var SMAFieldK = "SMAK" + settings.kSMAPeriod;
            var SMAFieldD = "SMAD" + settings.dSMAPeriod;
            var dataSetProvider = dataSet.dataProvider;
            dataSetProvider = dataSetForIndicators.concat(dataSetProvider);
            for (var i = 0; i < dataSetProvider.length; i++) {
                var high = dataSetProvider[i]['high'];
                var low = dataSetProvider[i]['low'];
                if (i >= settings.period) {
                    for (var j = i - (settings.period - 1); j <= i; j++) {
                        high = Math.max(dataSetProvider[j]['high'], high);
                        low = Math.min(dataSetProvider[j]['low'], low);
                    }
                } else {
                    for (var j = 0; j <= i; j++) {
                        high = Math.max(dataSetProvider[j]['high'], high);
                        low = Math.min(dataSetProvider[j]['low'], low);
                    }
                }
                if (high == low) {
                    dataSetProvider[i][fieldK] = 0;
                } else {
                    dataSetProvider[i][fieldK] = util.reduceFloatVal((dataSetProvider[i]['close'] - low) / (high - low) * 100);
                }
            }
            panel.title = settings.fullName;
            if (settings.kSMAPeriod == 0) {
                dataSet.fieldMappings.push({
                    fromField: fieldK,
                    toField: fieldK
                });
                var graphFieldK = {
                    valueField: fieldK,
                    useDataSetColors: false,
                    balloonText: "%K: <b>[[" + fieldK + "]]</b>",
                    lineThickness: 1,
                    lineColor: colorOptions.Black.Hex,
                    title: "%K"
                };
                panel.stockGraphs.push(graphFieldK);
                this.addSimpleMovingAverageDataPoints(dataSetProvider, settings.dSMAPeriod, fieldK, SMAFieldD);
            } else {
                dataSet.fieldMappings.push({
                    fromField: SMAFieldK,
                    toField: SMAFieldK
                });
                var graphSMAFieldK = {
                    valueField: SMAFieldK,
                    useDataSetColors: false,
                    balloonText: "%K(" + settings.kSMAPeriod + "): <b>[[" + SMAFieldK + "]]</b>",
                    lineThickness: 1,
                    lineColor: colorOptions.Black.Hex,
                    title: "%K(" + settings.kSMAPeriod + ")"
                };
                panel.stockGraphs.push(graphSMAFieldK);
                this.addSimpleMovingAverageDataPoints(dataSetProvider, settings.kSMAPeriod, fieldK, SMAFieldK);
                this.addSimpleMovingAverageDataPoints(dataSetProvider, settings.dSMAPeriod, SMAFieldK, SMAFieldD);
            }
            dataSet.fieldMappings.push({
                fromField: SMAFieldD,
                toField: SMAFieldD
            });
            var graphSMAFieldD = {
                valueField: SMAFieldD,
                useDataSetColors: false,
                balloonText: "%D(" + settings.dSMAPeriod + "): <b>[[" + SMAFieldD + "]]</b>",
                dashLength: 2,
                lineThickness: 1,
                lineColor: colorOptions.Red.Hex,
                title: "%D(" + settings.dSMAPeriod + ")"
            };
            panel.stockGraphs.push(graphSMAFieldD);
            dataSet.dataProvider = dataSetProvider.slice(dataSetForIndicators.length);
            panel.valueAxes = [];
            panel.valueAxes.push({
                guides: [{
                    value: 80,
                    toValue: 80,
                    dashLength: 5,
                    label: "Overbought",
                    position: "right",
                    fontSize: 9,
                    lineAlpha: 1,
                    lineThickness: 1,
                    color: colorOptions.Red.Hex,
                    lineColor: colorOptions.Red.Hex
                }, {
                    value: 50,
                    toValue: 50,
                    dashLength: 10,
                    lineAlpha: 0.8,
                    lineThickness: 1,
                    lineColor: colorOptions.Black.Hex
                }, {
                    value: 20,
                    toValue: 20,
                    dashLength: 5,
                    label: "Oversold",
                    position: "right",
                    fontSize: 9,
                    lineAlpha: 1,
                    lineThickness: 1,
                    color: colorOptions.Green.Hex,
                    lineColor: colorOptions.Green.Hex
                }]
            });
        },
        addSimpleMovingAverage: function(dataSet, panel, field, period, dataSetForIndicators, text) {
            var avgField = "SMA" + period;
            var graph = {};
            graph.valueField = avgField;
            graph.useDataSetColors = false;
            graph.balloonText = "SMA " + period + ":<b>[[value]]</b>";
            graph.lineThickness = 1;
            graph.visibleInLegend = false;
            switch (period) {
                case 5:
                    graph.lineColor = colorOptions.Orange.Hex;
                    break;
                case 13:
                    graph.lineColor = colorOptions.Black.Hex;
                    break;
                case 20:
                    graph.lineColor = colorOptions.Green.Hex;
                    break;
            };
            dataSet.fieldMappings.push({
                fromField: avgField,
                toField: avgField
            });
            var dataSetProvider = dataSet.dataProvider;
            dataSetProvider = dataSetForIndicators.concat(dataSetProvider);
            this.addSimpleMovingAverageDataPoints(dataSetProvider, period, field, avgField);
            dataSet.dataProvider = dataSetProvider.slice(dataSetForIndicators.length);
            panel.stockGraphs.push(graph);
        },
        addSimpleMovingAverageDataPoints: function(dataSetProvider, period, field, avgField) {
            for (var i = 0; i < dataSetProvider.length; i++) {
                var sum = 0;
                if (i >= period) {
                    for (var j = i - (period - 1); j <= i; j++) {
                        sum += dataSetProvider[j][field];
                    }
                    dataSetProvider[i][avgField] = util.reduceFloatVal(sum / period);
                } else {
                    for (var j = 0; j <= i; j++) {
                        sum += dataSetProvider[j][field];
                    }
                    dataSetProvider[i][avgField] = util.reduceFloatVal(sum / (i + 1));
                }
            }
        },
        addExponentialMovingAverage: function(dataSet, panel, field, period, dataSetForIndicators, text) {
            var avgField = "EMA" + period;
            var graph = {};
            graph.valueField = avgField;
            graph.useDataSetColors = false;
            graph.balloonText = "EMA " + period + ":<b>[[value]]</b>";
            graph.lineThickness = 1;
            graph.visibleInLegend = false;
            switch (period) {
                case 5:
                    graph.lineColor = colorOptions.Orange.Hex;
                    break;
                case 12:
                    graph.lineColor = colorOptions.Black.Hex;
                    break;
                case 26:
                    graph.lineColor = colorOptions.Green.Hex;
                    break;
            };
            dataSet.fieldMappings.push({
                fromField: avgField,
                toField: avgField
            });
            var dataSetProvider = dataSet.dataProvider;
            this.addExponentialMovingAverageDataPoints(dataSet.dataProvider, dataSetForIndicators, period, field, avgField)
            panel.stockGraphs.push(graph);
        },
        bottomMACD: function(dataSet, panel, dataSetForIndicators, settings) {
            var EMAField1 = "EMA" + settings.periodEMA1;
            var EMAField2 = "EMA" + settings.periodEMA2;
            var MACDLineField = settings.type + "Line";
            var MACDSignalLineField = settings.type + "SignalLine";
            var MACDHistogramField = settings.type + "Histogram";
            dataSet.fieldMappings.push({
                fromField: MACDLineField,
                toField: MACDLineField
            });
            dataSet.fieldMappings.push({
                fromField: MACDSignalLineField,
                toField: MACDSignalLineField
            });
            dataSet.fieldMappings.push({
                fromField: MACDHistogramField,
                toField: MACDHistogramField
            });
            panel.title = settings.fullName;
            var graphMACDLine = {
                valueField: MACDLineField,
                useDataSetColors: false,
                balloonText: "MACD Line: <b>[[" + MACDLineField + "]]</b>",
                lineThickness: 1,
                lineColor: colorOptions.Black.Hex,
                title: "Line"
            };
            var graphMACDSignalLine = {
                valueField: MACDSignalLineField,
                useDataSetColors: false,
                balloonText: "Signal Line: <b>[[" + MACDLineField + "]]</b>",
                dashLength: 2,
                lineThickness: 1,
                lineColor: colorOptions.Red.Hex,
                title: "Signal Line"
            };
            var graphMACDHistogram = {
                valueField: MACDHistogramField,
                useDataSetColors: false,
                balloonText: "MACD Histogram: <b>[[" + MACDHistogramField + "]]</b>",
                type: "column",
                fillAlphas: 0.5,
                lineColor: colorOptions.Green.Hex,
                negativeLineColor: colorOptions.Red.Hex,
                negativeFillColors: colorOptions.Red.Hex,
                title: "Histogram"
            };
            var dataSetForIndicatorsLocal = dataSetForIndicators.slice(0, dataSetForIndicators.length - settings.periodEMA3);
            var dataSetProviderLocal = dataSetForIndicators.slice(dataSetForIndicators.length - settings.periodEMA3).concat(dataSet.dataProvider);
            this.addExponentialMovingAverageDataPoints(dataSetProviderLocal, dataSetForIndicatorsLocal, settings.periodEMA1, 'close', EMAField1);
            this.addExponentialMovingAverageDataPoints(dataSetProviderLocal, dataSetForIndicatorsLocal, settings.periodEMA2, 'close', EMAField2);
            for (var i = 0; i < dataSetProviderLocal.length; i++) {
                dataSetProviderLocal[i][MACDLineField] = util.reduceFloatVal(dataSetProviderLocal[i][EMAField1] - dataSetProviderLocal[i][EMAField2]);
            };
            var dataSetForIndicatorsLocal = dataSetProviderLocal.slice(0, settings.periodEMA3);
            dataSetProviderLocal = dataSetProviderLocal.slice(settings.periodEMA3);
            this.addExponentialMovingAverageDataPoints(dataSetProviderLocal, dataSetForIndicatorsLocal, settings.periodEMA3, MACDLineField, MACDSignalLineField);
            for (var i = 0; i < dataSetProviderLocal.length; i++) {
                dataSetProviderLocal[i][MACDHistogramField] = util.reduceFloatVal(dataSetProviderLocal[i][MACDLineField] - dataSetProviderLocal[i][MACDSignalLineField]);
            };
            dataSet.dataProvider = dataSetProviderLocal;
            panel.stockGraphs.push(graphMACDLine);
            panel.stockGraphs.push(graphMACDSignalLine);
            panel.stockGraphs.push(graphMACDHistogram);
        },
        addExponentialMovingAverageDataPoints: function(dataSetProvider, dataSetForIndicators, period, field, avgField) {
            var sum = 0;
            var totalPoints = 0;
            var emaMultiplier = 2 / (period + 1);
            var firstEMA = 0;
            if (period > dataSetForIndicators.length) {
                if (dataSetForIndicators.length == 0) {
                    sum = dataSetProvider[0][field];
                    totalPoints = 1;
                } else {
                    for (var i = 0; i < dataSetForIndicators.length; i++) {
                        sum += dataSetProvider[i][field];
                    }
                    totalPoints = dataSetForIndicators.length;
                }
            } else {
                for (var i = dataSetForIndicators.length - period; i < dataSetForIndicators.length; i++) {
                    sum += dataSetProvider[i][field];
                }
                totalPoints = period;
            }
            firstEMA = util.reduceFloatVal(sum / totalPoints);
            dataSetProvider[0][avgField] = firstEMA;
            for (var i = 1; i < dataSetProvider.length; i++) {
                dataSetProvider[i][avgField] = util.reduceFloatVal((dataSetProvider[i][field] - dataSetProvider[i - 1][avgField]) * emaMultiplier + dataSetProvider[i - 1][avgField]);
            }
        },
        bottomADL: function(dataSet, panel, dataSetForIndicators, settings) {
            dataSet.fieldMappings.push({
                fromField: settings.type,
                toField: settings.type
            });
            panel.title = settings.fullName;
            panel.stockGraphs = [{
                valueField: settings.type,
                lineColor: colorOptions.Black.Hex,
                lineThickness: 1,
                balloonText: "Accu Dist:<b>[[" + settings.type + "]]</b>",
                bullet: "none",
                useDataSetColors: false
            }];
            var dataSetProvider = dataSet.dataProvider;
            dataSetProvider = dataSetForIndicators.concat(dataSetProvider);
            var currentPoint = dataSetProvider[0];
            if ((currentPoint["high"] - currentPoint["low"]) != 0) {
                dataSetProvider[0][settings.type] = util.reduceFloatVal(currentPoint["volumefrom"] * (((currentPoint["close"] - currentPoint["low"]) - (currentPoint["high"] - currentPoint["close"])) / (currentPoint["high"] - currentPoint["low"])));
            } else {
                dataSetProvider[0][settings.type] = util.reduceFloatVal(currentPoint["volumefrom"]);
            }
            for (var i = 1; i < dataSetProvider.length; i++) {
                var currentPoint = dataSetProvider[i];
                if ((currentPoint["high"] - currentPoint["low"]) != 0) {
                    dataSetProvider[i][settings.type] = util.reduceFloatVal(dataSetProvider[i - 1][settings.type] + currentPoint["volumefrom"] * (((currentPoint["close"] - currentPoint["low"]) - (currentPoint["high"] - currentPoint["close"])) / (currentPoint["high"] - currentPoint["low"])));
                } else {
                    dataSetProvider[i][settings.type] = util.reduceFloatVal(dataSetProvider[i - 1][settings.type]);
                }
            }
            dataSet.dataProvider = dataSetProvider.slice(dataSetForIndicators.length);
        },
        bottomRSI: function(dataSet, panel, dataSetForIndicators, settings) {
            var lineColor = "lineColor";
            dataSet.fieldMappings.push({
                fromField: settings.type,
                toField: settings.type
            });
            panel.title = settings.fullName;
            panel.stockGraphs = [{
                id: settings.type,
                valueField: settings.type,
                lineColorField: lineColor,
                lineThickness: 1,
                balloonText: settings.type + ":<b>[[" + settings.type + "]]</b>",
                bullet: "none",
                useDataSetColors: false
            }];
            dataSet.stockEvents = [];
            var dataSetProvider = dataSet.dataProvider;
            dataSetProvider = dataSetForIndicators.concat(dataSetProvider);
            for (var i = 0; i < dataSetProvider.length; i++) {
                var gainSum = 0;
                var lossSum = 0;
                if (i >= settings.period) {
                    for (var j = i - (settings.period - 1); j <= i; j++) {
                        var diffOpenClose = dataSetProvider[j]['close'] - dataSetProvider[j]['open'];
                        if (diffOpenClose > 0) {
                            gainSum += diffOpenClose;
                        }
                        if (diffOpenClose < 0) {
                            lossSum += Math.abs(diffOpenClose);
                        }
                    }
                } else {
                    for (var j = 0; j <= i; j++) {
                        var diffOpenClose = dataSetProvider[j]['close'] - dataSetProvider[j]['open'];
                        if (diffOpenClose > 0) {
                            gainSum += diffOpenClose;
                        }
                        if (diffOpenClose < 0) {
                            lossSum += Math.abs(diffOpenClose);
                        }
                    }
                }
                dataSetProvider[i][settings.type] = util.reduceFloatVal(100 - 100 / (1 + (gainSum / settings.period) / (lossSum / settings.period)));
            }
            panel.stockLegend.valueTextRegular = "[[" + settings.type + "]] " + settings.type;
            dataSet.dataProvider = dataSetProvider.slice(dataSetForIndicators.length);
            dataSetProvider = dataSet.dataProvider;
            var currentIndex = 0;
            var maxLength = dataSetProvider.length;
            while (currentIndex < maxLength - 1) {
                if (dataSetProvider[currentIndex][settings.type] > 70) {
                    var max = dataSetProvider[currentIndex][settings.type];
                    var dateForMax = dataSetProvider[currentIndex]['time'];
                    while (dataSetProvider[currentIndex][settings.type] > 70 && currentIndex < maxLength - 1) {
                        if (dataSetProvider[currentIndex][settings.type] > max) {
                            max = dataSetProvider[currentIndex][settings.type];
                            dateForMax = dataSetProvider[currentIndex]['time'];
                        }
                        dataSetProvider[currentIndex][lineColor] = colorOptions.Red.Hex;
                        currentIndex++;
                    }
                    dataSet.stockEvents.push({
                        date: new Date(dateForMax),
                        type: "arrowDown",
                        backgroundColor: colorOptions.Red.Hex,
                        borderColor: colorOptions.Red.Hex,
                        color: colorOptions.Red.Hex,
                        rollOverColor: colorOptions.LighRed.Hex,
                        graph: settings.type,
                        description: "Sell signal!"
                    });
                } else if (dataSetProvider[currentIndex][settings.type] < 30) {
                    var min = dataSetProvider[currentIndex][settings.type];
                    var dateForMin = dataSetProvider[currentIndex]['time'];
                    while (dataSetProvider[currentIndex][settings.type] < 30 && currentIndex < maxLength - 1) {
                        if (dataSetProvider[currentIndex][settings.type] < min) {
                            min = dataSetProvider[currentIndex][settings.type];
                            dateForMin = dataSetProvider[currentIndex]['time'];
                        }
                        dataSetProvider[currentIndex][lineColor] = colorOptions.Green.Hex;
                        currentIndex++;
                    }
                    dataSet.stockEvents.push({
                        date: new Date(dateForMin),
                        type: "arrowUp",
                        backgroundColor: colorOptions.Green.Hex,
                        borderColor: colorOptions.Green.Hex,
                        color: colorOptions.Green.Hex,
                        rollOverColor: colorOptions.DarkGreen.Hex,
                        graph: settings.type,
                        description: "Buy signal!"
                    });
                } else {
                    dataSetProvider[currentIndex][lineColor] = colorOptions.Black.Hex;
                    currentIndex++;
                }
            }
            panel.valueAxes = [];
            panel.valueAxes.push({
                guides: [{
                    value: 70,
                    toValue: 70,
                    dashLength: 5,
                    label: "Overbought",
                    position: "right",
                    fontSize: 9,
                    lineAlpha: 1,
                    lineThickness: 1,
                    color: colorOptions.Red.Hex,
                    lineColor: colorOptions.Red.Hex
                }, {
                    value: 30,
                    toValue: 30,
                    dashLength: 5,
                    label: "Oversold",
                    position: "right",
                    fontSize: 9,
                    lineAlpha: 1,
                    lineThickness: 1,
                    color: colorOptions.Green.Hex,
                    lineColor: colorOptions.Green.Hex
                }]
            });
        },
        addBollingerBands: function(dataSet, panel, field, period, dataSetForIndicators) {
            var avgFieldUp = "BBands" + period + "Up";
            var avgFieldDown = "BBands" + period + "Down";
            var squaredDifferance = "MediumSquared" + period;
            var sma = "SMABollBands" + period;
            var graphUp = {};
            var graphDown = {};
            var dataSetForIndicatorsLength = dataSetForIndicators.length;
            graphUp.valueField = avgFieldUp;
            graphUp.useDataSetColors = false;
            graphUp.balloonText = "BBand " + period + " Top:<b>[[value]]</b>";
            graphUp.lineThickness = 1;
            graphUp.visibleInLegend = false;
            graphDown.valueField = avgFieldDown;
            graphDown.useDataSetColors = false;
            graphDown.balloonText = "BBand " + period + " Bottom:<b>[[value]]</b>";
            graphDown.lineThickness = 1;
            graphDown.visibleInLegend = false;
            switch (period) {
                case 5:
                    graphUp.lineColor = colorOptions.Orange.Hex;
                    graphDown.lineColor = colorOptions.Orange.Hex;
                    break;
                case 13:
                    graphUp.lineColor = colorOptions.Black.Hex;
                    graphDown.lineColor = colorOptions.Black.Hex;
                    break;
                case 20:
                    graphUp.lineColor = colorOptions.Green.Hex;
                    graphDown.lineColor = colorOptions.Green.Hex;
                    break;
            };
            dataSet.fieldMappings.push({
                fromField: avgFieldUp,
                toField: avgFieldUp
            });
            dataSet.fieldMappings.push({
                fromField: avgFieldDown,
                toField: avgFieldDown
            });
            var dataSetProvider = dataSet.dataProvider;
            dataSetProvider = dataSetForIndicators.concat(dataSetProvider);
            for (var i = 0; i < dataSetProvider.length; i++) {
                var sum = 0;
                var sumSqrDiff = 0;
                if (i >= period) {
                    for (var j = i - (period - 1); j <= i; j++) {
                        sum += dataSetProvider[j][field];
                        if (j < i) {
                            sumSqrDiff += dataSetProvider[j][squaredDifferance];
                        }
                    }
                    var sqrDifference = dataSetProvider[i][field] - sum / period;
                    sqrDifference = sqrDifference * sqrDifference;
                    sumSqrDiff += sqrDifference;
                    dataSetProvider[i][squaredDifferance] = sqrDifference;
                    dataSetProvider[i][sma] = sum / period;
                    var deviation = Math.sqrt(sumSqrDiff / period);
                    dataSetProvider[i][avgFieldUp] = util.reduceFloatVal(dataSetProvider[i][sma] + 2 * deviation);
                    dataSetProvider[i][avgFieldDown] = util.reduceFloatVal(dataSetProvider[i][sma] - 2 * deviation);
                } else {
                    for (var j = 0; j <= i; j++) {
                        sum += dataSetProvider[j][field];
                        if (j < i) {
                            sumSqrDiff += dataSetProvider[j][squaredDifferance];
                        }
                    }
                    var sqrDifference = dataSetProvider[i][field] - sum / (i + 1);
                    sqrDifference = sqrDifference * sqrDifference;
                    sumSqrDiff += sqrDifference;
                    dataSetProvider[i][squaredDifferance] = sqrDifference;
                    dataSetProvider[i][sma] = sum / (i + 1);
                    var deviation = Math.sqrt(sumSqrDiff / (i + 1));
                    dataSetProvider[i][avgFieldUp] = util.reduceFloatVal(dataSetProvider[i][sma] + 2 * deviation);
                    dataSetProvider[i][avgFieldDown] = util.reduceFloatVal(dataSetProvider[i][sma] - 2 * deviation);
                }
            }
            dataSet.dataProvider = dataSetProvider.slice(dataSetForIndicators.length);
            panel.stockGraphs.push(graphUp);
            panel.stockGraphs.push(graphDown);
        },
        bottomVolatility: function(dataSet, panel, dataSetForIndicators, currentChartPeriod, settings) {
            var period = currentChartPeriod.indicatorPeriods.volatility;
            var fullPeriod = period * currentChartPeriod.aggregation;
            var periodType = currentChartPeriod.type;
            var volatilityField = "VOLALITY" + period + periodType;
            var volumeField = 'volumefrom';
            var volumeColumnColor = settings.type + "VolumeColumnColor";
            dataSet.fieldMappings.push({
                fromField: volatilityField,
                toField: volatilityField
            });
            dataSet.fieldMappings.push({
                fromField: volumeField,
                toField: volumeField
            });
            panel.title = settings.fullName;
            var field = 'close';
            var dataSetProvider = dataSet.dataProvider;
            dataSetProvider = dataSetForIndicators.concat(dataSetProvider);
            this.addVolatilityDataPoints(dataSetProvider, period, fullPeriod, periodType, field, volatilityField);
            panel.valueAxes = [];
            panel.valueAxes.push({
                id: "a1",
                title: "Volume",
                position: "left",
                gridAlpha: 0,
                axisAlpha: 1,
                labelsEnabled: true
            });
            panel.valueAxes.push({
                id: "a2",
                title: "Volatility ",
                position: "right",
                gridAlpha: 0,
                axisAlpha: 1,
                labelsEnabled: true
            });
            var pa = periodType === "day" ? "(p.a.)" : "";
            var volatilityGraph = {
                valueField: volatilityField,
                valueAxis: "a2",
                useDataSetColors: false,
                lineColor: colorOptions.Red.Hex,
                lineThickness: 1,
                balloonText: fullPeriod + "-" + periodType + " Volatility:<b>[[" + volatilityField + "]]% </b> " + pa,
                bullet: "none",
                title: "Volatility"
            };
            var volumeFromGraph = {
                valueField: volumeField,
                valueAxis: "a1",
                useDataSetColors: false,
                balloonText: "Volume: <b>[[" + volumeField + "]]</b>",
                type: "column",
                fillAlphas: 0.4,
                lineAlpha: 0.7,
                title: "Volume",
                lineColorField: volumeColumnColor,
                fillColorsField: volumeColumnColor,
                fillAlphas: 0.4,
                lineAlpha: 0.7
            };
            panel.stockGraphs.push(volumeFromGraph);
            panel.stockGraphs.push(volatilityGraph);
            dataSet.dataProvider = dataSetProvider.slice(dataSetForIndicators.length);
        },
        addVolatilityDataPoints: function(dataSetProvider, period, fullPeriod, periodType, field, volatilityField) {
            for (var i = 0; i < dataSetProvider.length; i++) {
                var sum = 0;
                if (i >= period) {
                    var avg = Math.log(dataSetProvider[i][field]) - Math.log(dataSetProvider[i - period + 1][field])
                    avg = avg / (period - 1);
                    var sqsum = 0;
                    for (var j = i - (period - 1); j < i; j++) {
                        var logChange = Math.log(dataSetProvider[j + 1][field]) - Math.log(dataSetProvider[j][field]);
                        sqsum += (logChange - avg) * (logChange - avg);
                    }
                    if (periodType === "day") {
                        sqsum = sqsum * 365 / fullPeriod;
                    }
                    dataSetProvider[i][volatilityField] = util.reduceFloatVal(Math.sqrt(sqsum / (period - 1)) * 100);
                } else if (i > 1) {
                    var avg = 0;
                    if (i > 1) {
                        avg = Math.log(dataSetProvider[i - 1][field]) - Math.log(dataSetProvider[0][field])
                        avg = avg / (i - 1);
                    }
                    var sqsum = 0;
                    for (var j = 0; j < i; j++) {
                        var logChange = Math.log(dataSetProvider[j + 1][field]) - Math.log(dataSetProvider[j][field]);
                        sqsum += (logChange - avg) * (logChange - avg);
                    }
                    if (periodType === "day") {
                        sqsum = sqsum * 365 / fullPeriod;
                    }
                    dataSetProvider[i][volatilityField] = util.reduceFloatVal(Math.sqrt(sqsum / (i - 1)) * 100);
                }
            }
        }
    };
}]);;;;
angular.module('ccc-app').controller('chartHistoAdvancedCtrl', ['$rootScope', '$scope', '$http', '$stateParams', '$location', 'subscriptionManager', 'chartUtil', 'chartIndicators', 'socialStats', 'cModalService', 'userManager', 'pageInfo', 'cccLightsService', function($rootScope, $scope, $http, $stateParams, $location, subscriptionManager, chartUtil, chartIndicators, socialStats, cModalService, userManager, pageInfo, cccLightsService) {
    $scope.userManager = userManager;
    $scope.zoomDates = {
        fromTS: 0,
        toTS: 0,
        zoom: false
    };
    $scope.firstChartLoad = true;
    $scope.chartStats = {
        pct: 0,
        chgValue: 0
    };
    $scope.drawingColorOptions = chartIndicators.getColorOptions();
    $scope.drawingColor = $scope.drawingColorOptions.Black.Hex;
    $scope.baseImagesPath = "/scripts/Vendor/AmCharts/";
    $scope.imagesToAdd = [{
        title: "Marker chevron down",
        path: $scope.baseImagesPath + "shapes/5.svg"
    }, {
        title: "Marker chevron up",
        path: $scope.baseImagesPath + "shapes/13.svg"
    }, {
        title: "Circle",
        path: $scope.baseImagesPath + "shapes/circle.svg"
    }, {
        title: "Highlight area",
        path: $scope.baseImagesPath + "shapes/square-transparent.svg"
    }, {
        title: "Fibonacci",
        path: $scope.baseImagesPath + "shapes/fibonacci.svg"
    }];
    $scope.chartTypes = [{
        key: 'CS',
        name: 'Candle Stick',
        shortName: 'Candle',
        icon: 'fa-bar-chart',
        extraClass: "pull-left",
        requiresLogin: false
    }, {
        key: 'LC',
        name: 'Line Chart',
        shortName: 'Line',
        icon: 'fa-line-chart',
        extraClass: "pull-right",
        requiresLogin: false
    }, {
        key: 'OHLC',
        name: 'OHLC',
        shortName: 'OHLC',
        icon: 'fa-bar-chart',
        extraClass: "pull-right",
        requiresLogin: true
    }];
    $scope.chartPeriod = [{
        key: '1H',
        name: '1 Hours',
        shortName: '1 H',
        maxPoints: 60,
        type: 'minute',
        allData: false,
        aggregation: 1,
        period: 'mm',
        polyfill: 60,
        requiresLogin: false,
        typeHasSocial: false,
        indicatorPeriods: {
            volatility: 10
        }
    }, {
        key: '1D',
        name: '1 Day',
        shortName: '1 D',
        maxPoints: 288,
        type: 'minute',
        allData: false,
        aggregation: 5,
        period: '5mm',
        polyfill: 5 * 60,
        requiresLogin: false,
        typeHasSocial: false,
        indicatorPeriods: {
            volatility: 6
        }
    }, {
        key: '2W',
        name: '2 Weeks',
        shortName: '2 W',
        maxPoints: 336,
        type: 'hour',
        allData: false,
        aggregation: 1,
        period: '1hh',
        polyfill: 60 * 60,
        requiresLogin: false,
        typeHasSocial: true,
        indicatorPeriods: {
            volatility: 12
        }
    }, {
        key: '1M',
        name: '1 Month',
        shortName: '1 M',
        maxPoints: 240,
        type: 'hour',
        allData: false,
        aggregation: 3,
        period: '3hh',
        polyfill: 3 * 60 * 60,
        requiresLogin: false,
        typeHasSocial: true,
        indicatorPeriods: {
            volatility: 8
        }
    }, {
        key: '3M',
        name: '3 Months',
        shortName: '3 M',
        maxPoints: 180,
        type: 'hour',
        allData: false,
        aggregation: 12,
        period: '12hh',
        polyfill: 12 * 60 * 60,
        requiresLogin: false,
        typeHasSocial: true,
        indicatorPeriods: {
            volatility: 4
        }
    }, {
        key: '6M',
        name: '6 Months',
        shortName: '6 M',
        maxPoints: 180,
        type: 'day',
        allData: false,
        aggregation: 1,
        period: 'DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true,
        typeHasSocial: true,
        indicatorPeriods: {
            volatility: 7
        }
    }, {
        key: '12M',
        name: '12 Months',
        shortName: '1 Y',
        maxPoints: 365,
        type: 'day',
        allData: false,
        aggregation: 1,
        period: 'DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true,
        typeHasSocial: true,
        indicatorPeriods: {
            volatility: 7
        }
    }, {
        key: '3Y',
        name: '3 Years',
        shortName: '3 Y',
        maxPoints: 157,
        type: 'day',
        allData: false,
        aggregation: 7,
        period: '7DD',
        polyfill: 7 * 24 * 60 * 60,
        requiresLogin: true,
        typeHasSocial: true,
        indicatorPeriods: {
            volatility: 4
        }
    }, {
        key: 'ALL',
        name: 'All Data',
        shortName: 'ALL',
        maxPoints: -1,
        allData: true,
        type: 'day',
        aggregation: 1,
        period: 'DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true,
        typeHasSocial: true,
        indicatorPeriods: {
            volatility: 7
        }
    }];
    $scope.chartIndicators = [{
        key: 'NI',
        name: 'No Indicator',
        fullName: 'Remove the current indicator',
        type: 'Clear',
        period: 0,
        requiresLogin: false,
        selected: false,
        dropdownId: -1
    }, {
        key: 'SMA5',
        name: 'SMA 5',
        fullName: 'Simple Moving Average 5',
        type: 'SMA',
        period: 5,
        requiresLogin: false,
        selected: false,
        dropdownId: -1
    }, {
        key: 'SMA13',
        name: 'SMA 13',
        fullName: 'Simple Moving Average 13',
        type: 'SMA',
        period: 13,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'SMA20',
        name: 'SMA 20',
        fullName: 'Simple Moving Average 20',
        type: 'SMA',
        period: 20,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'SMA30',
        name: 'SMA 30',
        fullName: 'Simple Moving Average 30',
        type: 'SMA',
        period: 30,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'SMA50',
        name: 'SMA 50',
        fullName: 'Simple Moving Average 50',
        type: 'SMA',
        period: 50,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'EMA5',
        name: 'EMA 5',
        fullName: 'Exponential Moving Average 5',
        type: 'EMA',
        period: 5,
        requiresLogin: false,
        selected: false,
        dropdownId: -1
    }, {
        key: 'EMA12',
        name: 'EMA 12',
        fullName: 'Exponential Moving Average 12',
        type: 'EMA',
        period: 12,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'EMA26',
        name: 'EMA 26',
        fullName: 'Exponential Moving Average 26',
        type: 'EMA',
        period: 26,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'EMA50',
        name: 'EMA 50',
        fullName: 'Exponential Moving Average 50',
        type: 'EMA',
        period: 50,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'BB5',
        name: 'BBands 5',
        fullName: 'Bollinger Bands 5',
        type: 'BBands',
        period: 5,
        requiresLogin: false,
        selected: false,
        dropdownId: -1
    }, {
        key: 'BB13',
        name: 'BBands 13',
        fullName: 'Bollinger Bands 13',
        type: 'BBands',
        period: 13,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }, {
        key: 'BB20',
        name: 'BBands 20',
        fullName: 'Bollinger Bands 20',
        type: 'BBands',
        period: 20,
        requiresLogin: true,
        selected: false,
        dropdownId: -1
    }];
    $scope.bottomChart = [{
        key: 'VF',
        name: 'Volume From',
        fullName: 'Total Volume From',
        type: 'Volume',
        period: 1,
        requiresLogin: false,
        selected: false
    }, {
        key: 'VT',
        name: 'Volume To',
        fullName: 'Total Volume To',
        type: 'VolumeTo',
        period: 1,
        requiresLogin: false,
        selected: false
    }, {
        key: 'RSI14',
        name: 'RSI 14',
        fullName: 'Relative Strength Index 14',
        type: 'RSI',
        period: 14,
        requiresLogin: true,
        selected: false
    }, {
        key: 'RSI21',
        name: 'RSI 21',
        fullName: 'Relative Strength Index 21',
        type: 'RSI',
        period: 21,
        requiresLogin: true,
        selected: false
    }, {
        key: 'VOLATILITY',
        name: 'Volatility',
        fullName: 'Volatility',
        type: 'VOLATILITY',
        period: 7,
        requiresLogin: true,
        selected: false
    }, {
        key: 'ADL',
        name: 'ADL',
        fullName: 'Accumulation Distribution Line',
        type: 'ADL',
        period: 1,
        requiresLogin: false,
        selected: false
    }, {
        key: 'MACD12269',
        name: 'MACD 12,26,9',
        fullName: 'Moving Average Convergence/Divergence Oscillator (12,26,9)',
        type: 'MACD',
        period: 35,
        periodEMA1: 12,
        periodEMA2: 26,
        periodEMA3: 9,
        requiresLogin: false,
        selected: false
    }, {
        key: 'StochO143',
        name: 'StochasticO Fast 14,3',
        fullName: 'Stochastic Oscillator Fast (14,3)',
        type: 'StochasticO',
        period: 14,
        kSMAPeriod: 0,
        dSMAPeriod: 3,
        requiresLogin: false,
        selected: false
    }, {
        key: 'StochO1433',
        name: 'StochasticO Slow 14,3,3',
        fullName: 'Stochastic Oscillator Slow (14,3,3)',
        type: 'StochasticO',
        period: 14,
        kSMAPeriod: 3,
        dSMAPeriod: 3,
        requiresLogin: true,
        selected: false
    }, {
        key: 'StochO1033',
        name: 'StochasticO Full 10,3,3',
        fullName: 'Stochastic Oscillator Full (10,3,3)',
        type: 'StochasticO',
        period: 10,
        kSMAPeriod: 3,
        dSMAPeriod: 3,
        requiresLogin: true,
        selected: false
    }, {
        key: 'StochO2055',
        name: 'StochasticO Full 20,5,5',
        fullName: 'Stochastic Oscillator Full (20,5,5)',
        type: 'StochasticO',
        period: 20,
        kSMAPeriod: 5,
        dSMAPeriod: 5,
        requiresLogin: true,
        selected: false
    }, {
        key: 'Aroon10',
        name: 'Aroon 10',
        fullName: 'Aroon 10 Days',
        type: 'Aroon',
        period: 10,
        requiresLogin: false,
        selected: false
    }, {
        key: 'Aroon25',
        name: 'Aroon 25',
        fullName: 'Aroon 25 Days',
        type: 'Aroon',
        period: 25,
        requiresLogin: true,
        selected: false
    }, {
        key: 'OBV',
        name: 'On Balance Volume',
        fullName: 'On Balance Volume (OBV)',
        type: 'OBV',
        period: 0,
        requiresLogin: false,
        selected: false
    }];
    $scope.chartIndicatorSelection = [{
        name: 'firstDropdown',
        type: "dropdown",
        requiresLogin: false
    }, {
        name: 'secondDropdown',
        type: "dropdown",
        requiresLogin: false
    }, {
        name: 'thirdDropdown',
        type: "dropdown",
        requiresLogin: true
    }, ];
    $scope.socialIndicator = [{
        key: 'ND',
        name: 'No Social Data',
        fullName: 'Remove the current social indicator',
        type: 'Clear',
        available: "Always",
        isHidden: false,
        requiresLogin: false,
        selected: false
    }, {
        key: 'CCCom',
        name: 'CC Comments',
        fullName: 'CryptoCompare comments',
        type: 'comments',
        available: "CryptoCompare",
        isHidden: true,
        requiresLogin: false,
        selected: false
    }, {
        key: 'CCPos',
        name: 'CC Posts',
        fullName: 'CryptoCompare posts',
        type: 'posts',
        available: "CryptoCompare",
        isHidden: true,
        requiresLogin: false,
        selected: false
    }, {
        key: 'CCFol',
        name: 'CryptoComp. Followers',
        fullName: 'CryptoCompare members that have followed the coin',
        type: 'followers',
        available: "CryptoCompare",
        isHidden: false,
        requiresLogin: false,
        selected: false
    }, {
        key: 'CCVie',
        name: 'CryptoComp. Views',
        fullName: 'CryptoCompare total page views across all the coin tabs',
        type: 'total_page_views',
        available: "CryptoCompare",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'FBLik',
        name: 'FB Likes',
        fullName: 'Facebook Likes',
        type: 'fb_likes',
        available: "Facebook",
        isHidden: false,
        requiresLogin: false,
        selected: false
    }, {
        key: 'FBTAbo',
        name: 'FB Talking About',
        fullName: 'Facebook users talking about the currency',
        type: 'fb_talking_about',
        available: "Facebook",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'TWFol',
        name: 'Twitter Followers',
        fullName: 'Twitter followers',
        type: 'twitter_followers',
        available: "Twitter",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'TWSta',
        name: 'Twitter Statuses',
        fullName: 'Twitter statuses',
        type: 'twitter_statuses',
        available: "Twitter",
        isHidden: false,
        requiresLogin: false,
        selected: false
    }, {
        key: 'RESub',
        name: 'Reddit Subscribers',
        fullName: 'Reddit subscribers',
        type: 'reddit_subscribers',
        available: "Reddit",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'REAUse',
        name: 'Reddit Active Users',
        fullName: 'Reddit active users',
        type: 'reddit_active_users',
        available: "Reddit",
        isHidden: false,
        requiresLogin: false,
        selected: false
    }, {
        key: 'REPHou',
        name: 'Reddit Posts/Hour',
        fullName: 'Reddit posts per hour as an average over the previous 100 posts',
        type: 'reddit_posts_per_hour',
        available: "Reddit",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'REPDay',
        name: 'Reddit Posts/Day',
        fullName: 'Reddit posts per day as an average over the previous 100 posts',
        type: 'reddit_posts_per_day',
        available: "Reddit",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'RECHou',
        name: 'Reddit Comments/Hour',
        fullName: 'Reddit comments per hour as an average over the previous 100 comments',
        type: 'reddit_comments_per_hour',
        isHidden: false,
        available: "Reddit",
        requiresLogin: true,
        selected: false
    }, {
        key: 'RECDay',
        name: 'Reddit Comments/Day',
        fullName: 'Reddit comments per day as an average over the previous 100 comments',
        type: 'reddit_comments_per_day',
        isHidden: false,
        available: "Reddit",
        requiresLogin: true,
        selected: false
    }, {
        key: 'CRSta',
        name: 'Code Repo Stars',
        fullName: 'Code repository stars',
        type: 'code_repo_stars',
        available: "CodeRepository",
        isHidden: false,
        requiresLogin: false,
        selected: false
    }, {
        key: 'CRFor',
        name: 'Code Repo Forks',
        fullName: 'Code repository forks',
        type: 'code_repo_forks',
        available: "CodeRepository",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'CROPul',
        name: 'Code Repo Open Pulls',
        fullName: 'Code repository open pull issues',
        type: 'code_repo_open_pull_issues',
        available: "CodeRepository",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }, {
        key: 'CRCPul',
        name: 'Code Repo Closed Pulls',
        fullName: 'Code repository closed pull issues',
        type: 'code_repo_closed_pull_issues',
        available: "CodeRepository",
        isHidden: false,
        requiresLogin: true,
        selected: false
    }];
    $scope.socialIndicator = $scope.socialIndicator.filter(function(obj) {
        if (obj.isHidden) {
            return false;
        }
        if (obj.available == "Always") {
            return true;
        }
        if (socialStats.getValueProperty(obj.available, 'Points') == 0) {
            return false;
        }
        return true;
    });
    $scope.socialDataSet = [];
    $scope.currentDataSet = [];
    $scope.availableExchanges = [];
    var maxChartIndicatorPeriod = ($scope.chartIndicators.concat($scope.bottomChart)).reduce(function(a, b) {
        return {
            period: Math.max(a.period, b.period)
        };
    }).period;
    var maxChartIndicatorSubPeriod = 0;
    for (var i = 0; i < $scope.chartPeriod.length; ++i) {
        var indicatorKeys = Object.keys($scope.chartPeriod[i].indicatorPeriods);
        for (var j = 0; j < indicatorKeys.length; ++j) {
            maxChartIndicatorSubPeriod = Math.max(maxChartIndicatorSubPeriod, $scope.chartPeriod[i].indicatorPeriods[indicatorKeys[j]]);
        }
    }
    $scope.maxIndicatorPeriod = Math.max(maxChartIndicatorPeriod, maxChartIndicatorSubPeriod);
    $scope.dataLoaded = false;
    $scope.dataIsLoading = true;
    $scope.socialDataLoaded = false;
    $scope.getByKey = function(key, dataSet, defaultIndex) {
        for (var i = 0, len = dataSet.length; i < len; i++) {
            if (dataSet[i].key == key) {
                return dataSet[i];
            }
        }
        return dataSet[defaultIndex];
    };
    $scope.generateMarketsFromCharts = function() {
        $scope.availableExchanges = [];
        var exchangeAlreadyExists = {};
        var allCharts = subscriptionManager.getCurrentChartDataSets();
        for (var i = 0, length = allCharts.length; i < length; i++) {
            var marketToPush = {
                'name': subscriptionManager.getNameForExchange(allCharts[i].exchange),
                'internalName': allCharts[i].exchange,
                'key': allCharts[i].exchange
            };
            if (!exchangeAlreadyExists.hasOwnProperty(marketToPush.name)) {
                $scope.availableExchanges.push(marketToPush);
                exchangeAlreadyExists[marketToPush.name] = true;
            }
        }
        $scope.availableExchanges.sort(function(a, b) {
            if (a.name > b.name) {
                return 1;
            }
            if (a.name < b.name) {
                return -1;
            }
            return 0;
        });
        $scope.availableExchanges.unshift({
            'name': subscriptionManager.getNameForExchange("CCCAGG"),
            'internalName': 'CCCAGG',
            'key': 'CCCAGG'
        });
    };
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getCurrentAggChartObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        $scope.computedChart = subscriptionManager.getCurrentAggChartByToSymbol($stateParams.Symbol.toUpperCase());
    } else {
        $scope.computedChart = subscriptionManager.getCurrentAggChart();
    }
    $scope.exchange = $scope.computedChart.exchange;
    $scope.fromsymbol = $scope.computedChart.fromsymbol;
    $scope.tosymbol = $scope.computedChart.tosymbol;
    $scope.generateMarketsFromCharts();
    var locationSearch = $location.search();
    if (locationSearch.hasOwnProperty('p')) {
        $scope.currentPeriod = $scope.getByKey(locationSearch['p'], $scope.chartPeriod, 3);
    } else {
        $scope.currentPeriod = $scope.chartPeriod[2];
    }
    if (locationSearch.hasOwnProperty('t')) {
        $scope.currentType = $scope.getByKey(locationSearch['t'], $scope.chartTypes, 0);
    } else {
        $scope.currentType = $scope.chartTypes[0];
    }
    if (locationSearch.hasOwnProperty('si')) {
        $scope.currentSocial = $scope.getByKey(locationSearch['si'], $scope.socialIndicator, 0);
    } else {
        $scope.currentSocial = $scope.socialIndicator[0];
    }
    if (locationSearch.hasOwnProperty('e')) {
        $scope.exchange = $scope.getByKey(locationSearch['e'], $scope.availableExchanges, 0).internalName;
    }
    if (locationSearch.hasOwnProperty('bc')) {
        var bottomChart = $scope.getByKey(locationSearch['bc'], $scope.bottomChart, 0);
        bottomChart.selected = true;
    } else {
        $scope.bottomChart[0].selected = true;
    }
    if (locationSearch.hasOwnProperty('ci0')) {
        var indicator = $scope.getByKey(locationSearch['ci0'], $scope.chartIndicators, 0);
        if (indicator.type != "Clear") {
            indicator.selected = true;
            indicator.dropdownId = 0;
        }
    }
    if (locationSearch.hasOwnProperty('ci1')) {
        var indicator = $scope.getByKey(locationSearch['ci1'], $scope.chartIndicators, 0);
        if (indicator.type != "Clear") {
            indicator.selected = true;
            indicator.dropdownId = 1;
        }
    }
    if (locationSearch.hasOwnProperty('ci2')) {
        var indicator = $scope.getByKey(locationSearch['ci2'], $scope.chartIndicators, 0);
        if (indicator.type != "Clear") {
            indicator.selected = true;
            indicator.dropdownId = 2;
        }
    }
    chartUtil.availableChartPeriods($scope.chartPeriod);
    chartUtil.setLoaded($scope.dataLoaded);
    chartUtil.setLoading($scope.dataIsLoading);
    chartUtil.saveCurrentPeriod($scope.currentPeriod);
    chartUtil.setFromSymbol($scope.fromsymbol);
    chartUtil.setToSymbol($scope.tosymbol);
    $scope.killListeners = function(changingView) {
        $scope.changeCurrency();
        $scope.changeView();
        $scope.changeLights();
    };
    $scope.getSelectedSocialIndicator = function() {
        return $scope.currentSocial.name;
    };
    $scope.getSelectedBottomChartName = function() {
        for (var i = 0, length = $scope.bottomChart.length; i < length; i++) {
            if ($scope.bottomChart[i].selected) {
                return $scope.bottomChart[i].name;
            }
        }
        return $scope.bottomChart[0].name;
    };
    $scope.getSelectedIndicatorName = function(dropdownId) {
        for (var i = 0, length = $scope.chartIndicators.length; i < length; i++) {
            if (dropdownId == $scope.chartIndicators[i].dropdownId) {
                return $scope.chartIndicators[i].name;
            }
        }
        return $scope.chartIndicators[0].name;
    };
    $scope.getSelectedMarketName = function() {
        for (var i = 0, length = $scope.availableExchanges.length; i < length; i++) {
            if ($scope.exchange == $scope.availableExchanges[i].internalName) {
                return $scope.availableExchanges[i].name;
            }
        }
        return $scope.availableExchanges[0].name;
    };
    $scope.isBottomChartSelected = function(index) {
        return $scope.bottomChart[index].selected;
    };
    $scope.isSocialIndicatorSelected = function(index) {
        return $scope.currentSocial.type == $scope.socialIndicator[index].type;
    };
    $scope.isMarketSelected = function(exchangeId) {
        return $scope.exchange == $scope.availableExchanges[exchangeId].internalName;
    };
    $scope.isIndicatorSelected = function(index) {
        return $scope.chartIndicators[index].selected;
    };
    $scope.handleNewSocialIndicator = function(index) {
        if ($scope.currentSocial.type == $scope.socialIndicator[index].type) {
            return;
        }
        if ($scope.socialIndicator[index].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to use the " + $scope.socialIndicator[index].name + " social indicator.");
        } else {
            $scope.currentSocial = $scope.socialIndicator[index];
            if ($scope.currentSocial.type != "Clear") {
                $location.search('si', $scope.currentSocial.key);
            } else {
                $location.search('si', null);
            }
            $scope.buildChart(false, !$scope.socialDataLoaded);
        }
    };
    $scope.handleNewBottomChart = function(index) {
        if ($scope.bottomChart[index].selected) {
            return;
        }
        if ($scope.bottomChart[index].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to use the " + $scope.bottomChart[index].name + " indicator.");
        } else {
            for (var i = 0, length = $scope.bottomChart.length; i < length; i++) {
                if ($scope.bottomChart[i].selected) {
                    $scope.bottomChart[i].selected = false;
                }
            }
            $scope.bottomChart[index].selected = true;
            $location.search('bc', $scope.bottomChart[index].key);
            $scope.buildChart(false, false);
        }
    };
    $scope.handleNewMarket = function(exchangeId) {
        if ($scope.exchange == $scope.availableExchanges[exchangeId].internalName) {
            return;
        }
        $scope.dataLoaded = false;
        chartUtil.setLoaded($scope.dataLoaded);
        $scope.exchange = $scope.availableExchanges[exchangeId].internalName;
        $location.search('e', $scope.exchange);
        $scope.buildChart(true, false);
    };
    $scope.handleNewIndicator = function(index, dropdownId) {
        if ($scope.chartIndicators[index].selected == true) {
            return false;
        }
        if (dropdownId == $scope.chartIndicators[index].dropdownId) {
            return;
        }
        if ($scope.chartIndicators[index].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to use the " + $scope.chartIndicators[index].name + " indicator.");
        } else {
            for (var i = 0, length = $scope.chartIndicators.length; i < length; i++) {
                if (dropdownId == $scope.chartIndicators[i].dropdownId) {
                    $scope.chartIndicators[i].selected = false;
                    $scope.chartIndicators[i].dropdownId = -1;
                }
            }
            if ($scope.chartIndicators[index].type != "Clear") {
                $scope.chartIndicators[index].selected = true;
                $scope.chartIndicators[index].dropdownId = dropdownId;
                $location.search('ci' + dropdownId, $scope.chartIndicators[index].key);
            } else {
                $location.search('ci' + dropdownId, null);
            }
            $scope.buildChart(false, false);
        }
    };
    $scope.handleNewSymbol = function(symbol) {
        if ($scope.tosymbol == symbol) {
            return;
        }
        $scope.dataLoaded = false;
        chartUtil.setLoaded($scope.dataLoaded);
        $scope.computedChart = subscriptionManager.getCurrentAggChart();
        $scope.exchange = $scope.computedChart.exchange;
        $scope.fromsymbol = $scope.computedChart.fromsymbol;
        $scope.tosymbol = $scope.computedChart.tosymbol;
        chartUtil.setToSymbol($scope.tosymbol);
        $scope.generateMarketsFromCharts();
        $scope.buildChart(true, false);
    };
    $scope.isPeriodSelected = function(periodId) {
        return chartUtil.isPeriodSelected(periodId);
    };
    $scope.handleNewPeriod = function(periodId) {
        if ($scope.currentPeriod.name == $scope.chartPeriod[periodId].name) {
            return;
        }
        if ($scope.chartPeriod[periodId].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to see the " + $scope.chartPeriod[periodId].name + " chart time period.");
        } else {
            $scope.currentPeriod = $scope.chartPeriod[periodId];
            $location.search('p', $scope.currentPeriod.key);
            $scope.buildChart(true, $scope.currentSocial.type != "Clear");
        }
    };
    $scope.isTypeSelected = function(typeId) {
        return $scope.currentType.name == $scope.chartTypes[typeId].name;
    };
    $scope.handleNewType = function(typeId) {
        if ($scope.currentType.name == $scope.chartTypes[typeId].name) {
            return;
        }
        if ($scope.chartTypes[typeId].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to use the " + $scope.chartTypes[typeId].name + " chart type.");
        } else {
            $scope.currentType = $scope.chartTypes[typeId];
            $location.search('t', $scope.currentType.key);
            $scope.buildChart(false, false);
        }
    };
    $scope.changeCurrency = $rootScope.$on("ChangeCurrency", function(event, symbol) {
        $scope.handleNewSymbol(symbol);
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.killListeners();
    });
    $scope.changeLights = $rootScope.$on("LightsChange", function() {
        $scope.generateNewChart();
    });
    $scope.generateNewChart = function() {
        var needsToZoomIn = true;
        var exportEnabled = !CCC.STATIC.UTIL.isMobile(navigator.userAgent);
        var defaultTheme = {
            backgroundColor: '#f9f9f9',
            color: '#000000'
        };
        $scope.drawingColor = $scope.drawingColorOptions.Black.Hex;
        if (!cccLightsService.isOn()) {
            defaultTheme.backgroundColor = '#1c1f21';
            defaultTheme.color = '#ffffff';
            $scope.drawingColor = $scope.drawingColorOptions.White.Hex;
        }
        var panEventsEnabled = exportEnabled;
        var fileNameForExport = $scope.currentPeriod.type + '_' + subscriptionManager.getNameForExchange($scope.exchange).replace(' ', '_') + '_' + $scope.fromsymbol + '_' + $scope.tosymbol + '_' + $scope.currentDataSet.length + '_' + $scope.currentPeriod.aggregation
        $scope.chartConfig = {
            type: "stock",
            theme: "none",
            addClassNames: true,
            panEventsEnabled: panEventsEnabled,
            pathToImages: "/images/",
            categoryAxesSettings: {
                minPeriod: $scope.currentPeriod.period,
                maxSeries: $scope.currentDataSet.length + $scope.maxIndicatorPeriod + 10,
                labelsEnabled: !panEventsEnabled,
                parseDates: true,
                equalSpacing: true
            },
            dataSets: [{
                color: '#006098',
                fieldMappings: [],
                dataProvider: $scope.currentDataSet,
                addClassNames: true,
                categoryField: "timeDate"
            }],
            panels: [{
                showCategoryAxis: false,
                title: subscriptionManager.getNameForExchange($scope.exchange) + ' : ' + $scope.fromsymbol,
                percentHeight: 63,
                color: defaultTheme.color,
                stockGraphs: [],
                categoryAxis: {
                    gridColor: defaultTheme.color,
                    gridAlpha: 0.2,
                    axisAlpha: 1
                },
                valueAxes: [{
                    id: "a1",
                    title: "Price",
                    position: "left",
                    gridAlpha: 0.2,
                    axisAlpha: 1,
                    gridColor: defaultTheme.color
                }],
                stockLegend: {
                    color: defaultTheme.color,
                    markerType: "none"
                }
            }, {
                categoryAxis: {
                    gridColor: defaultTheme.color,
                    gridAlpha: 0.2,
                    axisAlpha: 1
                },
                valueAxes: [{
                    gridAlpha: 0.2,
                    axisAlpha: 1,
                    gridColor: defaultTheme.color
                }],
                percentHeight: 37,
                color: defaultTheme.color,
                stockGraphs: [],
                stockLegend: {
                    color: defaultTheme.color,
                    markerType: "none"
                }
            }],
            panelsSettings: {
                panEventsEnabled: panEventsEnabled
            },
            chartScrollbarSettings: {
                graph: "base",
                graphType: "line",
                usePeriod: $scope.currentPeriod.period,
                updateOnReleaseOnly: true,
                enabled: panEventsEnabled,
                oppositeAxis: false,
                backgroundColor: "#444",
                backgroundAlpha: 0.7,
                graphFillAlpha: 0.5,
                graphLineAlpha: 0.5,
                selectedBackgroundColor: "#ffffff",
                selectedBackgroundAlpha: 0.4,
                selectedGraphFillAlpha: 0,
                selectedGraphLineAlpha: 1,
                autoGridCount: true,
                gridAlpha: 0.15,
                height: 30
            },
            chartCursorSettings: {
                valueBalloonsEnabled: true,
                zoomable: panEventsEnabled,
                valueLineEnabled: true,
                valueLineBalloonEnabled: true,
                categoryBalloonDateFormats: [{
                    period: 'fff',
                    format: 'JJ:NN:SS'
                }, {
                    period: 'ss',
                    format: 'JJ:NN:SS'
                }, {
                    period: 'mm',
                    format: 'JJ:NN'
                }, {
                    period: 'hh',
                    format: 'MMM DD, JJ:NN'
                }, {
                    period: 'DD',
                    format: 'MMM DD'
                }, {
                    period: 'WW',
                    format: 'YYYY MMM DD'
                }, {
                    period: 'MM',
                    format: 'YYYY MMM'
                }, {
                    period: 'YYYY',
                    format: 'YYYY'
                }]
            },
            panelsSettings: {
                usePrefixes: false
            },
            export: {
                enabled: exportEnabled,
                path: $scope.baseImagesPath,
                backgroundColor: defaultTheme.backgroundColor,
                drawing: {
                    enabled: true,
                    color: $scope.drawingColor,
                    opacity: 1,
                    mode: "line",
                    arrow: "end",
                    fontSize: 14,
                    autoClose: true
                },
                menu: $scope.advancedChartMenu(),
                menuReviver: function(item, li) {
                    if (item.hasOwnProperty("title")) {
                        li.setAttribute("title", item.title);
                    }
                    if (item.hasOwnProperty("idHtml")) {
                        li.id = item.idHtml;
                    }
                    return li;
                },
                fileName: fileNameForExport
            }
        };
        if ($scope.currentType.name == $scope.chartTypes[0].name) {
            chartUtil.topCandleStick($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], $scope.tosymbol);
        } else if ($scope.currentType.name == $scope.chartTypes[1].name) {
            chartUtil.topLine($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], $scope.tosymbol, false);
        } else if ($scope.currentType.name == $scope.chartTypes[2].name) {
            chartUtil.topOHLC($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], $scope.tosymbol);
        }
        for (var i = 0, length = $scope.chartIndicators.length; i < length; i++) {
            if ($scope.chartIndicators[i].selected) {
                switch ($scope.chartIndicators[i].type) {
                    case "SMA":
                        chartIndicators.addSimpleMovingAverage($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], 'close', $scope.chartIndicators[i].period, $scope.dataSetForIndicators);
                        break;
                    case "EMA":
                        chartIndicators.addExponentialMovingAverage($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], 'close', $scope.chartIndicators[i].period, $scope.dataSetForIndicators);
                        break;
                    case "BBands":
                        chartIndicators.addBollingerBands($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], 'close', $scope.chartIndicators[i].period, $scope.dataSetForIndicators);
                        break;
                }
            }
        }
        if ($scope.currentSocial.type != "Clear") {
            chartIndicators.addOverlayChart($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], $scope.currentSocial);
        }
        for (var i = 0, length = $scope.bottomChart.length; i < length; i++) {
            if ($scope.bottomChart[i].selected) {
                switch ($scope.bottomChart[i].type) {
                    case "Volume":
                        chartUtil.bottomVolume($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.fromsymbol);
                        break;
                    case "VolumeTo":
                        chartUtil.bottomVolumeTo($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.tosymbol);
                        break;
                    case "RSI":
                        chartIndicators.bottomRSI($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.dataSetForIndicators, $scope.bottomChart[i]);
                        break;
                    case "VOLATILITY":
                        chartIndicators.bottomVolatility($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.dataSetForIndicators, $scope.currentPeriod, $scope.bottomChart[i]);
                        break;
                    case "ADL":
                        chartIndicators.bottomADL($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.dataSetForIndicators, $scope.bottomChart[i]);
                        break;
                    case "MACD":
                        chartIndicators.bottomMACD($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.dataSetForIndicators, $scope.bottomChart[i]);
                        break;
                    case "StochasticO":
                        chartIndicators.bottomStochasticO($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.dataSetForIndicators, $scope.bottomChart[i]);
                        break;
                    case "Aroon":
                        chartIndicators.bottomAroon($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.dataSetForIndicators, $scope.bottomChart[i]);
                        break;
                    case "OBV":
                        chartIndicators.bottomOBV($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.dataSetForIndicators, $scope.bottomChart[i]);
                        break;
                }
            }
        }
        $scope.chart = AmCharts.makeChart($scope.chartid, $scope.chartConfig);
        $scope.chart.addListener("zoomed", function(event) {
            $scope.zoomDates.fromTS = event.startDate.getTime() / 1000;
            $scope.zoomDates.toTS = event.endDate.getTime() / 1000;
            $scope.zoomDates.zoom = true;
            if ($scope.currentPeriod.allData == true) {
                $location.search('fTs', $scope.zoomDates.fromTS);
                $location.search('tTs', $scope.zoomDates.toTS);
            } else {
                $location.search('fTs', null);
                $location.search('tTs', null);
            }
        });
        if ($scope.zoomDates.zoom && $scope.zoomDates.fromTS > 0 && $scope.zoomDates.toTS > 0) {
            $scope.chart.zoom(new Date($scope.zoomDates.fromTS * 1000), new Date($scope.zoomDates.toTS * 1000));
        }
    };
    $scope.buildChart = function(updateData, updateSocial) {
        if (!subscriptionManager.hasSubs()) {
            return;
        }
        if (updateSocial && !$scope.currentPeriod.typeHasSocial) {
            updateSocial = false;
        }
        if (!updateData && $scope.currentDataSet.length > 0) {
            if (updateSocial) {
                $scope.getSocialData();
            } else {
                $scope.generateNewChart();
            }
        } else {
            if ($scope.firstChartLoad) {
                $scope.firstChartLoad = false;
            } else {
                $scope.zoomDates.zoom = false;
            }
            $scope.getHistoData(updateSocial);
        }
    };
    $scope.decorateWithSocialData = function() {
        var totalDataPoints = $scope.currentDataSet.length;
        var totalSocialDataPoints = $scope.socialDataSet.length;
        if (totalDataPoints == 0 || totalSocialDataPoints == 0) {
            return;
        }
        if (totalSocialDataPoints == totalDataPoints) {
            for (var i = 0; i < totalDataPoints; i++) {
                if ($scope.currentDataSet[i].time == $scope.socialDataSet[i].time) {
                    if ($scope.socialDataSet[i].points > 0) {
                        for (var attrname in $scope.socialDataSet[i]) {
                            $scope.currentDataSet[i][attrname] = $scope.socialDataSet[i][attrname];
                        }
                    }
                }
            }
        } else if (totalSocialDataPoints < totalDataPoints) {
            var firstSocialPointTs = $scope.socialDataSet[0].time;
            var currentDataTs = $scope.currentDataSet[0].time;
            var currentDataIndex = 0;
            while (firstSocialPointTs > currentDataTs && currentDataIndex < totalDataPoints) {
                currentDataIndex = currentDataIndex + 1;
                currentDataTs = $scope.currentDataSet[currentDataIndex].time;
            }
            for (var i = currentDataIndex; i < totalDataPoints; i++) {
                var socialIndex = i - currentDataIndex;
                if (socialIndex >= totalSocialDataPoints) {
                    continue;
                }
                if ($scope.currentDataSet[i].time == $scope.socialDataSet[socialIndex].time) {
                    if ($scope.socialDataSet[socialIndex].points > 0) {
                        for (var attrname in $scope.socialDataSet[socialIndex]) {
                            $scope.currentDataSet[i][attrname] = $scope.socialDataSet[socialIndex][attrname];
                        }
                    }
                }
            }
        }
    };
    $scope.getSocialData = function() {
        $scope.dataIsLoading = true;
        chartUtil.getSocialHistoFromApi($scope.currentPeriod.type, pageInfo.getPageId(), $scope.currentDataSet.length, $scope.currentPeriod.aggregation).success(function(data) {
            $scope.socialDataSet = chartUtil.polyfillSocialData(data, $scope.currentPeriod.polyfill);
            if ($scope.socialDataSet.length - 1 == $scope.currentDataSet.length) {
                $scope.socialDataSet.shift();
            }
            $scope.decorateWithSocialData();
            $scope.generateNewChart();
            $scope.dataIsLoading = false;
            $scope.socialDataLoaded = true;
            chartUtil.saveCurrentPeriod($scope.currentPeriod);
            chartUtil.saveCurrentData($scope.currentDataSet);
            chartUtil.setLoading($scope.dataIsLoading);
            chartUtil.setLoaded($scope.dataLoaded);
        });
    };
    $scope.getHistoData = function(updateSocial) {
        $scope.dataIsLoading = true;
        chartUtil.setLoading($scope.dataIsLoading);
        var pointsToRequest = false;
        if (!$scope.currentPeriod.allData) {
            pointsToRequest = $scope.currentPeriod.maxPoints + $scope.maxIndicatorPeriod;
        }
        chartUtil.getHistoFromMinApi($scope.currentPeriod.type, $scope.exchange, $scope.fromsymbol, $scope.tosymbol, pointsToRequest, $scope.currentPeriod.aggregation).success(function(data) {
            if (!$scope.currentPeriod.allData) {
                $scope.currentDataSet = chartUtil.polyfillChartData(data, $scope.currentPeriod.polyfill, $scope.maxIndicatorPeriod + 1);
                chartUtil.setChartStats($scope.currentDataSet.stats);
                $scope.chartStats = chartUtil.getChartStats();
                $scope.currentDataSet = $scope.currentDataSet.data;
                $scope.dataSetForIndicators = $scope.currentDataSet.slice(0, $scope.maxIndicatorPeriod);
                $scope.currentDataSet = $scope.currentDataSet.slice($scope.maxIndicatorPeriod);
            } else {
                $scope.currentDataSet = chartUtil.polyfillChartData(data, $scope.currentPeriod.polyfill, 0);
                chartUtil.setChartStats($scope.currentDataSet.stats);
                $scope.chartStats = chartUtil.getChartStats();
                $scope.currentDataSet = $scope.currentDataSet.data;
                $scope.dataSetForIndicators = [];
            }
            if (!updateSocial) {
                if ($scope.socialDataSet.length > 0) {
                    $scope.decorateWithSocialData();
                }
                $scope.generateNewChart();
                $scope.dataLoaded = true;
                $scope.dataIsLoading = false;
                chartUtil.saveCurrentPeriod($scope.currentPeriod);
                chartUtil.saveCurrentData($scope.currentDataSet);
                chartUtil.setLoading($scope.dataIsLoading);
                chartUtil.setLoaded($scope.dataLoaded);
            } else {
                $scope.getSocialData();
            }
        });
    };
    $scope.addActiveClassToDrawingTool = function(type) {
        var line = document.getElementById("draw_line");
        if (type == "line") {
            line.className = line.className + " active";
        } else {
            line.className = line.className.replace(/\b active\b/, '');
        }
        var arrow = document.getElementById("draw_arrow");
        if (type == "arrow") {
            arrow.className = arrow.className + " active";
        } else {
            arrow.className = arrow.className.replace(/\b active\b/, '');
        }
        var pencil = document.getElementById("draw_pencil");
        if (type == "pencil") {
            pencil.className = pencil.className + " active";
        } else {
            pencil.className = pencil.className.replace(/\b active\b/, '');
        }
    };
    $scope.advancedChartMenu = function() {
        return [{
            label: "<i class='fa fa-minus'></i>",
            idHtml: "draw_line",
            title: "Draw Line",
            class: "drawing-line",
            click: function() {
                $scope.addActiveClassToDrawingTool("line");
                if (!this.drawing.buffer.enabled) {
                    this.capture({
                        action: "draw",
                        drawing: {
                            mode: "line"
                        }
                    }, function() {});
                } else {
                    this.drawing.handler.change({
                        mode: "line"
                    }, false);
                }
            }
        }, {
            label: "<i class='fa fa-long-arrow-right'></i>",
            idHtml: "draw_arrow",
            class: "drawing-arrow",
            title: "Draw Arrow",
            click: function() {
                $scope.addActiveClassToDrawingTool("arrow");
                if (!this.drawing.buffer.enabled) {
                    this.capture({
                        action: "draw",
                        drawing: {
                            mode: "arrow"
                        }
                    }, function() {});
                } else {
                    this.drawing.handler.change({
                        mode: "arrow"
                    }, false);
                }
            }
        }, {
            label: "<i class='fa fa-pencil'></i>",
            idHtml: "draw_pencil",
            class: "drawing-pencil",
            title: "Draw Pencil",
            click: function() {
                $scope.addActiveClassToDrawingTool("pencil");
                if (!this.drawing.buffer.enabled) {
                    this.capture({
                        action: "draw",
                        drawing: {
                            mode: "pencil"
                        }
                    }, function() {});
                } else {
                    this.drawing.handler.change({
                        mode: "pencil"
                    }, false);
                }
            }
        }, {
            label: "<i class='fa fa-font'></i>",
            title: "Add text",
            class: "drawing-text",
            click: function() {
                if (!this.drawing.buffer.enabled) {
                    $scope.addActiveClassToDrawingTool("line");
                    this.capture({
                        action: "draw",
                        drawing: {
                            mode: "line"
                        }
                    }, function() {
                        this.drawing.handler.text({
                            top: 100,
                            text: 'Add your text...'
                        });
                    });
                } else {
                    this.drawing.handler.text({
                        top: 100,
                        text: 'Add your text...'
                    });
                }
            }
        }, {
            label: "<i class='fa fa-plus'></i>",
            title: "Add shape",
            class: "drawing-shape",
            menu: [{
                label: "<img src='" + $scope.imagesToAdd[0].path + "'>",
                title: $scope.imagesToAdd[0].title,
                click: function() {
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.add({
                                url: $scope.imagesToAdd[0].path
                            });
                        });
                    } else {
                        this.drawing.handler.add({
                            url: $scope.imagesToAdd[0].path
                        });
                    }
                }
            }, {
                label: "<img src='" + $scope.imagesToAdd[1].path + "'>",
                title: $scope.imagesToAdd[1].title,
                click: function() {
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.add({
                                url: $scope.imagesToAdd[1].path
                            });
                        });
                    } else {
                        this.drawing.handler.add({
                            url: $scope.imagesToAdd[1].path
                        });
                    }
                }
            }, {
                label: "<img src='" + $scope.imagesToAdd[2].path + "'>",
                title: $scope.imagesToAdd[2].title,
                click: function() {
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.add({
                                url: $scope.imagesToAdd[2].path
                            });
                        });
                    } else {
                        this.drawing.handler.add({
                            url: $scope.imagesToAdd[2].path
                        });
                    }
                }
            }, {
                label: "<img src='" + $scope.imagesToAdd[3].path + "'>",
                title: $scope.imagesToAdd[3].title,
                click: function() {
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.add({
                                url: $scope.imagesToAdd[3].path
                            });
                        });
                    } else {
                        this.drawing.handler.add({
                            url: $scope.imagesToAdd[3].path
                        });
                    }
                }
            }, {
                label: "<img src='" + $scope.imagesToAdd[4].path + "'>",
                title: $scope.imagesToAdd[4].title,
                click: function() {
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.add({
                                url: $scope.imagesToAdd[4].path
                            });
                        });
                    } else {
                        this.drawing.handler.add({
                            url: $scope.imagesToAdd[4].path
                        });
                    }
                }
            }]
        }, {
            label: "<i class='fa fa-square' style='color:" + $scope.drawingColor + "' id='current_selected_color" + $scope.chartid + "'></i>",
            class: "drawing-color",
            needsCurrentColor: true,
            title: "Change color",
            menu: [{
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.Green.Hex + "'></i>",
                title: $scope.drawingColorOptions.Green.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.Green.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.Green.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.Green.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.DarkGreen.Hex + "'></i>",
                title: $scope.drawingColorOptions.DarkGreen.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.DarkGreen.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.DarkGreen.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.DarkGreen.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.Red.Hex + "'></i>",
                title: $scope.drawingColorOptions.Red.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.Red.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.Red.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.Red.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.LighRed.Hex + "'></i>",
                title: $scope.drawingColorOptions.LighRed.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.LighRed.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.LighRed.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.LighRed.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.Blue.Hex + "'></i>",
                title: $scope.drawingColorOptions.Blue.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.Blue.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.Blue.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.Blue.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.Black.Hex + "'></i>",
                title: $scope.drawingColorOptions.Black.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.Black.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.Black.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.Black.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.Orange.Hex + "'></i>",
                title: $scope.drawingColorOptions.Orange.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.Orange.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.Orange.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.Orange.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.Yellow.Hex + "'></i>",
                title: $scope.drawingColorOptions.Yellow.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.Yellow.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.Yellow.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.Yellow.Hex
                        });
                    }
                }
            }, {
                label: "<i class='fa fa-square' style='color:" + $scope.drawingColorOptions.White.Hex + "'></i>",
                title: $scope.drawingColorOptions.White.Title,
                click: function() {
                    $scope.drawingColor = $scope.drawingColorOptions.White.Hex;
                    document.getElementById("current_selected_color" + $scope.chartid).style.color = $scope.drawingColor;
                    if (!this.drawing.buffer.enabled) {
                        $scope.addActiveClassToDrawingTool("line");
                        this.capture({
                            action: "draw",
                            drawing: {
                                mode: "line"
                            }
                        }, function() {
                            this.drawing.handler.change({
                                color: $scope.drawingColorOptions.White.Hex
                            });
                        });
                    } else {
                        this.drawing.handler.change({
                            color: $scope.drawingColorOptions.White.Hex
                        });
                    }
                }
            }]
        }, {
            label: "<i class='fa fa-undo'></i>",
            title: "Undo",
            click: function() {
                this.drawing.handler.undo();
            }
        }, {
            label: "<i class='fa fa-repeat'></i>",
            title: "Redo",
            click: function() {
                this.drawing.handler.redo();
            }
        }, {
            label: "<i class='fa fa-floppy-o'></i>",
            title: "Save as... ",
            menu: [{
                label: "PNG",
                click: function() {
                    $scope.addActiveClassToDrawingTool("clear");
                    if (this.drawing.buffer.enabled) {
                        this.drawing.handler.done();
                        this.toPNG({}, function(data) {
                            this.download(data, "image/png", this.config.fileName + Date.now() + '.png');
                        });
                    } else {
                        this.capture({}, function() {
                            this.toPNG({}, function(data) {
                                this.download(data, "text/xml", this.config.fileName + Date.now() + '.png');
                            });
                        });
                    }
                }
            }, {
                label: "JPG",
                click: function() {
                    $scope.addActiveClassToDrawingTool("clear");
                    if (this.drawing.buffer.enabled) {
                        this.drawing.handler.done();
                        this.toJPG({}, function(data) {
                            this.download(data, "image/jpg", this.config.fileName + Date.now() + '.jpg');
                        });
                    } else {
                        this.capture({}, function() {
                            this.toJPG({}, function(data) {
                                this.download(data, "text/xml", this.config.fileName + Date.now() + '.jpg');
                            });
                        });
                    }
                }
            }, {
                label: "SVG",
                click: function() {
                    $scope.addActiveClassToDrawingTool("clear");
                    if (this.drawing.buffer.enabled) {
                        this.drawing.handler.done();
                        this.toSVG({}, function(data) {
                            this.download(data, "text/xml", this.config.fileName + Date.now() + '.svg');
                        });
                    } else {
                        this.capture({}, function() {
                            this.toSVG({}, function(data) {
                                this.download(data, "text/xml", this.config.fileName + Date.now() + '.svg');
                            });
                        });
                    }
                }
            }, {
                label: "CSV",
                click: function() {
                    $scope.addActiveClassToDrawingTool("clear");
                    this.toCSV({}, function(data) {
                        this.download(data, "text/plain", this.config.fileName + Date.now() + ".csv");
                    });
                }
            }, {
                label: "JSON",
                click: function() {
                    $scope.addActiveClassToDrawingTool("clear");
                    this.toJSON({}, function(data) {
                        this.download(data, "text/plain", this.config.fileName + Date.now() + ".json");
                    });
                }
            }, {
                label: "XLSX",
                click: function() {
                    $scope.addActiveClassToDrawingTool("clear");
                    this.toXLSX({}, function(data) {
                        this.download(data, "application/octet-stream", this.config.fileName + Date.now() + ".xlsx");
                    });
                }
            }]
        }, {
            label: "<i class='fa fa-trash'></i>",
            title: "Close Edit Mode",
            click: function() {
                $scope.addActiveClassToDrawingTool("clear");
                this.drawing.handler.done();
            }
        }];
    }
    $scope.buildChart(true, $scope.currentSocial.type != "Clear");
}]);;;;
angular.module('ccc-app').directive('chartHistoAdvanced', function() {
    return {
        restrict: 'E',
        templateUrl: 'charts/histo-advanced.html',
        controller: 'chartHistoAdvancedCtrl',
        scope: {
            chartid: "@"
        },
        link: function(scope, element, attrs) {}
    };
});;;;
angular.module('ccc-app').controller('SocialInfluenceCtrl', ['$scope', '$filter', 'socialStats', 'dateParsing', 'pageInfo', function($scope, $filter, socialStats, dateParsing, pageInfo) {
    var utilStatic = CCC.STATIC.UTIL;
    $scope.tempDisplay = {};
    $scope.convertToShortNumber = function(value, valueWhenNothing) {
        if (value) {
            return utilStatic.convertValueToDisplay('', value, $filter('number'), 'short', true);
        }
        return valueWhenNothing;
    }
    $scope.websiteData = socialStats.getSocialStatsTab("CryptoCompare");
    $scope.tempDisplay.websiteData = {};
    $scope.tempDisplay.websiteData.PageViews = utilStatic.convertValueToDisplay('', $scope.websiteData.PageViews, $filter('number'), 'short', true);
    $scope.tempDisplay.websiteData.OverviewPageViews = utilStatic.convertValueToDisplay('', $scope.websiteData.PageViewsSplit.Overview, $filter('number'), 'short', true);
    $scope.tempDisplay.websiteData.ChartsPageViews = utilStatic.convertValueToDisplay('', $scope.websiteData.PageViewsSplit.Charts, $filter('number'), 'short', true);
    $scope.tempDisplay.websiteData.ForumPageViews = utilStatic.convertValueToDisplay('', $scope.websiteData.PageViewsSplit.Forum, $filter('number'), 'short', true);
    $scope.tempDisplay.websiteData.ReviewsPageViews = utilStatic.convertValueToDisplay('', $scope.websiteData.PageViewsSplit.Reviews, $filter('number'), 'short', true);
    $scope.tempDisplay.websiteData.Points = $scope.convertToShortNumber($scope.websiteData.Points, 0);
    $scope.tempDisplay.websiteData.Posts = $scope.convertToShortNumber($scope.websiteData.Posts, 0);
    $scope.tempDisplay.websiteData.Comments = $scope.convertToShortNumber($scope.websiteData.Comments, 0);
    $scope.tempDisplay.websiteData.Followers = $scope.convertToShortNumber($scope.websiteData.Followers, 0);
    $scope.tempDisplay.websiteData.Reviews = $scope.convertToShortNumber($scope.websiteData.Reviews, 0);
    $scope.generalData = socialStats.getSocialStatsTab("General");
    $scope.tempDisplay.generalData = {};
    $scope.tempDisplay.generalData.Points = $scope.convertToShortNumber($scope.generalData.Points, 0);
    $scope.generalData.InternalParent = false;
    $scope.generalData.InternalSource = false;
    $scope.generalData.ExternalParent = false;
    $scope.generalData.ExternalSource = false;
    $scope.pageName = pageInfo.getH1Text();
    var redditData = socialStats.getSocialStatsTab("Reddit");
    $scope.redditData = {};
    $scope.redditData.Points = $scope.convertToShortNumber(redditData.Points, 0);
    $scope.redditData.Subscribers = $scope.convertToShortNumber(redditData.subscribers, "N/A");
    $scope.redditData.ActiveUsers = $scope.convertToShortNumber(redditData.active_users, "N/A");
    $scope.redditData.PostsPerDay = $scope.convertToShortNumber(redditData.posts_per_day, "N/A");
    $scope.redditData.CommentsPerDay = $scope.convertToShortNumber(redditData.comments_per_day, "N/A");
    if (redditData.hasOwnProperty("community_creation")) {
        $scope.redditData.CreatedOn = dateParsing.formatShortDate(parseInt(redditData.community_creation, 10) * 1000) + " (" + dateParsing.formatFromNow(parseInt(redditData.community_creation, 10) * 1000) + ")";
    } else {
        $scope.redditData.CreatedOn = "N/A"
    }
    if (redditData.hasOwnProperty("link")) {
        $scope.redditData.Link = '<a href="' + redditData.link + '" target="_blank">' + redditData.name + '</a>';
    } else {
        $scope.redditData.Link = "N/A";
    }
    var twitterData = socialStats.getSocialStatsTab("Twitter");
    $scope.twitterData = {};
    $scope.twitterData.Points = $scope.convertToShortNumber(twitterData.Points, 0);
    $scope.twitterData.Followers = $scope.convertToShortNumber(twitterData.followers, "N/A");
    $scope.twitterData.Following = $scope.convertToShortNumber(twitterData.following, "N/A");
    $scope.twitterData.Lists = $scope.convertToShortNumber(twitterData.lists, "N/A");
    $scope.twitterData.Favourites = $scope.convertToShortNumber(twitterData.favourites, "N/A");
    $scope.twitterData.Statuses = $scope.convertToShortNumber(twitterData.statuses, "N/A");
    if (twitterData.hasOwnProperty("account_creation")) {
        $scope.twitterData.CreatedOn = dateParsing.formatShortDate(parseInt(twitterData.account_creation, 10) * 1000) + " (" + dateParsing.formatFromNow(parseInt(twitterData.account_creation, 10) * 1000) + ")";
    } else {
        $scope.twitterData.CreatedOn = "N/A"
    }
    if (twitterData.hasOwnProperty("link")) {
        $scope.twitterData.Link = '<a href="' + twitterData.link + '" target="_blank">' + twitterData.name + '</a>';
    } else {
        $scope.twitterData.Link = "N/A";
    }
    var facebookData = socialStats.getSocialStatsTab("Facebook");
    $scope.facebookData = {};
    $scope.facebookData.Points = $scope.convertToShortNumber(facebookData.Points, 0);
    $scope.facebookData.Likes = $scope.convertToShortNumber(facebookData.likes, "N/A");
    $scope.facebookData.TalkingAbout = $scope.convertToShortNumber(facebookData.talking_about, "N/A");
    if (facebookData.hasOwnProperty("is_closed")) {
        if (facebookData.is_closed == "true") {
            $scope.facebookData.IsClosed = true;
        } else {
            $scope.facebookData.IsClosed = false;
        }
    } else {
        $scope.facebookData.IsClosed = "N/A";
    }
    $scope.facebookData.CreatedOn = "N/A"
    if (facebookData.hasOwnProperty("link")) {
        $scope.facebookData.Link = '<a href="' + facebookData.link + '" target="_blank">' + facebookData.name + '</a>';
    } else {
        $scope.facebookData.Link = "N/A";
    }
    var codeRepository = socialStats.getSocialStatsTab("CodeRepository");
    $scope.codeRepository = {};
    $scope.codeRepository.ActualPoints = codeRepository.Points || 0;
    $scope.codeRepository.Points = $scope.convertToShortNumber(codeRepository.Points, 0);
    $scope.codeRepository.List = [];
    for (var i = 0, length = codeRepository.List.length; i < length; i++) {
        var itemToAdd = {};
        var currentRepo = codeRepository.List[i];
        itemToAdd.Language = currentRepo.language || "N/A";
        itemToAdd.Stars = $scope.convertToShortNumber(currentRepo.stars, "N/A");
        itemToAdd.Forks = $scope.convertToShortNumber(currentRepo.forks, "N/A");
        itemToAdd.Subscribers = $scope.convertToShortNumber(currentRepo.subscribers, "N/A");
        if (currentRepo.hasOwnProperty("size")) {
            itemToAdd.Size = utilStatic.convertToMB(currentRepo.size);
        } else {
            itemToAdd.Size = "N/A";
        }
        itemToAdd.ClosedTotalIssues = $scope.convertToShortNumber(currentRepo.closed_total_issues, "N/A");
        itemToAdd.OpenTotalIssues = $scope.convertToShortNumber(currentRepo.open_total_issues, "N/A");
        itemToAdd.OpenPullIssues = $scope.convertToShortNumber(currentRepo.open_pull_issues, "N/A");
        itemToAdd.ClosedPullIssues = $scope.convertToShortNumber(currentRepo.closed_pull_issues, "N/A");
        itemToAdd.OpenIssues = $scope.convertToShortNumber(currentRepo.open_issues, "N/A");
        itemToAdd.ClosedIssues = $scope.convertToShortNumber(currentRepo.closed_issues, "N/A");
        if (currentRepo.hasOwnProperty("last_update")) {
            itemToAdd.LastUpdate = dateParsing.formatShortDate(parseInt(currentRepo.last_update, 10) * 1000) + " (" + dateParsing.formatFromNow(parseInt(currentRepo.last_update, 10) * 1000) + ")";
        } else {
            itemToAdd.LastUpdate = "N/A"
        }
        if (currentRepo.hasOwnProperty("last_push")) {
            itemToAdd.LastPush = dateParsing.formatShortDate(parseInt(currentRepo.last_push, 10) * 1000) + " (" + dateParsing.formatFromNow(parseInt(currentRepo.last_push, 10) * 1000) + ")";
        } else {
            itemToAdd.LastPush = "N/A"
        }
        if (currentRepo.hasOwnProperty("created_at")) {
            itemToAdd.CreatedOn = dateParsing.formatShortDate(parseInt(currentRepo.created_at, 10) * 1000) + " (" + dateParsing.formatFromNow(parseInt(currentRepo.created_at, 10) * 1000) + ")";
        } else {
            itemToAdd.CreatedOn = "N/A"
        }
        if (currentRepo.hasOwnProperty("url")) {
            itemToAdd.Link = '<a href="' + currentRepo.url + '" target="_blank"><i class="fa fa-external-link" aria-hidden="true"></i></a>';
        } else {
            itemToAdd.Link = "Repo N/A";
        }
        if (currentRepo.hasOwnProperty("fork")) {
            if (currentRepo.fork == "true") {
                itemToAdd.Fork = true;
                if (currentRepo.parent.hasOwnProperty("InternalData")) {
                    itemToAdd.InternalParent = currentRepo.parent.InternalData;
                    $scope.generalData.InternalParent = currentRepo.parent.InternalData;
                    if (currentRepo.source.hasOwnProperty("InternalData") && currentRepo.source.InternalData.Id != currentRepo.parent.InternalData.Id) {
                        itemToAdd.InternalSource = currentRepo.source.InternalData;
                        $scope.generalData.InternalSource = currentRepo.source.InternalData;
                    }
                } else if (currentRepo.parent.Name != "") {
                    itemToAdd.ExtenalParent = currentRepo.parent;
                    $scope.generalData.ExtenalParent = currentRepo.parent;
                    if (currentRepo.source.Name != "" && currentRepo.parent.Name != currentRepo.source.Name) {
                        itemToAdd.ExtenalSource = currentRepo.source;
                        $scope.generalData.ExtenalSource = currentRepo.source;
                    }
                }
            } else {
                itemToAdd.Fork = false;
                itemToAdd.Parent = false;
                itemToAdd.Source = false;
            }
        } else {
            itemToAdd.Fork = "N/A";
            itemToAdd.Parent = false;
            itemToAdd.Source = false;
        }
        $scope.codeRepository.List.push(itemToAdd);
    }
}]);;;;
angular.module('ccc-app').controller('chartHistoSimpleCtrl', ['$rootScope', '$scope', '$http', '$stateParams', 'pageInfo', 'subscriptionManager', 'chartUtil', 'cModalService', 'userManager', function($rootScope, $scope, $http, $stateParams, pageInfo, subscriptionManager, chartUtil, cModalService, userManager) {
    $scope.userManager = userManager;
    $scope.fromSymbolName = pageInfo.getH1Text();
    $scope.chartTypes = [{
        name: 'Line Chart',
        icon: 'fa-area-chart',
        extraClass: "pull-right",
        linkToPage: false,
        requiresLogin: false
    }, {
        name: 'Logarithmic',
        icon: 'fa-line-chart',
        extraClass: "pull-left",
        linkToPage: false,
        requiresLogin: false
    }, {
        name: 'Candle Stick',
        icon: 'fa-bar-chart',
        extraClass: "pull-left",
        linkToPage: false,
        requiresLogin: false
    }, {
        name: 'Advanced Chart',
        icon: 'fa-area-chart',
        extraClass: "pull-left",
        linkToPage: true,
        pageType: 'Chart',
        requiresLogin: false
    }];
    $scope.currentDataSet = [];
    $scope.chartPeriod = [{
        name: '1 Hour',
        shortName: '1 H',
        maxPoints: 60,
        type: 'minute',
        aggregation: 1,
        periodForTable: 10,
        periodForTableName: '10 min',
        period: 'mm',
        polyfill: 60,
        requiresLogin: false
    }, {
        name: '1 Day',
        shortName: '1 D',
        maxPoints: 144,
        type: 'minute',
        aggregation: 10,
        periodForTable: 18,
        periodForTableName: '3 hours',
        period: '10mm',
        polyfill: 10 * 60,
        requiresLogin: false
    }, {
        name: '1 Week',
        shortName: '1 W',
        maxPoints: 168,
        type: 'hour',
        aggregation: 1,
        periodForTable: 24,
        periodForTableName: 'day',
        period: 'hh',
        polyfill: 60 * 60,
        requiresLogin: false
    }, {
        name: '1 Month',
        shortName: '1 M',
        maxPoints: 120,
        type: 'hour',
        aggregation: 6,
        periodForTable: 12,
        periodForTableName: '3 days',
        period: '6hh',
        polyfill: 6 * 60 * 60,
        requiresLogin: false
    }, {
        name: '3 Months',
        shortName: '3 M',
        maxPoints: 90,
        type: 'day',
        aggregation: 1,
        periodForTable: 10,
        periodForTableName: '10 days',
        period: 'DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }, {
        name: '6 Months',
        shortName: '6 M',
        maxPoints: 180,
        type: 'day',
        aggregation: 1,
        periodForTable: 30,
        periodForTableName: '30 days',
        period: 'DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }, {
        name: '1 Year',
        shortName: '1 Y',
        maxPoints: 365,
        type: 'day',
        aggregation: 1,
        periodForTable: 60,
        periodForTableName: '60 days',
        period: 'DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }];
    $scope.currentType = $scope.chartTypes[0];
    $scope.currentPeriod = $scope.chartPeriod[1];
    $scope.dataLoaded = false;
    $scope.dataIsLoading = true;
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getCurrentAggChartObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        $scope.computedChart = subscriptionManager.getCurrentAggChartByToSymbol($stateParams.Symbol.toUpperCase());
    } else {
        $scope.computedChart = subscriptionManager.getCurrentAggChart();
    }
    $scope.exchange = $scope.computedChart.exchange;
    $scope.fromsymbol = $scope.computedChart.fromsymbol;
    $scope.tosymbol = $scope.computedChart.tosymbol;
    chartUtil.availableChartPeriods($scope.chartPeriod);
    chartUtil.setLoaded($scope.dataLoaded);
    chartUtil.setLoading($scope.dataIsLoading);
    chartUtil.saveCurrentPeriod($scope.currentPeriod);
    chartUtil.setFromSymbol($scope.fromsymbol);
    chartUtil.setToSymbol($scope.tosymbol);
    $scope.killListeners = function(changingView) {
        $scope.changeCurrency();
        $scope.changeView();
        $scope.periodChangeExternal();
    };
    $scope.handleNewSymbol = function(symbol) {
        if ($scope.tosymbol == symbol) {
            return;
        }
        $scope.dataLoaded = false;
        chartUtil.setLoaded($scope.dataLoaded);
        $scope.computedChart = subscriptionManager.getCurrentAggChart();
        $scope.exchange = $scope.computedChart.exchange;
        $scope.fromsymbol = $scope.computedChart.fromsymbol;
        $scope.tosymbol = $scope.computedChart.tosymbol;
        chartUtil.setToSymbol($scope.tosymbol);
        $scope.buildChart(true);
    };
    $scope.isPeriodSelected = function(periodId) {
        return chartUtil.isPeriodSelected(periodId);
    };
    $scope.handleNewPeriod = function(periodId) {
        if ($scope.currentPeriod.name == $scope.chartPeriod[periodId].name) {
            return;
        };
        if ($scope.chartPeriod[periodId].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to see the " + $scope.chartPeriod[periodId].name + " chart time period.");
        } else {
            $scope.currentPeriod = $scope.chartPeriod[periodId];
            $scope.buildChart(true);
        }
    };
    $scope.isTypeSelected = function(typeId) {
        return $scope.currentType.name == $scope.chartTypes[typeId].name;
    };
    $scope.handleNewType = function(typeId) {
        if ($scope.currentType.name == $scope.chartTypes[typeId].name) {
            return;
        }
        if ($scope.chartTypes[typeId].linkToPage == true) {
            if ($scope.chartTypes[typeId].pageType == "Chart") {
                $rootScope.$emit('ChangeToChartsView')
            }
        } else {
            $scope.currentType = $scope.chartTypes[typeId];
            $scope.buildChart(false);
        }
    };
    $scope.changeCurrency = $rootScope.$on("ChangeCurrency", function(event, symbol) {
        $scope.handleNewSymbol(symbol);
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.killListeners();
    });
    $scope.periodChangeExternal = $rootScope.$on('ChartPeriodChange', function(event, periodId) {
        $scope.handleNewPeriod(periodId);
    });
    $scope.generateNewChart = function() {
        var logarithmicChart = false;
        if ($scope.currentType.name == $scope.chartTypes[1].name) {
            logarithmicChart = true;
        }
        $scope.chartConfig = {
            type: "stock",
            theme: "none",
            addClassNames: true,
            panEventsEnabled: false,
            pathToImages: "/images/",
            categoryAxesSettings: {
                minPeriod: $scope.currentPeriod.period,
                maxSeries: $scope.currentPeriod.maxPoints + 20,
                parseDates: true,
                equalSpacing: true
            },
            chartScrollbarSettings: {},
            dataSets: [{
                color: "#006098",
                fieldMappings: [{
                    fromField: "close",
                    toField: "close",
                }, {
                    fromField: "open",
                    toField: "open"
                }, {
                    fromField: "high",
                    toField: "high"
                }, {
                    fromField: "low",
                    toField: "low"
                }, {
                    fromField: "volumefrom",
                    toField: "volumefrom"
                }],
                dataProvider: $scope.currentDataSet,
                addClassNames: true,
                categoryField: "timeDate"
            }],
            panels: [{
                showCategoryAxis: false,
                title: subscriptionManager.getNameForExchange($scope.exchange) + ' : ' + $scope.fromsymbol,
                percentHeight: 70,
                valueAxes: [{
                    id: "a1",
                    title: "Price",
                    position: "left",
                    gridAlpha: 0.2,
                    axisAlpha: 1,
                    logarithmic: logarithmicChart
                }],
                stockGraphs: [],
                stockLegend: {
                    markerType: "none"
                }
            }, {
                percentHeight: 30,
                stockGraphs: [],
                stockLegend: {
                    markerType: "none"
                }
            }],
            panelsSettings: {
                panEventsEnabled: false
            },
            chartScrollbarSettings: {
                graph: "g1",
                enabled: false
            },
            chartCursorSettings: {
                valueBalloonsEnabled: true,
                zoomable: false,
                categoryBalloonDateFormats: [{
                    period: 'fff',
                    format: 'JJ:NN:SS'
                }, {
                    period: 'ss',
                    format: 'JJ:NN:SS'
                }, {
                    period: 'mm',
                    format: 'JJ:NN'
                }, {
                    period: 'hh',
                    format: 'MMM DD, JJ:NN'
                }, {
                    period: 'DD',
                    format: 'MMM DD'
                }, {
                    period: 'WW',
                    format: 'YYYY MMM DD'
                }, {
                    period: 'MM',
                    format: 'YYYY MMM'
                }, {
                    period: 'YYYY',
                    format: 'YYYY'
                }]
            },
            panelsSettings: {
                usePrefixes: false
            }
        }
        if ($scope.currentType.name == $scope.chartTypes[2].name) {
            chartUtil.topCandleStick($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], $scope.tosymbol);
        } else if ($scope.currentType.name == $scope.chartTypes[0].name || $scope.currentType.name == $scope.chartTypes[1].name) {
            chartUtil.topLine($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[0], $scope.tosymbol, true);
        }
        chartUtil.bottomVolume($scope.chartConfig.dataSets[0], $scope.chartConfig.panels[1], $scope.fromsymbol);
        $scope.chart = AmCharts.makeChart($scope.chartid, $scope.chartConfig);
    };
    $scope.buildChart = function(updateData) {
        if (!subscriptionManager.hasSubs()) {
            return;
        }
        if (!updateData && $scope.currentDataSet.length > 0) {
            $scope.generateNewChart();
        } else {
            $scope.getHistoData();
        }
    };
    $scope.getHistoData = function() {
        $scope.dataIsLoading = true;
        chartUtil.setLoading($scope.dataIsLoading);
        chartUtil.getHistoFromMinApi($scope.currentPeriod.type, $scope.exchange, $scope.fromsymbol, $scope.tosymbol, $scope.currentPeriod.maxPoints, $scope.currentPeriod.aggregation).success(function(data) {
            $scope.currentDataSet = chartUtil.polyfillChartData(data, $scope.currentPeriod.polyfill, 0);
            chartUtil.setChartStats($scope.currentDataSet.stats);
            $scope.currentDataSet = $scope.currentDataSet.data;
            $scope.generateNewChart();
            $scope.dataIsLoading = false;
            $scope.dataLoaded = true;
            chartUtil.saveCurrentPeriod($scope.currentPeriod);
            chartUtil.saveCurrentData($scope.currentDataSet);
            chartUtil.setLoading(false);
            chartUtil.setLoaded(true);
        });
    };
    $scope.buildChart(true);
}]);
angular.module('ccc-app').directive('histoPriceTable', [function() {
    return {
        restrict: 'E',
        templateUrl: 'charts/histo-price-table.html',
        controller: ['$scope', 'pageInfo', 'chartUtil', 'userManager', 'subscriptionManager', 'dateParsing', function($scope, pageInfo, chartUtil, userManager, subscriptionManager, dateParsing) {
            $scope.pageInfo = pageInfo;
            $scope.chartUtil = chartUtil;
            $scope.dateParsing = dateParsing;
            $scope.userManager = userManager;
        }],
        scope: {},
        link: function(scope, element, attrs) {}
    };
}]);
angular.module('ccc-app').controller('chartSocialSimpleCtrl', ['$rootScope', '$scope', '$http', '$stateParams', 'pageInfo', 'subscriptionManager', 'chartUtil', 'cModalService', 'userManager', function($rootScope, $scope, $http, $stateParams, pageInfo, subscriptionManager, chartUtil, cModalService, userManager) {
    $scope.userManager = userManager;
    $scope.fromSymbolName = pageInfo.getH1Text();
    $scope.chartTypes = [{
        name: 'Line Chart',
        icon: 'fa-area-chart',
        extraClass: "pull-right",
        linkToPage: false,
        requiresLogin: false
    }];
    $scope.currentDataSet = [];
    $scope.chartPeriod = [{
        name: '1 Week',
        shortName: '1 W',
        maxPoints: 168,
        type: 'hour',
        aggregation: 1,
        period: 'hh',
        format: 'MMM DD, JJ:NN',
        polyfill: 60 * 60,
        requiresLogin: false
    }, {
        name: '1 Month',
        shortName: '1 M',
        maxPoints: 120,
        type: 'hour',
        aggregation: 6,
        period: '6hh',
        format: 'MMM DD, JJ:NN',
        polyfill: 6 * 60 * 60,
        requiresLogin: false
    }, {
        name: '3 Months',
        shortName: '3 M',
        maxPoints: 90,
        type: 'day',
        aggregation: 1,
        period: 'DD',
        format: 'MMM DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }, {
        name: '6 Months',
        shortName: '6 M',
        maxPoints: 180,
        type: 'day',
        aggregation: 1,
        period: 'DD',
        format: 'MMM DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }, {
        name: '1 Year',
        shortName: '1 Y',
        maxPoints: 365,
        type: 'day',
        aggregation: 1,
        period: 'DD',
        format: 'MMM DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }];
    $scope.currentType = $scope.chartTypes[0];
    $scope.currentPeriod = $scope.chartPeriod[0];
    $scope.dataIsLoading = true;
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getCurrentAggChartObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        $scope.computedChart = subscriptionManager.getCurrentAggChartByToSymbol($stateParams.Symbol.toUpperCase());
    } else {
        $scope.computedChart = subscriptionManager.getCurrentAggChart();
    }
    $scope.killListeners = function(changingView) {
        $scope.changeView();
    };
    $scope.isPeriodSelected = function(periodId) {
        return $scope.chartPeriod[periodId].name == $scope.currentPeriod.name;
    };
    $scope.handleNewPeriod = function(periodId) {
        if ($scope.currentPeriod.name == $scope.chartPeriod[periodId].name) {
            return;
        };
        if ($scope.chartPeriod[periodId].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to see the " + $scope.chartPeriod[periodId].name + " chart time period.");
        } else {
            $scope.currentPeriod = $scope.chartPeriod[periodId];
            $scope.buildChart(true);
        }
    };
    $scope.isTypeSelected = function(typeId) {
        return $scope.currentType.name == $scope.chartTypes[typeId].name;
    };
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.killListeners();
    });
    $scope.generateNewChart = function() {
        $scope.chartConfig = {
            type: "serial",
            theme: "none",
            legend: {
                enabled: false
            },
            zoomOutText: '',
            dataProvider: $scope.currentDataSet,
            panEventsEnabled: false,
            marginTop: 10,
            marginRight: 10,
            marginLeft: 10,
            marginBottom: 30,
            autoMargins: false,
            balloon: {
                adjustBorderColor: false,
                horizontalPadding: 10,
                verticalPadding: 8,
                color: "#ffffff",
                borderThickness: 2
            },
            addClassNames: true,
            pathToImages: "/images/",
            categoryField: "time",
            guides: [],
            valueAxes: [{
                position: "left",
                gridThickness: 1,
                gridAlpha: 0.2,
                axisAlpha: 0,
                inside: true
            }],
            parseDates: true,
            categoryAxis: {
                minPeriod: $scope.currentPeriod.period,
                maxSeries: $scope.currentDataSet.length + 10,
                parseDates: true,
                gridThickness: 1,
                gridAlpha: 0.2,
                labelsEnabled: true
            },
            graphs: [],
            chartCursor: {
                valueBalloonsEnabled: true,
                zoomable: false,
                categoryBalloonEnabled: true,
                categoryBalloonDateFormat: $scope.currentPeriod.format
            },
            panelsSettings: {
                panEventsEnabled: false,
                usePrefixes: false
            },
            listeners: [{
                event: "rendered",
                method: function(e) {
                    $scope.dataIsLoading = false;
                }
            }]
        }
        if ($scope.currentType.name == $scope.chartTypes[0].name) {
            chartUtil.topLineSerial($scope.chartConfig.graphs, 'CryptoCompare Points', 'points', '');
        }
        $scope.chart = AmCharts.makeChart($scope.chartid, $scope.chartConfig);
    };
    $scope.buildChart = function(updateData) {
        $scope.getSocialData();
    };
    $scope.getSocialData = function() {
        $scope.dataIsLoading = true;
        chartUtil.getSocialHistoFromApi($scope.currentPeriod.type, pageInfo.getPageId(), $scope.currentPeriod.maxPoints, $scope.currentPeriod.aggregation).success(function(data) {
            $scope.currentDataSet = chartUtil.polyfillSocialData(data, $scope.currentPeriod.polyfill);
            $scope.generateNewChart();
        });
    };
    $scope.buildChart(true);
}]);;;;
angular.module('ccc-app').directive('socialInfluence', [function() {
    return {
        restrict: 'E',
        templateUrl: 'global/social-influence.html',
        controller: 'SocialInfluenceCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
}]);
angular.module('ccc-app').directive('socialInfluenceExchange', [function() {
    return {
        restrict: 'E',
        templateUrl: 'global/social-influence-exchange.html',
        controller: 'SocialInfluenceCtrl',
        scope: {},
        link: function(scope, element, attrs) {}
    };
}]);;;;
angular.module('ccc-app').directive('chartHistoSimple', function() {
    return {
        restrict: 'E',
        templateUrl: 'charts/histo-simple.html',
        controller: 'chartHistoSimpleCtrl',
        scope: {
            chartid: "@"
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('chartHistoSimpleV2', function() {
    return {
        restrict: 'E',
        templateUrl: 'charts/histo-simple-v2.html',
        controller: 'chartHistoSimpleCtrl',
        scope: {
            chartid: "@"
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('chartSocialSimpleV2', function() {
    return {
        restrict: 'E',
        templateUrl: 'charts/social-simple-v2.html',
        controller: 'chartSocialSimpleCtrl',
        scope: {
            chartid: "@"
        },
        link: function(scope, element, attrs) {}
    };
});
angular.module('ccc-app').directive('chartHistoPlaceholder', function() {
    return {
        restrict: 'E',
        templateUrl: 'charts/histo-placeholder.html',
        controller: 'chartHistoSimpleCtrl',
        scope: {
            chartid: "@"
        },
        link: function(scope, element, attrs) {}
    };
});;;;
angular.module('ccc-app').controller('PieChartCurrencyMarketShare', ['$rootScope', '$scope', '$interval', 'pageInfo', 'subscriptionManager', 'streamerUtilities', 'chartUtil', function($rootScope, $scope, $interval, pageInfo, subscriptionManager, streamerUtilities, chartUtil) {
    $scope.chartType = 'pieChartCurrencyMarketShare';
    $scope.chartId = '';
    $scope.chartData = [];
    $scope.currentAGGSubsObj = subscriptionManager.getCurrentAGGSubsObj();
    $scope.toSymbol = subscriptionManager.getCurrentToSymbol();
    $scope.fromSymbol = pageInfo.getSymbol();
    $scope.tempSubs = [];
    $scope.chartHasData = true;
    $scope.totalVolume = 0;
    $scope.dataHasChanged = false;
    $scope.rebuildEvery10Sec = $interval(function() {
        if ($scope.dataHasChanged) {
            $scope.buildChart();
        }
    }, 10000, false);
    for (var i in $scope.currentAGGSubsObj) {
        $scope.tempSubs.push($scope.currentAGGSubsObj[i]);
    };
    $scope.connection = streamerUtilities.initConnection();
    $scope.progressBar = streamerUtilities.initProgressBar();
    $scope.createChartDynamic = function(chartId) {
        $scope.chartId = chartId;
        if ($scope.connection.connected) {
            $scope.connectAll();
        }
    }
    $scope.buildChart = function() {
        $scope.chartConfig = {
            type: "pie",
            dataProvider: $scope.connection.data,
            titleField: "Symbol",
            valueField: "Volume",
            labelRadius: 5,
            groupPercent: 1,
            pulledField: 'Pulled',
            startRadius: 200,
            startDuration: 0,
            colors: ['#82AE52', '#2D4F79', '#d14836', '#006098', '#3FB488'],
            radius: "42%",
            innerRadius: "40%",
            labelText: "[[Symbol]]",
            startAngle: 30,
            labelRadius: -25,
            hoverAlpha: 0.7,
            color: '#000000',
            panEventsEnabled: false
        };
        $scope.chart = AmCharts.makeChart($scope.chartId, $scope.chartConfig);
        $scope.dataHasChanged = false;
    };
    $scope.parseMessage = function(messageInfo) {
        var subKey = messageInfo.SubKey;
        if ($scope.connection.subs.indexOf(subKey) > -1) {
            if (subKey == messageInfo.Raw) {
                $scope.progressBar.current++;
                if ($scope.progressBar.current == $scope.progressBar.max) {
                    $scope.connection.loadingData = false;
                    $scope.connection.data.sort(function(a, b) {
                        return b.Volume - a.Volume;
                    });
                    $scope.connection.keyToPosition = {};
                    for (var i = 0; i < $scope.connection.data.length; i++) {
                        $scope.connection.keyToPosition[$scope.connection.data[i].SUBKEY] = i;
                    };
                    $scope.totalVolume = $scope.connection.data.reduce(function(a, b) {
                        return {
                            Volume: a.Volume + b.Volume
                        };
                    }).Volume;
                    if ($scope.totalVolume == 0) {
                        $scope.chartHasData = false;
                    }
                    $scope.buildChart();
                }
            } else {
                var messageObject = messageInfo.Obj;
                var objToAdd = {
                    "Symbol": messageObject['TOSYMBOL'],
                    "Volume": chartUtil.convertValueForChart(messageObject['VOLUME24HOUR']),
                    "SUBKEY": subKey
                };
                if (objToAdd.Symbol == $scope.toSymbol && $scope.progressBar.max > 3) {
                    objToAdd.Pulled = true;
                } else {
                    objToAdd.Pulled = false;
                }
                var arrayKey = 0;
                if ($scope.connection.keyToPosition[subKey] != 0) {
                    arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                }
                $scope.connection.data[arrayKey] = objToAdd;
                $scope.dataHasChanged = true;
                if ($scope.connection.loadingData) {
                    $scope.progressBar.current++;
                    if ($scope.progressBar.current == $scope.progressBar.max) {
                        $scope.connection.loadingData = false;
                        $scope.connection.data.sort(function(a, b) {
                            return b.Volume - a.Volume;
                        });
                        $scope.connection.keyToPosition = {};
                        for (var i = 0; i < $scope.connection.data.length; i++) {
                            $scope.connection.keyToPosition[$scope.connection.data[i].SUBKEY] = i;
                        };
                        $scope.totalVolume = $scope.connection.data.reduce(function(a, b) {
                            return {
                                Volume: a.Volume + b.Volume
                            };
                        }).Volume;
                        if ($scope.totalVolume == 0) {
                            $scope.chartHasData = false;
                        }
                        $scope.buildChart();
                    }
                }
            }
        }
    };
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        $scope.progressBar.current++;
        $scope.connectAll();
    });
    $scope.currentAggMessage = $rootScope.$on('CurrentAggMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
    $scope.changeCurrency = $rootScope.$on("ChangeCurrency", function(event, symbol) {
        if ($scope.toSymbol == symbol) {
            return;
        }
        $scope.toSymbol = symbol;
        if (!$scope.connection.loadingData && $scope.chart.chartData.length > 1) {
            var isInOther = true;
            var otherId = 0;
            for (var i = 0; i < $scope.chart.chartData.length; i++) {
                if ($scope.chart.chartData[i].pulled) {
                    $scope.chart.clickSlice(i);
                }
                if ($scope.chart.chartData[i].title == symbol) {
                    $scope.chart.clickSlice(i);
                    isInOther = false;
                }
                if ($scope.chart.chartData[i].title == "Other") {
                    otherId = i;
                }
            }
            if (isInOther) {
                $scope.chart.clickSlice(otherId);
            }
        }
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.disconnectAll();
    });
    $scope.connectAll = function() {
        $scope.connection = streamerUtilities.initConnection();
        $scope.connection.subs = $scope.tempSubs;
        $scope.progressBar.max = $scope.connection.subs.length + 2;
        streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    };
    $scope.disconnectAll = function() {
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        $scope.socketConnected();
        $scope.currentAggMessage();
        $scope.changeCurrency();
        $scope.changeView();
        $interval.cancel($scope.rebuildEvery10Sec);
    };
}]);
angular.module('ccc-app').controller('PieChartExchangeMarketShare', ['$rootScope', '$scope', '$stateParams', '$interval', 'pageInfo', 'subscriptionManager', 'streamerUtilities', 'chartUtil', function($rootScope, $scope, $stateParams, $interval, pageInfo, subscriptionManager, streamerUtilities, chartUtil) {
    $scope.chartType = 'pieChartExchangeMarketShare';
    $scope.chartId = '';
    $scope.chartData = [];
    $scope.totalVolume = 0;
    $scope.chartHasData = true;
    $scope.connection = streamerUtilities.initConnection();
    $scope.progressBar = streamerUtilities.initProgressBar();
    $scope.toSymbol = subscriptionManager.getCurrentToSymbol();
    $scope.fromSymbol = pageInfo.getSymbol();
    $scope.dataHasChanged = false;
    $scope.rebuildEvery10Sec = $interval(function() {
        if ($scope.dataHasChanged) {
            $scope.buildChart();
        }
    }, 10000, false);
    $scope.createChartDynamic = function(chartId) {
        $scope.chartId = chartId;
        if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getCurrentAggChartObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
            if ($scope.connection.connected) {
                $scope.reconnectAll($stateParams.Symbol);
            } else {
                $scope.connection.subs = subscriptionManager.getCurrentSubsByToSymbol($stateParams.Symbol);
                $scope.progressBar.max = $scope.connection.subs.length + 2;
            }
        } else {
            $scope.connection.subs = subscriptionManager.getTopCurrentSubs();
            $scope.progressBar.max = $scope.connection.subs.length + 2;
            if ($scope.connection.connected) {
                streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
                    $scope.parseMessage(messageInfo);
                });
            }
        }
    }
    $scope.buildChart = function() {
        $scope.chartConfig = {
            type: "pie",
            dataProvider: $scope.connection.data,
            titleField: "Market",
            valueField: "Volume",
            labelRadius: 5,
            groupPercent: 2,
            startRadius: 200,
            startDuration: 0,
            colors: ['#82AE52', '#F53002', '#285678', '#DF2F7A', '#879CAC', '#95608F', '#FD7625', '#1F9EB2', '#565656'],
            radius: "42%",
            innerRadius: "40%",
            labelText: "[[Market]]",
            startAngle: 30,
            labelRadius: -35,
            hoverAlpha: 0.7,
            color: '#FFF',
            panEventsEnabled: false
        };
        $scope.chart = AmCharts.makeChart($scope.chartId, $scope.chartConfig);
        $scope.dataHasChanged = false;
    };
    $scope.parseMessage = function(messageInfo) {
        var subKey = messageInfo.SubKey;
        if ($scope.connection.subs.indexOf(subKey) > -1) {
            if (subKey == messageInfo.Raw) {
                $scope.progressBar.current++;
                if ($scope.progressBar.current == $scope.progressBar.max) {
                    $scope.connection.loadingData = false;
                    $scope.connection.data.sort(function(a, b) {
                        return b.Volume - a.Volume;
                    });
                    $scope.connection.keyToPosition = {};
                    for (var i = 0; i < $scope.connection.data.length; i++) {
                        $scope.connection.keyToPosition[$scope.connection.data[i].SUBKEY] = i;
                    };
                    $scope.totalVolume = $scope.connection.data.reduce(function(a, b) {
                        return {
                            Volume: a.Volume + b.Volume
                        };
                    }).Volume;
                    if ($scope.totalVolume == 0) {
                        $scope.chartHasData = false;
                    }
                    $scope.buildChart();
                }
            } else {
                var messageObject = messageInfo.Obj;
                var arrayKey = 0;
                if ($scope.connection.keyToPosition[subKey] != 0) {
                    arrayKey = $scope.connection.keyToPosition[subKey] || $scope.connection.data.length;
                }
                $scope.connection.data[arrayKey] = {
                    "Market": messageObject['MARKET'],
                    "Volume": chartUtil.convertValueForChart(messageObject['VOLUME24HOUR']),
                    "SUBKEY": messageInfo.SubKey
                };
                $scope.dataHasChanged = true;
                if ($scope.connection.loadingData) {
                    $scope.progressBar.current++;
                    if ($scope.progressBar.current == $scope.progressBar.max) {
                        $scope.connection.loadingData = false;
                        $scope.connection.data.sort(function(a, b) {
                            return b.Volume - a.Volume;
                        });
                        $scope.connection.keyToPosition = {};
                        for (var i = 0; i < $scope.connection.data.length; i++) {
                            $scope.connection.keyToPosition[$scope.connection.data[i].SUBKEY] = i;
                        };
                        $scope.totalVolume = $scope.connection.data.reduce(function(a, b) {
                            return {
                                Volume: a.Volume + b.Volume
                            };
                        }).Volume;
                        if ($scope.totalVolume == 0) {
                            $scope.chartHasData = false;
                        }
                        $scope.buildChart();
                    }
                }
            }
        }
    };
    $scope.changeCurrency = $rootScope.$on('ChangeCurrency', function(event, symbol) {
        $scope.toSymbol = symbol;
        $scope.chartHasData = true;
        $scope.disconnectAll(false);
        $scope.reconnectAll(symbol);
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.disconnectAll(true);
    });
    $scope.socketConnected = $rootScope.$on('SocketConnected', function(event, isConnected) {
        $scope.connection.connected = true;
        $scope.progressBar.current++;
        $scope.progressBar.message = 'Loading data...';
        streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    });
    $scope.currentMessage = $rootScope.$on('CurrentMessage', function(event, messageInfo) {
        $scope.parseMessage(messageInfo);
    });
    $scope.reconnectAll = function(symbol) {
        $scope.connection.subs = subscriptionManager.getCurrentSubsByToSymbol(symbol);
        $scope.progressBar.max = $scope.connection.subs.length + 2;
        streamerUtilities.addGlobalPageSubs($scope.connection.subs, function(messageInfo) {
            $scope.parseMessage(messageInfo);
        });
    };
    $scope.disconnectAll = function(changingView) {
        streamerUtilities.removeGlobalPageSubs($scope.connection.subs);
        $scope.connection = streamerUtilities.initConnection();
        $scope.progressBar = streamerUtilities.initProgressBar();
        $scope.ordering = streamerUtilities.initOrdering();
        if (changingView) {
            $scope.changeCurrency();
            $scope.changeView();
            $scope.socketConnected();
            $scope.currentMessage();
            $interval.cancel($scope.rebuildEvery10Sec);
        }
    };
}]);;;;
angular.module('ccc-app').controller('volumeBarChartSerialCtrl', ['$rootScope', '$scope', '$http', '$stateParams', '$location', 'pageInfo', 'subscriptionManager', 'chartUtil', 'cModalService', 'userManager', function($rootScope, $scope, $http, $stateParams, $location, pageInfo, subscriptionManager, chartUtil, cModalService, userManager) {
    $scope.maxCurrencyPairs = 7;
    $scope.maxExchanges = 5;
    $scope.baseImagesPath = "/scripts/Vendor/AmCharts/";
    $scope.chartColors = CCC.STATIC.UTIL.chartColors;
    $scope.chartColorsIds = Object.keys($scope.chartColors);
    $scope.userManager = userManager;
    $scope.dataLoaded = false;
    $scope.dataIsLoading = true;
    $scope.currentDataSet = [];
    $scope.valuesToLoad = [];
    $scope.chartTypes = [{
        key: 'Vol',
        name: 'Vol.',
        icon: 'fa-area-chart',
        extraClass: "pull-right",
        linkToPage: false,
        requiresLogin: false,
        symbol: 'fromSymbol'
    }, {
        key: 'VolTo',
        name: 'Vol.',
        icon: 'fa-area-chart',
        extraClass: "pull-right",
        linkToPage: false,
        requiresLogin: false,
        symbol: 'toSymbol'
    }, {
        key: 'Currencies',
        name: 'vs Top Currencies',
        icon: 'fa-line-chart',
        extraClass: "pull-right",
        linkToPage: false,
        requiresLogin: true,
        symbol: 'toSymbol'
    }, {
        key: 'Exchanges',
        name: 'Exchanges Comparsion',
        icon: 'fa-bar-chart',
        extraClass: "pull-right",
        linkToPage: false,
        requiresLogin: true,
        symbol: 'toSymbol'
    }];
    $scope.chartPeriod = [{
        key: '1H',
        name: '1 Hour',
        shortName: '1 H',
        maxPoints: 60,
        allData: false,
        type: 'minute',
        aggregation: 1,
        period: 'mm',
        format: 'JJ:NN',
        polyfill: 60,
        requiresLogin: false
    }, {
        key: '1D',
        name: '1 Day',
        shortName: '1 D',
        maxPoints: 288,
        allData: false,
        type: 'minute',
        aggregation: 5,
        period: '5mm',
        format: 'JJ:NN',
        polyfill: 5 * 60,
        requiresLogin: false
    }, {
        key: '2W',
        name: '2 Week',
        shortName: '2 W',
        maxPoints: 336,
        allData: false,
        type: 'hour',
        aggregation: 1,
        period: 'hh',
        format: 'MMM DD, JJ:NN',
        polyfill: 60 * 60,
        requiresLogin: false
    }, {
        key: '1M',
        name: '1 Month',
        shortName: '1 M',
        maxPoints: 240,
        allData: false,
        type: 'hour',
        aggregation: 3,
        period: '3hh',
        format: 'MMM DD JJ:NN',
        polyfill: 3 * 60 * 60,
        requiresLogin: false
    }, {
        key: '6M',
        name: '6 Months',
        shortName: '6 M',
        maxPoints: 180,
        allData: false,
        type: 'day',
        aggregation: 1,
        period: 'DD',
        format: 'MMM DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }, {
        key: '1Y',
        name: '1 Year',
        shortName: '1 Y',
        maxPoints: 365,
        allData: false,
        type: 'day',
        aggregation: 1,
        period: 'DD',
        format: 'MMM DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }, {
        key: 'ALL',
        name: 'All Data',
        shortName: 'ALL',
        maxPoints: -1,
        allData: true,
        type: 'day',
        aggregation: 1,
        period: 'DD',
        format: 'MMM DD',
        polyfill: 24 * 60 * 60,
        requiresLogin: true
    }];
    $scope.killListeners = function(changingView) {
        $scope.changeCurrency();
        $scope.changeView();
    };
    $scope.handleNewSymbol = function(symbol) {
        if ($scope.tosymbol == symbol) {
            return;
        }
        $scope.dataLoaded = false;
        $scope.computedChart = subscriptionManager.getCurrentAggChart();
        $scope.exchange = $scope.computedChart.exchange;
        $scope.fromSymbol = $scope.computedChart.fromsymbol;
        $scope.toSymbol = $scope.computedChart.tosymbol;
        $scope.buildChart(true);
    };
    $scope.getPeriodByKey = function(periodKey) {
        for (var i = 0; i < $scope.chartPeriod.length; i++) {
            if ($scope.chartPeriod[i]['key'] == periodKey) {
                return $scope.chartPeriod[i];
            }
        }
        return $scope.chartPeriod[3];
    };
    $scope.getTypeByKey = function(typeKey) {
        for (var i = 0; i < $scope.chartTypes.length; i++) {
            if ($scope.chartTypes[i]['key'] == typeKey) {
                return $scope.chartTypes[i];
            }
        }
        return $scope.chartTypes[0];
    };
    $scope.isPeriodSelected = function(periodId) {
        return $scope.currentPeriod.name == $scope.chartPeriod[periodId].name;
    };
    $scope.handleNewPeriod = function(periodId) {
        if ($scope.currentPeriod.name == $scope.chartPeriod[periodId].name) {
            return;
        };
        if ($scope.chartPeriod[periodId].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to see the " + $scope.chartPeriod[periodId].name + " chart time period.");
        } else {
            $scope.currentPeriod = $scope.chartPeriod[periodId];
            $location.search('period', $scope.currentPeriod.key);
            $scope.buildChart(true);
        }
    };
    $scope.isTypeSelected = function(typeId) {
        return $scope.currentType.key == $scope.chartTypes[typeId].key;
    };
    $scope.handleNewType = function(typeId) {
        if ($scope.currentType.key == $scope.chartTypes[typeId].key) {
            return;
        }
        if ($scope.chartTypes[typeId].requiresLogin && !userManager.isLoggedIn()) {
            cModalService.showLoginModal("Please login or signup and you'll be able to see the " + $scope.chartTypes[typeId].name + " chart type.");
        } else {
            $scope.currentType = $scope.chartTypes[typeId];
            $location.search('type', $scope.currentType.key);
            $scope.buildChart(true);
        }
    };
    $scope.changeCurrency = $rootScope.$on("ChangeCurrency", function(event, symbol) {
        $scope.handleNewSymbol(symbol);
    });
    $scope.changeView = $rootScope.$on('ChangeView', function(event, viewChangeParams) {
        $scope.killListeners();
    });
    $scope.generateNewChart = function() {
        var exportEnabled = !CCC.STATIC.UTIL.isMobile(navigator.userAgent);
        var panEventsEnabled = exportEnabled;
        var valueAxes = {
            axisAlpha: 0,
            position: "left",
            inside: true
        };
        var legend = {
            enabled: false
        };
        if ($scope.currentType.key != "Vol" && $scope.currentType.key != "VolTo") {
            valueAxes = {
                stackType: '100%',
                axisAlpha: 0,
                gridAlpha: 0.07,
                position: 'left',
                inside: true
            };
            legend = {
                align: "center",
                equalWidths: true,
                periodValueText: "[[percents]]",
                valueAlign: "right",
                valueText: "[[percents]]%",
                valueWidth: 50
            };
        }
        $scope.chartConfig = {
            type: "serial",
            theme: "none",
            legend: legend,
            zoomOutText: '',
            dataProvider: $scope.currentDataSet,
            panEventsEnabled: panEventsEnabled,
            marginTop: 0,
            marginRight: 10,
            marginLeft: 10,
            marginBottom: 30,
            autoMargins: false,
            balloon: {
                adjustBorderColor: false,
                horizontalPadding: 10,
                verticalPadding: 8,
                color: "#ffffff",
                borderThickness: 2
            },
            addClassNames: true,
            pathToImages: "/images/",
            categoryField: "timeDate",
            valueAxes: [valueAxes],
            parseDates: true,
            categoryAxis: {
                minPeriod: $scope.currentPeriod.period,
                maxSeries: $scope.currentDataSet.length + 10,
                parseDates: true,
                equalSpacing: true,
                labelsEnabled: !panEventsEnabled
            },
            graphs: [],
            chartCursor: {
                valueBalloonsEnabled: true,
                zoomable: panEventsEnabled,
                categoryBalloonEnabled: true,
                categoryBalloonDateFormat: $scope.currentPeriod.format
            },
            panelsSettings: {
                panEventsEnabled: panEventsEnabled,
                usePrefixes: false
            },
            chartScrollbar: {
                graphType: "line",
                usePeriod: $scope.currentPeriod.period,
                updateOnReleaseOnly: true,
                enabled: panEventsEnabled,
                oppositeAxis: false,
                backgroundColor: "#444",
                backgroundAlpha: 0.7,
                graphFillAlpha: 0.5,
                graphLineAlpha: 0.5,
                selectedBackgroundColor: "#ffffff",
                selectedBackgroundAlpha: 0.4,
                selectedGraphFillAlpha: 0,
                selectedGraphLineAlpha: 1,
                autoGridCount: true,
                gridAlpha: 0.15,
                scrollbarHeight: 30
            },
            export: {
                enabled: exportEnabled,
                path: $scope.baseImagesPath,
                drawing: {
                    enabled: false
                },
                menu: chartUtil.addDownloadButtonToChart(),
                menuReviver: function(item, li) {
                    if (item.hasOwnProperty("title")) {
                        li.setAttribute("title", item.title);
                    }
                    if (item.hasOwnProperty("idHtml")) {
                        li.id = item.idHtml;
                    }
                    return li;
                },
                fileName: $scope.currentPeriod.type + '_' + $scope.currentType.key + '_' + $scope.toSymbol + '_' + $scope.currentPeriod.maxPoints + '_' + $scope.currentPeriod.aggregation
            }
        };
        if ($scope.currentType.key == "Vol") {
            $scope.chartConfig.chartScrollbar['graph'] = 'base';
            chartUtil.topVolumeColumn($scope.chartConfig.graphs, $scope.fromSymbol, 'volumefrom');
        } else if ($scope.currentType.key == "VolTo") {
            $scope.chartConfig.chartScrollbar['graph'] = 'base';
            chartUtil.topVolumeColumn($scope.chartConfig.graphs, $scope.toSymbol, 'volumeto');
        } else {
            for (var i = 0, len = $scope.valuesToLoad.length; i < len; i++) {
                var colorId = 0;
                var fieldName = '';
                if (i < $scope.chartColorsIds.length) {
                    colorId = i;
                }
                if ($scope.currentType.key == "Currencies") {
                    fieldName = $scope.valuesToLoad[i].toSymbol;
                } else {
                    fieldName = $scope.valuesToLoad[i].exchange;
                }
                chartUtil.topStacked($scope.chartConfig.graphs, fieldName, 'volumefrom', $scope.chartColors[$scope.chartColorsIds[colorId]]['Hex']);
                if (i == 0) {
                    $scope.chartConfig.chartScrollbar['graph'] = fieldName + '_' + 'volumefrom';
                }
            }
        }
        $scope.chart = AmCharts.makeChart($scope.chartid, $scope.chartConfig);
    };
    $scope.buildChart = function(updateData) {
        if (!subscriptionManager.hasSubs()) {
            return;
        }
        if (!updateData && $scope.currentDataSet.length > 0) {
            $scope.generateNewChart();
        } else {
            $scope.getHistoData();
        }
    };
    $scope.getHistoData = function() {
        $scope.dataIsLoading = true;
        var pointsToRequest = false;
        if (!$scope.currentPeriod.allData) {
            pointsToRequest = $scope.currentPeriod.maxPoints;
        }
        if ($scope.currentType.key == "Vol" || $scope.currentType.key == "VolTo") {
            chartUtil.getHistoFromMinApi($scope.currentPeriod.type, $scope.exchange, $scope.fromSymbol, $scope.toSymbol, pointsToRequest, $scope.currentPeriod.aggregation).success(function(data) {
                $scope.currentDataSet = chartUtil.polyfillChartData(data, $scope.currentPeriod.polyfill, 0);
                $scope.currentDataSet = $scope.currentDataSet.data;
                $scope.generateNewChart();
                $scope.dataIsLoading = false;
                $scope.dataLoaded = true;
            }).error(function(data) {
                $scope.currentDataSet = [];
                $scope.generateNewChart();
                $scope.dataIsLoading = false;
                $scope.dataLoaded = true;
            });
        }
        if ($scope.currentType.key == "Currencies") {
            subscriptionManager.getTopPairsFromMinApi($scope.fromSymbol, $scope.maxCurrencyPairs).success(function(data) {
                $scope.valuesToLoad = data.Data;
                var valueRemoved = false;
                if ($scope.valuesToLoad.length > 0) {
                    for (var i = 0; i < $scope.valuesToLoad.length; i++) {
                        if ($scope.valuesToLoad[i].fromSymbol == $scope.fromSymbol && $scope.valuesToLoad[i].toSymbol == $scope.toSymbol) {
                            $scope.valuesToLoad.splice(i, 1);
                            valueRemoved = true;
                        }
                    }
                    if (!valueRemoved) {
                        $scope.valuesToLoad.pop();
                    }
                    $scope.valuesToLoad.unshift({
                        exchange: 'CCCAGG',
                        fromSymbol: $scope.fromSymbol,
                        toSymbol: $scope.toSymbol
                    });
                }
                $scope.loadMultiHistoData(0, [], 'toSymbol');
            }).error(function(data) {
                $scope.valuesToLoad = [];
                $scope.generateNewChart();
                $scope.dataIsLoading = false;
                $scope.dataLoaded = true;
            });
        }
        if ($scope.currentType.key == "Exchanges") {
            subscriptionManager.getTopExchangesFromMinApi($scope.fromSymbol, $scope.toSymbol, $scope.maxExchanges).success(function(data) {
                $scope.valuesToLoad = data.Data;
                $scope.loadMultiHistoData(0, [], 'exchange');
            }).error(function(data) {
                $scope.valuesToLoad = [];
                $scope.generateNewChart();
                $scope.dataIsLoading = false;
                $scope.dataLoaded = true;
            });
        }
    };
    $scope.loadMultiHistoData = function(id, loadedData, varField) {
        if (id == $scope.valuesToLoad.length) {
            $scope.currentDataSet = loadedData;
            $scope.generateNewChart();
            $scope.dataIsLoading = false;
            $scope.dataLoaded = true;
            return;
        }
        var pointsToRequest = false;
        if (!$scope.currentPeriod.allData) {
            pointsToRequest = $scope.currentPeriod.maxPoints;
        }
        chartUtil.getHistoFromMinApi($scope.currentPeriod.type, $scope.valuesToLoad[id].exchange, $scope.valuesToLoad[id].fromSymbol, $scope.valuesToLoad[id].toSymbol, pointsToRequest, $scope.currentPeriod.aggregation).success(function(data) {
            var currentBatch = chartUtil.polyfillChartData(data, $scope.currentPeriod.polyfill, 0);
            currentBatch = currentBatch.data;
            chartUtil.appendData(loadedData, currentBatch, 'volumefrom', $scope.valuesToLoad[id][varField]);
            id = id + 1;
            $scope.loadMultiHistoData(id, loadedData, varField);
        }).error(function(data) {
            chartUtil.appendData(loadedData, [], 'volumefrom', $scope.valuesToLoad[id][varField]);
            id = id + 1;
            $scope.loadMultiHistoData(id, loadedData, varField);
        });
    }
    if ($stateParams.hasOwnProperty("Symbol") && subscriptionManager.getCurrentAggChartObj().hasOwnProperty($stateParams.Symbol.toUpperCase())) {
        $scope.computedChart = subscriptionManager.getCurrentAggChartByToSymbol($stateParams.Symbol);
    } else {
        $scope.computedChart = subscriptionManager.getCurrentAggChart();
    }
    var locationSearch = $location.search();
    if (locationSearch.hasOwnProperty('period')) {
        $scope.currentPeriod = $scope.getPeriodByKey(locationSearch['period']);
    } else {
        $scope.currentPeriod = $scope.chartPeriod[3];
    }
    if (locationSearch.hasOwnProperty('type')) {
        $scope.currentType = $scope.getTypeByKey(locationSearch['type']);
    } else {
        $scope.currentType = $scope.chartTypes[0];
    }
    $scope.exchange = $scope.computedChart.exchange;
    $scope.fromSymbol = $scope.computedChart.fromsymbol;
    $scope.toSymbol = $scope.computedChart.tosymbol;
    $scope.buildChart(true);
}]);;;;
angular.module('ccc-app').directive('chartHistoVolume', function() {
    return {
        restrict: 'E',
        templateUrl: 'charts/histo-volume.html',
        controller: 'volumeBarChartSerialCtrl',
        scope: {
            chartid: "@"
        },
        link: function(scope, element, attrs) {}
    };
});;;;